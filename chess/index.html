<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess & Chill</title>
    
    <!-- CSS de Chessboard.js -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    
    <!-- Biblioteca de Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- Estilos CSS (Modo Oscuro y Redise√±o SPA) -->
    <style>
        :root {
            --bg-primary: #1e1e2e;
            --bg-secondary: #27293d;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --border-color: #444455;
            --primary-accent: #885fff;
            --secondary-accent: #00e6a1;
            --warning-accent: #ffc107;
            --purple-accent: #c56eff;
            --danger-accent: #ff5572;
            --correct-accent: #2ecc71;
        }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Evitar scroll en la app principal */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        h1, h2, h3, h4 {
            color: var(--text-primary);
            font-weight: 700;
            text-align: center;
        }
        
        /* Contenedor Base de Vistas */
        .app-view {
            width: 100%;
            height: 100%;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Contenedor de Tarjeta (Login, Setup) */
        .card-container {
            width: 100%;
            max-width: 620px;
            padding: 25px;
            background-color: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        
        #loginView {
            display: flex; /* Mostrar por defecto */
        }
        
        #loginError {
            color: var(--danger-accent);
            margin-top: 15px;
            min-height: 1.2em;
            font-size: 0.9rem;
        }
        
        .login-input {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 8px;
            margin-top: 8px;
            box-sizing: border-box;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .login-input:focus {
            outline: none;
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 3px rgba(136, 95, 255, 0.3);
        }
        
        .login-label {
            margin-top: 15px;
            display: block;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        button {
            color: white;
            border: none;
            padding: 14px 22px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            background-color: var(--primary-accent);
            margin-top: 10px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* --- Vista Principal de la App (Post-Login) --- */
        #mainAppView {
            justify-content: flex-start;
        }

        /* √Årea de Contenido de Pesta√±as */
        #mainContentArea {
            width: 100%;
            height: calc(100% - 70px); /* Altura total menos la barra de navegaci√≥n */
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Cada Pesta√±a individual */
        .tab-view {
            display: none; /* Ocultas por defecto */
            width: 100%;
            max-width: 600px;
        }
        .tab-view.active {
            display: block;
        }

        /* --- Barra de Navegaci√≥n Inferior --- */
        #bottomNav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
            z-index: 100;
        }
        .nav-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            padding: 8px;
            border-radius: 8px;
            width: 80px;
            transition: color 0.2s, background-color 0.2s;
        }
        .nav-button svg {
            width: 24px;
            height: 24px;
            stroke: var(--text-secondary);
            transition: stroke 0.2s;
            margin-bottom: 4px;
        }
        .nav-button:hover {
            background-color: var(--border-color);
        }
        .nav-button.active {
            color: var(--primary-accent);
        }
        .nav-button.active svg {
            stroke: var(--primary-accent);
        }

        /* --- Estilos de Pesta√±as --- */
        #dashboardView { text-align: center; }
        #authStatus { font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 20px; word-break: break-all; line-height: 1.5; }
        #authStatus strong { color: var(--text-primary); }
        .menu-buttons { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 320px; margin: 0 auto; }
        .menu-buttons button { font-size: 1.2rem; padding: 16px 30px; }
        
        .menu-buttons button#playQuickMatchButton { background-color: var(--primary-accent); }
        .menu-buttons button#playAiButton { background-color: var(--secondary-accent); color: #1e1e2e; font-size: 1rem; padding: 14px 20px;}
        .menu-buttons button#playMatchmakingButton { background-color: var(--warning-accent); color: #1e1e2e; font-size: 1rem; padding: 14px 20px;}
        
        #puzzlesView { text-align: center; padding-top: 20px; }
        #puzzlesView p { font-size: 1.1rem; color: var(--text-primary); line-height: 1.6; }
        #startPuzzleButton { background-color: var(--purple-accent); font-size: 1.3rem; padding: 20px 40px; }

        #friendsView { text-align: center; }
        .setup-section { width: 100%; margin-top: 15px; }
        .setup-section input[type="text"] { width: 100%; padding: 12px; font-size: 1rem; }
        .setup-section button { background-color: var(--secondary-accent); color: var(--bg-primary); margin-top: 15px; }
        
        .list-container {
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 15px;
            padding: 10px;
            background-color: var(--bg-primary);
        }
        .list-item { padding: 12px; border-bottom: 1px solid var(--border-color); }
        .list-item:last-child { border-bottom: none; }
        .list-item span { font-weight: 600; color: var(--text-primary); }
        
        /* --- Contenido Pesta√±as --- */
        .tab-icon {
            width: 60px;
            height: 60px;
            stroke: var(--purple-accent);
            margin: 10px auto;
        }
        .how-to-list {
            text-align: left;
            color: var(--text-secondary);
            background-color: var(--bg-primary);
            padding: 15px 20px 15px 40px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }
        .how-to-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        .stats-container {
            width: 100%;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            box-sizing: border-box;
        }
        .stats-container h2 {
            margin-top: 0;
            color: var(--text-primary);
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            color: var(--text-secondary);
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .stat-item:last-child { border-bottom: none; }
        .stat-item span:last-child { font-weight: 600; color: var(--text-primary); }


        /* --- Vistas de Superposici√≥n (Game, Setup, Matchmaking) --- */
        #gameSetupView, #matchmakingView, #fakeMatchmakingView {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 200;
        }

        /* Slider de ELO */
        #eloSlider {
            -webkit-appearance: none; width: 90%; height: 10px; border-radius: 5px;   
            background: var(--bg-primary); outline: none; opacity: 0.8;
            -webkit-transition: .2s; transition: opacity .2s; margin-top: 10px;
            border: 1px solid var(--border-color);
        }
        #eloSlider:hover { opacity: 1; }
        #eloSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
            border-radius: 50%; background: var(--secondary-accent); cursor: pointer;
            border: 3px solid var(--bg-secondary); box-shadow: 0 0 10px rgba(0, 230, 161, 0.5);
        }
        #eloValue { font-size: 1.1rem; font-weight: 600; color: var(--secondary-accent); margin-top: 10px; }
        #startAiGameButton { background-color: var(--secondary-accent); color: var(--bg-primary); }

        /* Matchmaking */
        #matchmakingStatus, #fakeMatchmakingStatus { 
            font-size: 1.2rem; font-weight: 600; color: var(--warning-accent); margin: 20px 0; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner {
            border: 4px solid var(--border-color); border-top: 4px solid var(--warning-accent);
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin: 20px 0;
        }

        /* --- Vista de Juego (Pantalla Completa) --- */
        #gameView {
            background-color: var(--bg-primary);
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
            z-index: 150;
        }
        
        .game-layout {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 900px;
            align-items: flex-start;
        }
        .game-column-left {
            flex: 1;
            min-width: 320px; /* Ancho m√≠nimo del tablero */
            max-width: 600px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-column-right {
            flex: 0 0 250px; /* Ancho fijo para PGN */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .board-container {
            width: 100%;
            max-width: 600px;
            margin: 10px auto;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            /* MODIFICACI√ìN: Se elimin√≥ 'overflow: hidden;' que causaba que las piezas desaparecieran al arrastrar */
        }
        #myBoard, #reviewBoard { width: 100%; border-radius: 6px; }
        /* Asegurar que las piezas arrastradas sean visibles */
/* Asegurar que las piezas sean visibles */
#myBoard img, #reviewBoard img {
    z-index: 100 !important;
}

/* Pieza durante el arrastre */
.piece-417db {
    z-index: 9999 !important;
}
        
        .status-container { margin-top: 15px; text-align: center; }
        #status { font-size: 1.2rem; font-weight: 600; color: var(--text-primary); min-height: 1.5rem; margin-bottom: 10px; }
        #puzzleStatus { font-size: 1.1rem; font-weight: 600; min-height: 1.4rem; margin-top: 10px; }
        #puzzleStatus.correct { color: var(--correct-accent); }
        #puzzleStatus.incorrect { color: var(--danger-accent); }
        
        #pgn, #reviewPgn {
            width: 100%;
            height: 300px; /* M√°s alto */
            max-height: 40vh;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.9rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
            box-sizing: border-box;
        }
        #reviewPgn { height: 200px; max-height: 200px; }
        
        /* Contenedor para botones de juego */
        .game-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .game-actions button {
            width: 100%;
            font-size: 1rem;
            padding: 12px;
        }
        
        #hintButton {
            background-color: var(--warning-accent);
            color: var(--bg-primary);
        }
        #drawButton {
            background-color: #5a6a8a;
        }
        #resignButton {
            background-color: var(--danger-accent);
        }
        
        /* MODIFICADO: Cambiado a 'outline' para no tapar la pieza */
        .highlight-hint { 
            outline: 4px solid rgba(255, 193, 7, 0.9) !important;
            outline-offset: -4px; /* Dibuja el borde hacia adentro */
        }
        
        #backToMenuButton, #backToMenuFromReviewButton {
            background-color: var(--danger-accent);
            margin-top: 20px;
        }
        
        .timer-display {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            background-color: var(--bg-secondary);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 120px;
            text-align: center;
            margin: 5px 0;
            display: none;
        }
        .timer-display.active-timer {
            color: var(--warning-accent);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
        }

        /* Nombres de Jugadores */
        .player-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 10px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #opponentName { margin-bottom: 5px; }
        #playerName { margin-top: 5px; }

        /* Barra de Emojis */
        .emoji-bar {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
        }
        .emoji-bar h4 { margin: 0 0 10px 0; }
        .emoji-buttons { display: flex; justify-content: space-around; }
        .emoji-btn {
            font-size: 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            margin: 0;
            box-shadow: none;
            transition: transform 0.2s;
        }
        .emoji-btn:hover { transform: scale(1.2); }
        
        #emoji-display-opponent, #emoji-display-player {
            position: fixed;
            font-size: 3rem;
            opacity: 0;
            display: none; 
            z-index: 1000;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        /* Posiciones de Emojis (Ajustar seg√∫n sea necesario) */
        #emoji-display-opponent { top: 20%; left: 50%; transform: translateX(-50%); }
        #emoji-display-player { bottom: 20%; left: 50%; transform: translateX(-50%); }

        /* Vista de Revisi√≥n */
        #reviewView {
            background-color: var(--bg-primary);
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
            z-index: 150;
        }
        .review-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .review-controls button {
            font-size: 1.2rem;
            padding: 10px 15px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }
        #reviewMoveEval {
            margin-top: 15px;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--text-primary);
            min-height: 28px; /* Para que no salte al cargar */
        }
        .eval-icon {
            width: 28px;
            height: 28px;
        }
        
        /* Dise√±o Responsivo para el juego */
        @media (max-width: 768px) {
            .game-layout {
                flex-direction: column;
                max-width: 600px;
            }
            .game-column-right {
                order: -1; /* Poner el estado y PGN arriba */
                width: 100%;
                flex: 1;
                box-sizing: border-box;
            }
            #pgn, #reviewPgn {
                height: 100px; /* M√°s peque√±o en m√≥vil */
                max-height: 100px;
            }
            .game-actions {
                flex-direction: row; /* Botones en fila */
                justify-content: space-around;
            }
            .game-actions button {
                width: auto;
                font-size: 0.9rem;
            }
            #gameView, #reviewView {
                justify-content: flex-start; /* Alinear al principio */
            }
            #backToMenuButton {
                margin-top: 10px;
            }
            .review-controls button { font-size: 1rem; padding: 8px 10px; }
            #emoji-display-opponent { top: 15%; }
            #emoji-display-player { bottom: 15%; }
        }

        /* Video de fondo */
        #background-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1; /* Detr√°s de todo el contenido */
            filter: brightness(50%); /* Oscurecer el video */
        }

        /* Asegurar que el contenido est√© encima del video */
        body {
            position: relative;
            z-index: 1;
        }
        
    </style>
</head>
<body>

    <!-- Video de fondo -->
    <!-- NOTA: El video se muestra por defecto, pero se oculta en showView('loginView') -->
    <video id="background-video" autoplay muted loop>
        <source src="bg.mp4" type="video/mp4">
        Tu navegador no soporta la etiqueta de video.
    </video>

    <!-- Bot√≥n para activar/desactivar el sonido del video -->
    <!-- NOTA: Est√° fuera de las vistas para ser un elemento flotante, visible si el video est√° visible. -->
    <button id="toggleSoundButton" style="
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background-color: rgba(39, 41, 61, 0.8); /* Semi-transparente */
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 10px 15px;
        font-size: 0.9rem;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    ">üîä Activar Sonido</button>

    <!-- Vista de Login -->
    <div id="loginView" class="app-view">
        <div class="card-container">
            <h1>Ajedrez Online</h1>
            <div class="setup-section" style="width: 90%;">
                <label for="loginUsername" class="login-label">Usuario:</label>
                <input type="text" id="loginUsername" placeholder="tu-usuario" class="login-input">
                <label for="loginPassword" class="login-label">Contrase√±a:</label>
                <input type="password" id="loginPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" class="login-input">
            </div>
            <div id="loginError"></div>
            <div style="margin-top: 20px; display: flex; justify-content: space-around; width: 90%;">
                <button id="loginButton" style="font-size: 1rem; padding: 12px 20px;">Iniciar Sesi√≥n</button>
                <button id="registerButton" style="font-size: 1rem; padding: 12px 20px; background-color: var(--secondary-accent); color: var(--bg-primary);">Registrarse</button>
            </div>
        </div>
    </div>

    <!-- Vista Principal de la App (con Pesta√±as) -->
    <div id="mainAppView" class="app-view">
        <!-- Contenido de la Pesta√±a -->
        <div id="mainContentArea">
            
            <!-- Pesta√±a 1: Jugar (Dashboard) -->
            <div id="dashboardView" class="tab-view active">
                <h1>üåø Chess & Chill</h1>
                <div id="authStatus">Conectando...</div>
                <div class="menu-buttons">
                    <button id="playQuickMatchButton">Jugar partida (5min)</button>
                    <button id="playAiButton">Jugar contra IA</button>
                    <button id="playMatchmakingButton">Buscar Partida (Lento)</button>
                </div>
                
                <div class="stats-container">
                    <h2>Tus Estad√≠sticas</h2>
                    <div class="stat-item">
                        <span>ELO (Cl√°sico)</span>
                        <span id="userClassicElo">100</span>
                    </div>
                    <div class="stat-item">
                        <span>ELO (Problemas)</span>
                        <span>1450</span>
                    </div>
                    <div class="stat-item">
                        <span>Victorias</span>
                        <span>0</span>
                    </div>
                    <div class="stat-item">
                        <span>Derrotas</span>
                        <span>0</span>
                    </div>
                </div>
                
                <button id="logoutButton" style="margin-top: 30px; font-size: 0.9rem; padding: 10px 15px;">Cerrar Sesi√≥n</button>
            </div>

            <!-- Pesta√±a 2: Problemas -->
            <div id="puzzlesView" class="tab-view">
                <h1>Problemas de Ajedrez</h1>
                <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 21h-6a2 2 0 0 1-2-2v-2h10v2a2 2 0 0 1-2 2z"/><path d="M12 11V3"/><path d="M12 3l-2.5 2.5"/><path d="M12 3l2.5 2.5"/><path d="M12 11h-4a2.83 2.83 0 0 0-3 3v2a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-2a2.83 2.83 0 0 0-3-3h-4z"/></svg>
                <p>Resuelve problemas aleatorios de una base de datos de m√°s de 10,000. ¬°Encuentra la mejor jugada!</p>
                <button id="startPuzzleButton">Comenzar Problemas</button>
                <div class="stats-container" style="margin-top: 20px;">
                    <h2 style="margin-top: 0;">C√≥mo Funciona</h2>
                    <ul class="how-to-list">
                        <li>Se cargar√° un problema aleatorio de nuestra base de datos.</li>
                        <li>Tu objetivo es encontrar el **√∫nico movimiento ganador**.</li>
                        <li>Si aciertas, se cargar√° un nuevo problema al instante.</li>
                        <li>¬°Usa el bot√≥n de pista si te quedas atascado!</li>
                    </ul>
                </div>
            </div>
            
            <!-- Pesta√±a 3: Amigos -->
            <div id="friendsView" class="tab-view">
                <h1>Amigos</h1>
                <div class="setup-section">
                    <h4>A√±adir Amigo por Usuario</h4>
                    <input type="text" id="addFriendUsernameInput" placeholder="Nombre de usuario del amigo" class="login-input" style="width:100%">
                    <button id="addFriendButton">A√±adir</button>
                    <div id="addFriendStatus" style="font-size: 0.9rem; margin-top: 10px;"></div>
                </div>
                <hr style="width:100%; margin: 20px 0; border: 1px solid var(--border-color);">
                <h4>Mi Lista de Amigos</h4>
                <div id="friendsListContainer" class="list-container">
                    <!-- Los amigos se cargar√°n aqu√≠ din√°micamente -->
                </div>
            </div>

        </div>

        <!-- Barra de Navegaci√≥n Inferior -->
        <nav id="bottomNav">
            <button id="navPlay" class="nav-button active">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8a6 6 0 0 0-12 0v-2h12v2Z"/><path d="M18 10v6a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2v-6"/><path d="M12 10v2"/><path d="M12 14v2"/><path d="m15 12-3-3-3 3"/></svg>
                <span>Jugar</span>
            </button>
            <button id="navPuzzles" class="nav-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="m10 13-2 2 2 2"/><path d="m14 17 2-2-2-2"/></svg>
                <span>Problemas</span>
            </button>
            <button id="navFriends" class="nav-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                <span>Amigos</span>
            </button>
        </nav>
    </div>

    <!-- Vista de Configuraci√≥n IA (Superposici√≥n) -->
    <div id="gameSetupView" class="app-view">
        <div class="card-container">
            <h1>Configurar Partida vs IA</h1>
            <div class="setup-section" style="width: 100%; text-align: center;">
                <h4>ELO</h4>
                <!-- MODIFICADO: min="100" y value="500" -->
                <input type="range" id="eloSlider" min="100" max="2800" value="500" step="100">
                <div id="eloValue">500</div>
            </div>
            <button id="startAiGameButton">Empezar Partida</button>
            <button id="backButtonSetup" class="back-button">Cancelar</button>
        </div>
    </div>
    
    <!-- Vista de Matchmaking (Superposici√≥n) -->
    <div id="matchmakingView" class="app-view">
        <div class="card-container">
            <h1>Buscando Partida</h1>
            <div id="matchmakingStatus">Buscando oponente...</div>
            <div class="spinner"></div>
            <button id="cancelMatchmakingButton" class="back-button">Cancelar B√∫squeda</button>
        </div>
    </div>
    
    <!-- NUEVA VISTA: Fake Matchmaking (Superposici√≥n) -->
    <div id="fakeMatchmakingView" class="app-view">
        <div class="card-container">
            <h1>Buscando Partida</h1>
            <!-- Se actualiza con el ELO simulado -->
            <div id="fakeMatchmakingStatus">Buscando oponente con ELO: <span id="fakeOpponentEloDisplay">...</span></div>
            <div class="spinner"></div>
            <button id="cancelFakeMatchmakingButton" class="back-button">Cancelar B√∫squeda</button>
        </div>
    </div>

    <!-- Vista de Juego (Pantalla Completa) -->
    <div id="gameView" class="app-view">
        <div class="game-layout">
            
            <!-- Columna Izquierda: Tablero y Timers -->
            <div class="game-column-left">
                <h1 id="gameTitle">Ajedrez</h1>
                <!-- NUEVO: Nombre Oponente -->
                <div class="player-name" id="opponentName">Oponente</div>
                <div class="timer-display" id="opponentTimer">5:00</div>
                <div class="game-info"><span id="gameIdDisplay"></span></div>
                <div class="board-container">
                    <div id="myBoard"></div>
                </div>
                <!-- NUEVO: Nombre Jugador -->
                <div class="player-name" id="playerName">Jugador</div>
                <div class="timer-display" id="playerTimer">5:00</div>
            </div>
            
            <!-- Columna Derecha: Estado, PGN y Acciones -->
            <div class="game-column-right">
                <div class="status-container">
                    <h3>Estado: <span id="status">Cargando...</span></h3>
                    <div id="puzzleStatus"></div>
                </div>
                
                <textarea id="pgn" readonly></textarea>
                
                <div class="game-actions">
                    <button id="hintButton" style="display: none;">Pista</button>
                    <!-- MODIFICADO: El texto se cambiar√° por JS -->
                    <button id="newGameButton" style="display: none; background-color: #5a6a8a;">Juego Nuevo</button>
                    <button id="drawButton" style="display: none;">Pedir Tablas</button>
                    <button id="resignButton" style="display: none;">Rendirse</button>
                </div>

                <!-- NUEVO: Barra de Emojis -->
                <div class="emoji-bar" style="display: none;">
                    <h4>Reacciones</h4>
                    <div class="emoji-buttons">
                        <button class="emoji-btn" data-emoji="üëç">üëç</button>
                        <button class="emoji-btn" data-emoji="üòÇ">üòÇ</button>
                        <button class="emoji-btn" data-emoji="üî•">üî•</button>
                        <button class="emoji-btn" data-emoji="ü§î">ü§î</button>
                        <button class="emoji-btn" data-emoji="üëé">üëé</button>
                    </div>
                </div>

            </div>
            
        </div>
        
        <button id="backToMenuButton">Abandonar y Volver</button>
    </div>

    <!-- NUEVA VISTA: Revisi√≥n de Partida -->
    <div id="reviewView" class="app-view">
        <div class="game-layout">
            <div class="game-column-left">
                <h1 id="reviewGameTitle">Revisi√≥n de Partida</h1>
                <div class="board-container">
                    <div id="reviewBoard"></div>
                </div>
                <!-- NUEVO: Evaluaci√≥n de Jugada -->
                <h3 id="reviewMoveEval"></h3>
            </div>
            <div class="game-column-right">
                <h3>Movimientos (PGN)</h3>
                <textarea id="reviewPgn" readonly></textarea>
                <!-- NUEVO: Controles de Revisi√≥n -->
                <div class="review-controls">
                    <button id="reviewFirstBtn">‚èÆ</button>
                    <button id="reviewPrevBtn">‚è™</button>
                    <button id="reviewNextBtn">‚è©</button>
                    <button id="reviewLastBtn">‚è≠</button>
                </div>
                <button id="backToMenuFromReviewButton">Volver al Men√∫</button>
            </div>
        </div>
    </div>

    <!-- NUEVO: Contenedores de Emojis (globales) -->
    <div id="emoji-display-opponent"></div>
    <div id="emoji-display-player"></div>

    <!-- Pre-carga de Sonidos -->
    <audio id="audioGameStart" src="https://logise1.github.io/chess/assets/audio/game-start.mp3" preload="auto"></audio>
    <audio id="audioMove" src="https://logise1.github.io/chess/assets/audio/move-self.mp3" preload="auto"></audio>
    <audio id="audioCapture" src="https://logise1.github.io/chess/assets/audio/capture.mp3" preload="auto"></audio>
    <audio id="audioCastle" src="https://logise1.github.io/chess/assets/audio/castle.mp3" preload="auto"></audio>
    <audio id="audioGameEnd" src="https://logise1.github.io/chess/assets/audio/game-end.mp3" preload="auto"></audio>

    <!-- SDKs de Firebase (v11.6.1) -->
    <script type="module">
        // Importar funciones de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            onAuthStateChanged, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            signOut 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc,
            setDoc, 
            updateDoc,
            onSnapshot, 
            collection,
            query,
            where,
            getDocs,
            addDoc,
            deleteDoc,
            runTransaction,
            limit,
            serverTimestamp,
            setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Variables Globales de la App ---
        var board = null;
        var game = new Chess();
        var $status, $pgn;
        var stockfish = null;
        var stockfishReady = false;
        var makingMove = false;
        var currentGameMode = null; // 'ai', 'online', 'puzzle', 'bot_match'
        var playerColor = 'w';
        
        // --- GLOBALES PARA ELO Y BOT ---
        var userElo = 100;
        var currentOpponentElo = 0;
        var currentOpponentName = "Oponente";
        var fakeMatchmakingTimer = null;
        const ELO_K_FACTOR = 32;
        var botNames = []; // Load dynamically from usernames.json
        
        // --- GLOBALES PARA EL TEMPORIZADOR ---
        var playerTime = 300; // 5 minutos
        var opponentTime = 300;
        var gameTimerInterval = null;
        var activeTimer = null; // 'w' o 'b'

        // Firebase
        var db, auth;
        var appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        var userId;
        var username;
        
        var firebaseConfig = {
            apiKey: "AIzaSyDWGEMpfCF7OvBiM68uthumbOeDHwWai6M",
            authDomain: "chess-a9347.firebaseapp.com",
            projectId: "chess-a9347",
            storageBucket: "chess-a9347.firebasestorage.app",
            messagingSenderId: "950558367537",
            appId: "1:950558367537:web:4cee83e2053262a4541a10",
            measurementId: "G-Z3KNSZBL2F"
        };
        
        // Listeners de Firebase
        var gameUnsubscribe = null; 
        var matchmakingUnsubscribe = null;
        var friendsUnsubscribe = null;
        var myMatchmakingDocRef = null;
        var currentGameRef = null;
        
        // Puzzles
        let puzzles = []; 
        var currentPuzzle = null;
        var currentPuzzleStep = 0;

        // --- Variables de Revisi√≥n ---
        var reviewBoard = null;
        var reviewGame = new Chess();
        var reviewHistory = [];
        var reviewMoveIndex = -1;
        var finalPgn = '';

        // --- NUEVO: Variables de Emojis Online ---
        var lastOpponentEmojiTimestamp = null;
        
        // Configuraci√≥n del tablero
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd,
            pieceTheme: getPieceTheme,
            snapSpeed: 200,
            moveSpeed: 'medium',
            appearSpeed: 200,
            trashSpeed: 200,
            sparePieces: false
        };

        // --- 1. Inicializaci√≥n ---

        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                setLogLevel('Debug'); 

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        username = user.email ? user.email.split('@')[0] : 'Usuario';
                        console.log("Usuario autenticado:", userId, username);
                        $('#authStatus').html(`Conectado como: <strong>${username}</strong>`);
                        
                        const profileRef = doc(db, 'artifacts', appId, 'public/data', 'userProfiles', userId);
                        getDoc(profileRef).then(docSnap => {
                            if (docSnap.exists()) {
                                // Asegurar que el ELO del usuario nunca sea menor a 100
                                userElo = Math.max(100, docSnap.data().elo || 100);
                            } else {
                                userElo = 100;
                            }
                            $('#userClassicElo').text(Math.round(userElo));
                        });

                        showView('mainAppView');
                        showTabView('dashboardView');
                        loadFriends();
                        initStockfish();
                    } else {
                        userId = null;
                        username = null;
                        console.log("Sin usuario, mostrando login.");
                        showView('loginView');
                        if (friendsUnsubscribe) friendsUnsubscribe();
                    }
                });
            } catch (e) {
                console.error("Error al inicializar Firebase:", e);
                $('#authStatus').text('Error al cargar Firebase.');
            }
        }
        
        async function initStockfish(readyCallback) {
            if (stockfishReady) {
                if (readyCallback) readyCallback();
                return;
            }
            try {
                console.log('Cargando motor de IA...');
                const response = await fetch("https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js");
                if (!response.ok) throw new Error(`Error al descargar stockfish.js: ${response.statusText}`);
                const scriptText = await response.text();
                const blob = new Blob([scriptText], { type: 'application/javascript' });
                const blobUrl = URL.createObjectURL(blob);
                
                stockfish = new Worker(blobUrl);
                
                stockfish.onmessage = function(event) {
                    var message = event.data;

                    if (message === 'uciok') {
                        stockfish.postMessage('isready');
                    } else if (message === 'readyok') {
                        console.log('Motor listo.');
                        stockfishReady = true;
                        if (readyCallback) readyCallback();
                    } else if (message.startsWith('bestmove') && (currentGameMode === 'ai' || currentGameMode === 'bot_match')) {
                        var bestmove = message.split(' ')[1];
                        const move = game.move(bestmove, { sloppy: true });
                        if (move) {
                            if (move.flags.includes('c')) playSound('audioCapture');
                            else if (move.flags.includes('k') || move.flags.includes('q')) playSound('audioCastle');
                            else playSound('audioMove');
                        }
                        
                        // --- MODIFICADO: A√±adido 'true' para forzar animaci√≥n ---
                        board.position(game.fen(), true); 
                        
                        switchTimer();
                        updateStatus();
                        makingMove = false;
                    }
                }
                stockfish.postMessage('uci');
            } catch (e) {
                console.error("No se pudo inicializar Stockfish:", e);
            }
        }

        // --- 2. L√≥gica de Vistas y Navegaci√≥n ---
        
        function showView(viewId) {
            // Asegurar que el video de fondo est√© visible para TODAS las vistas excepto Login
            const backgroundVideo = document.getElementById('background-video');
            const toggleSoundButton = document.getElementById('toggleSoundButton'); // Nuevo

            if (viewId !== 'loginView') {
                backgroundVideo.style.display = 'block';
                toggleSoundButton.style.display = 'block'; // Mostrar el bot√≥n
            } else {
                backgroundVideo.style.display = 'none';
                toggleSoundButton.style.display = 'none'; // Ocultar el bot√≥n
            }

            // Mostrar la vista solicitada
            document.querySelectorAll('.app-view').forEach(view => view.style.display = 'none');
            document.getElementById(viewId).style.display = 'flex';
        }
        
        function showTabView(tabId) {
            // La visibilidad del video ya es manejada por showView('mainAppView')
            
            $('.tab-view').removeClass('active');
            $('#' + tabId).addClass('active');
            
            $('.nav-button').removeClass('active');
            if (tabId === 'dashboardView') $('#navPlay').addClass('active');
            else if (tabId === 'puzzlesView') $('#navPuzzles').addClass('active');
            else if (tabId === 'friendsView') $('#navFriends').addClass('active');
        }

        // --- 3. L√≥gica Auxiliar (Sonidos, Timers) ---

        function playSound(soundId) {
            const audio = document.getElementById(soundId);
            if (audio) {
                audio.currentTime = 0;
                audio.play().catch(e => console.warn("Error al reproducir sonido:", e));
            }
        }

        function startGameTimer() {
            playerTime = 300;
            opponentTime = 300;
            updateTimerDisplay();
            $('#playerTimer, #opponentTimer').show();
            
            activeTimer = 'w';
            if (playerColor === 'w') {
                $('#playerTimer').addClass('active-timer');
                $('#opponentTimer').removeClass('active-timer');
            } else {
                $('#opponentTimer').addClass('active-timer');
                $('#playerTimer').removeClass('active-timer');
            }

            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = setInterval(() => {
                if (game.game_over() || !currentGameMode) {
                    stopGameTimer();
                    return;
                }

                if (activeTimer === playerColor) {
                    playerTime--;
                    if (playerTime <= 0) {
                        playerTime = 0;
                        updateStatus(0); // Derrota por tiempo
                    }
                } else {
                    opponentTime--;
                    if (opponentTime <= 0) {
                        opponentTime = 0;
                        updateStatus(1); // Victoria por tiempo
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }

        function stopGameTimer() {
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = null;
            activeTimer = null;
            $('#playerTimer, #opponentTimer').removeClass('active-timer');
        }

        function updateTimerDisplay() {
            const formatTime = (time) => {
                const minutes = Math.floor(time / 60);
                const seconds = time % 60;
                return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            };
            $('#playerTimer').text(formatTime(playerTime));
            $('#opponentTimer').text(formatTime(opponentTime));
        }

        function switchTimer() {
            if (game.game_over()) {
                stopGameTimer();
                return;
            }
            
            activeTimer = (activeTimer === 'w') ? 'b' : 'w';
            
            if (activeTimer === playerColor) {
                $('#playerTimer').addClass('active-timer');
                $('#opponentTimer').removeClass('active-timer');
            } else {
                $('#opponentTimer').addClass('active-timer');
                $('#playerTimer').removeClass('active-timer');
            }
        }

        // --- Funci√≥n para determinar la profundidad de Stockfish ---
        function calculateMaxDepth(elo) {
            // Se asegura de que el ELO m√≠nimo sea 100
            elo = Math.max(100, Math.min(2800, parseFloat(elo) || 100));
            
            // Para ELOs muy bajos (100 - 500) -> Profundidad 1 a 2.
            if (elo <= 500) {
                // 100 ELO -> Profundidad 1 (M√≠nimo absoluto para garantizar errores)
                // 500 ELO -> Profundidad 2
                return Math.max(1, 1 + Math.round((elo - 100) / 400 * 1)); 
            }
            
            // Para ELOs bajos/medios (500 - 1500) -> Profundidad 2 a 10.
            if (elo <= 1500) {
                // 500 ELO -> Profundidad 2
                // 1500 ELO -> Profundidad 10
                return 2 + Math.round((elo - 500) / 1000 * 8);
            }
            
            // Para ELOs altos (1500 - 2800) -> Profundidad 10 a 20.
            return 10 + Math.round((elo - 1500) / 1300 * 10);
        }

        // --- 4. L√≥gica de Juego (Principal) ---
        
        async function initGame(mode, options = {}) {
            currentGameMode = mode;
            showView('gameView');
            
            game.reset(); // Asegurar reinicio del juego
            makingMove = false;
            playerColor = options.playerColor || 'w';
            finalPgn = '';
            lastOpponentEmojiTimestamp = null; // Resetear timestamp de emoji
            
            $('#pgn, #newGameButton, #hintButton, #playerTimer, #opponentTimer, #drawButton, #resignButton').hide();
            $('#puzzleStatus').text('').removeClass('correct incorrect');
            $('#gameIdDisplay').hide();
            $('.emoji-bar').hide();
            
            if (gameUnsubscribe) gameUnsubscribe();
            if (matchmakingUnsubscribe) matchmakingUnsubscribe();
            if (myMatchmakingDocRef) myMatchmakingDocRef = null;

            config.position = 'start';
            if (board) {
                board.position('start', false); // Sin animaci√≥n al resetear
            } else {
                board = Chessboard('myBoard', config);
            }

            if (mode === 'bot_match' || mode === 'ai') {
                // Ensure minimum ELO is 100
                currentOpponentElo = Math.max(100, options.opponentElo || options.skillLevel); 
                board.orientation(playerColor === 'w' ? 'white' : 'black');
                
                const playerEloDisplay = Math.round(userElo);
                const opponentEloDisplay = Math.round(currentOpponentElo);

                // Nombres y ELO
                if (playerColor === 'w') {
                    $('#playerName').text(`${username} (ELO: ${playerEloDisplay})`);
                    // Cambiamos el nombre para que el modo "Jugar contra IA" parezca m√°s una IA ajustable
                    currentOpponentName = (mode === 'ai') ? `Stockfish ELO ${opponentEloDisplay}` : currentOpponentName;
                    $('#opponentName').text(`${currentOpponentName}`);
                } else {
                    $('#playerName').text(`${username} (ELO: ${playerEloDisplay})`);
                    currentOpponentName = (mode === 'ai') ? `Stockfish ELO ${opponentEloDisplay}` : currentOpponentName;
                    $('#opponentName').text(`${currentOpponentName}`);
                }
                
                // CORRECCI√ìN: Usar el t√≠tulo correcto
                $('#gameTitle').text((mode === 'ai') ? 'Partida vs. IA' : 'Partida R√°pida');
                $('#gameIdDisplay').text('5 min').show();
                $('#pgn, #drawButton, #resignButton, .emoji-bar').show();
                
                stockfish.postMessage('ucinewgame');
                
                // --- MODIFICACI√ìN CLAVE: Ajustar Skill Level y Profundidad ---
                let elo = parseFloat(options.skillLevel) || 100;
                let skillLevel = Math.round(Math.max(0, Math.min(20, (elo - 100) * (20 / 2700))));
                let maxDepth = calculateMaxDepth(elo);
                
                console.log(`Configurando IA: ELO ${elo}, Skill Level ${skillLevel}, Max Depth ${maxDepth}`);
                stockfish.postMessage('setoption name Skill Level value ' + skillLevel);

                game.reset();
                board.start();
                startGameTimer();
                playSound('audioGameStart');

                if (playerColor === 'b') {
                    makingMove = true;
                    $status.text('Oponente est√° pensando...');
                    setTimeout(() => {
                        stockfish.postMessage('position fen ' + game.fen());
                        // Usar la profundidad ajustada
                        stockfish.postMessage('go depth ' + maxDepth);
                    }, 1500);
                }

            } else if (mode === 'online') {
                const { gameId, color } = options;
                playerColor = color; 
                board.orientation(playerColor === 'w' ? 'white' : 'black');
                
                $('#gameTitle').text('Partida Online');
                $('#gameIdDisplay').text(`ID Partida: ${gameId}`).show();
                $('#pgn, #drawButton, #resignButton, .emoji-bar').show();

                const gameDocRef = doc(db, 'artifacts', appId, 'public/data', 'games', gameId);
                currentGameRef = gameDocRef;

                // Nombres y ELO
                const gameDataForNames = await getDoc(gameDocRef);
                if (gameDataForNames.exists()) {
                    const data = gameDataForNames.data();
                    const opponentId = playerColor === 'w' ? data.playerBlack : data.playerWhite;
                    
                    try {
                        const oppProfileRef = doc(db, 'artifacts', appId, 'public/data', 'userProfiles', opponentId);
                        const oppDoc = await getDoc(oppProfileRef);
                        const opponentUsername = oppDoc.exists() ? oppDoc.data().username : 'Oponente';
                        // Asegurar ELO m√≠nimo de 100
                        const opponentElo = oppDoc.exists() ? Math.round(Math.max(100, oppDoc.data().elo || 100)) : 100;

                        if (playerColor === 'w') {
                            $('#playerName').text(`${username} (ELO: ${Math.round(userElo)})`);
                            $('#opponentName').text(`${opponentUsername} (ELO: ${opponentElo})`);
                        } else {
                            $('#playerName').text(`${username} (ELO: ${Math.round(userElo)})`);
                            $('#opponentName').text(`${opponentUsername} (ELO: ${opponentElo})`);
                        }
                    } catch(e) {
                        console.error("Error fetching opponent name", e);
                        $('#playerName').text(`${username} (ELO: ${Math.round(userElo)})`);
                        $('#opponentName').text('Oponente (ELO: 100)');
                    }
                }
                
                gameUnsubscribe = onSnapshot(gameDocRef, (doc) => {
                    if (!doc.exists()) {
                        console.error("La partida no existe.");
                        $status.text("Error: La partida no existe.");
                        return;
                    }
                    const gameData = doc.data();
                    const currentFen = game.fen();
                    const newFen = (gameData.fen === 'start' || !gameData.fen) ? 'start' : gameData.fen;
                    
                    if (newFen !== currentFen) {
                        game.load(newFen);
                        board.position(game.fen(), true); // Animaci√≥n
                    }
                    
                    makingMove = (game.turn() !== playerColor);
                    updateStatus();
                });
                playSound('audioGameStart');
            } else if (mode === 'puzzle') {
                if (options.puzzleIndex >= puzzles.length) {
                    console.error("√çndice de problema fuera de rango");
                    startRandomPuzzle();
                    return;
                }
                
                currentPuzzle = puzzles[options.puzzleIndex];
                currentPuzzleStep = 0;
                playerColor = currentPuzzle.turn;

                const fullFen = `${currentPuzzle.fen} ${currentPuzzle.turn} - - 0 1`;
                if (!game.load(fullFen)) {
                    console.error("Error al cargar FEN del problema:", fullFen);
                    startRandomPuzzle();
                    return;
                }
                
                config.position = currentPuzzle.fen;
                board.position(currentPuzzle.fen, true); // Animaci√≥n
                board.orientation(playerColor === 'w' ? 'white' : 'black');
                
                $('#gameTitle').text(`Problema #${currentPuzzle.index + 1}`);
                $('#gameIdDisplay').hide();
                $('#hintButton').show().prop('disabled', true);
                
                // Nombres
                $('#playerName').text(username);
                $('#opponentName').text('Problema');
                
                makingMove = true;
                getSolutionMove(fullFen, (bestmove) => {
                    console.log(`Soluci√≥n calculada para ${currentPuzzle.name}: ${bestmove}`);
                    currentPuzzle.solution = [bestmove];
                    makingMove = false;
                    $('#hintButton').prop('disabled', false);
                    updateStatus();
                });
            }
            updateStatus();
        }

        function onDragStart(source, piece, position, orientation) {
            if (game.game_over()) return false;
            if (makingMove) return false;
            
            if (currentGameMode === 'puzzle') {
                return piece.search(playerColor) !== -1;
            } else {
                if (game.turn() !== playerColor) return false;
                return piece.search(playerColor) === 0;
            }
        }

        async function onDrop(source, target) {
            // --- L√≥gica de Problemas ---
            if (currentGameMode === 'puzzle') {
                if (!currentPuzzle || currentPuzzle.solution.length === 0) {
                    $('#puzzleStatus').text('Espera a que la IA calcule la soluci√≥n...').addClass('incorrect');
                    return 'snapback';
                }
                
                const $puzzleStatus = $('#puzzleStatus');
                const solutionMove = currentPuzzle.solution[currentPuzzleStep];
                const move = game.move({ from: source, to: target, promotion: 'q' });

                if (move === null) return 'snapback';
                
                if (move.from + move.to === solutionMove) {
                    if (move.flags.includes('c')) playSound('audioCapture');
                    else playSound('audioMove');

                    currentPuzzleStep++;
                    if (currentPuzzleStep === currentPuzzle.solution.length) {
                        $puzzleStatus.text('¬°Correcto! Cargando siguiente problema...').removeClass('incorrect').addClass('correct');
                        makingMove = true;
                        $('#hintButton').hide();
                        setTimeout(startRandomPuzzle, 1500); 
                    } 
                } else {
                    game.undo();
                    $puzzleStatus.text('Movimiento incorrecto. Int√©ntalo de nuevo.').removeClass('correct').addClass('incorrect');
                    return 'snapback';
                }
                return; // onSnapEnd se encargar√° de actualizar
            }

            // --- L√≥gica de IA y Online ---
            var move = game.move({ from: source, to: target, promotion: 'q' });
            if (move === null) return 'snapback';
            
            if (move.flags.includes('c')) playSound('audioCapture');
            else if (move.flags.includes('k') || move.flags.includes('q')) playSound('audioCastle');
            else playSound('audioMove');
            
            if (currentGameMode === 'bot_match') {
                switchTimer();
            }
            
            // updateStatus() se llama en onSnapEnd

            if (currentGameMode === 'ai' || currentGameMode === 'bot_match') {
                makingMove = true;
                $status.text('Oponente est√° pensando...');

                // Recalcular la profundidad de b√∫squeda
                let maxDepth = calculateMaxDepth(currentOpponentElo);
                
                setTimeout(() => {
                    stockfish.postMessage('position fen ' + game.fen());
                    // Usar la profundidad ajustada
                    stockfish.postMessage('go depth ' + maxDepth);
                }, 1500 + Math.random() * 500); // Delay m√°s humano
                
            } else if (currentGameMode === 'online') {
                makingMove = true; 
                try {
                    await updateDoc(doc(db, 'artifacts', appId, 'public/data', 'games', currentGameRef.id), {
                        fen: game.fen(),
                        pgn: game.pgn(),
                        turn: game.turn()
                    });
                } catch (e) {
                    console.error("Error al actualizar la partida:", e);
                    $status.text("Error de conexi√≥n al mover.");
                    game.undo();
                }
            }
        }

        function onSnapEnd() {
            // Sincronizar el tablero con el estado del juego
            board.position(game.fen());
            updateStatus();
        }

        function updateStatus(forcedResult) {
            var status = '';
            var moveColor = (game.turn() === 'w') ? 'Blancas' : 'Negras';
            var gameOver = game.game_over();
            var result = null;

            if (forcedResult !== undefined) {
                gameOver = true;
                result = forcedResult;
                status = (result === 1) ? "¬°Victoria por tiempo!" : "¬°Derrota por tiempo!";
            } else if (gameOver) {
                if (game.in_checkmate()) {
                    result = (game.turn() === playerColor) ? 0 : 1;
                    status = `¬°Jaque Mate! ${result === 1 ? "Ganaste" : "Perdiste"}.`;
                } 
                // CORRECCI√ìN CLAVE: Ser espec√≠fico sobre el tipo de tablas
                else if (game.in_draw()) {
                    result = 0.5;
                    
                    if (game.in_stalemate()) {
                        status = "¬°Tablas por Ahogado!";
                    } else if (game.in_threefold_repetition()) {
                        status = "¬°Tablas por Triple Repetici√≥n!";
                    } else if (game.insufficient_material()) {
                        status = "¬°Tablas por Material Insuficiente!";
                    } else if (game.half_moves() >= 100) { // 50 movimientos = 100 half-moves
                        status = "¬°Tablas por la Regla de 50 Movimientos!";
                    } else {
                        status = "¬°Tablas!"; // Caso de respaldo, aunque in_draw deber√≠a cubrir los casos de arriba
                    }
                } else {
                    // Si game.game_over() es true, pero no es jaque mate ni tablas... ¬°Esto nunca deber√≠a pasar con chess.js!
                    // Pero si pasa, tratamos la posici√≥n como un empate.
                    result = 0.5;
                    status = "¬°Tablas! (Estado Indefinido)";
                }
            }
            
            if (gameOver) {
                stopGameTimer();
                playSound('audioGameEnd');
                $('.emoji-bar').hide();
                finalPgn = game.pgn();
                
                // Bot√≥n de Revisi√≥n
                $('#newGameButton').text('Revisar Partida')
                    .show()
                    .off('click') // Limpiar listener anterior
                    .on('click', () => initReview(finalPgn));

                
                if (currentGameMode === 'bot_match' && result !== null) {
                    const newElo = calculateElo(userElo, currentOpponentElo, result);
                    const eloChange = Math.round(newElo - userElo);
                    
                    status += ` (ELO: ${Math.round(userElo)} ${eloChange >= 0 ? '+' : ''}${eloChange} -> ${Math.round(newElo)})`;
                    
                    userElo = newElo;
                    $('#userClassicElo').text(Math.round(userElo));
                    updateEloInFirebase(newElo);
                    
                    currentGameMode = null;
                }
                
                // Limpiar referencia de partida online
                if (currentGameMode === 'online') {
                    currentGameRef = null;
                    currentGameMode = null;
                }
            } else {
                if (currentGameMode === 'puzzle') {
                    status = `Problema #${currentPuzzle.index + 1}. Mueven ${moveColor}`;
                    $status.css('color', 'var(--text-primary)');
                } else if (currentGameMode === 'online' || currentGameMode === 'bot_match' || currentGameMode === 'ai') {
                    if (game.turn() === playerColor) {
                        status = '¬°Es tu turno! (Mueven ' + moveColor + ')';
                        $status.css('color', 'var(--secondary-accent)');
                    } else {
                        status = 'Turno del oponente (Mueven ' + moveColor + ')';
                        $status.css('color', 'var(--warning-accent)');
                    }
                }
                
                if (game.in_check()) {
                    status += ' (¬°Jaque!)';
                }
            }
            
            $status.text(status);
            $pgn.val(game.pgn({ max_width: 5, newline_char: '\n' }));
            $pgn.scrollTop($pgn[0].scrollHeight);
        }

        function getPieceTheme(piece) {
            var pieceName = piece.toLowerCase(); 
            return 'https://logise1.github.io/chess/assets/' + pieceName + '.png';
        }

        // --- 5. L√≥gica de Modos Espec√≠ficos ---

        function calculateElo(playerElo, opponentElo, result) {
            const expectedScore = 1 / (1 + Math.pow(10, (opponentElo - playerElo) / 400));
            // Se asegura de que el ELO resultante nunca sea menor a 100
            return Math.max(100, playerElo + ELO_K_FACTOR * (result - expectedScore));
        }
        
        async function updateEloInFirebase(newElo) {
            if (!userId) return;
            const profileRef = doc(db, 'artifacts', appId, 'public/data', 'userProfiles', userId);
            try {
                // Asegurar ELO m√≠nimo al guardar
                await updateDoc(profileRef, { elo: Math.max(100, newElo) });
                console.log("ELO actualizado en Firebase:", newElo);
            } catch (e) {
                console.error("Error al actualizar ELO, intentando crear/setear:", e);
                try {
                    await setDoc(profileRef, { elo: Math.max(100, newElo), username: username }, { merge: true });
                } catch (e2) {
                     console.error("Error fatal al guardar ELO:", e2);
                }
            }
        }

        async function startMatchmaking() {
            showView('matchmakingView');
            $('#matchmakingStatus').text('Buscando oponente...');
            const matchmakingQueueRef = collection(db, 'artifacts', appId, 'public/data', 'matchmakingQueue');
            try {
                await runTransaction(db, async (transaction) => {
                    const q = query(matchmakingQueueRef, where("status", "==", "waiting"), limit(1));
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.empty) {
                        myMatchmakingDocRef = await addDoc(matchmakingQueueRef, {
                            userId: userId, username: username, status: 'waiting', createdAt: serverTimestamp()
                        });
                    } else {
                        const waitingPlayerDoc = querySnapshot.docs[0];
                        const waitingPlayer = waitingPlayerDoc.data();
                        
                        if (waitingPlayer.userId === userId) {
                            console.log("Esperando a otro jugador...");
                            myMatchmakingDocRef = await addDoc(matchmakingQueueRef, {
                                userId: userId, username: username, status: 'waiting', createdAt: serverTimestamp()
                            });
                            return;
                        }

                        const gameId = crypto.randomUUID().substring(0, 8);
                        const newGameRef = doc(db, 'artifacts', appId, 'public/data', 'games', gameId);
                        transaction.set(newGameRef, {
                            fen: 'start', pgn: '', status: 'active',
                            playerWhite: waitingPlayer.userId, playerBlack: userId,
                            turn: 'w', createdAt: serverTimestamp(),
                            playerWhiteEmoji: null, playerBlackEmoji: null // NUEVO
                        });
                        transaction.update(waitingPlayerDoc.ref, {
                            status: 'matched', gameId: gameId, opponentId: userId
                        });
                        return { gameId: gameId, color: 'b' };
                    }
                }).then((result) => {
                    if (result) {
                        initGame('online', { gameId: result.gameId, color: result.color, playerColor: 'b' }); // Jugador es Negras
                    } else {
                        if (!myMatchmakingDocRef) return;
                        matchmakingUnsubscribe = onSnapshot(myMatchmakingDocRef, (doc) => {
                            const data = doc.data();
                            if (data && data.status === 'matched' && data.gameId) {
                                if (matchmakingUnsubscribe) matchmakingUnsubscribe();
                                matchmakingUnsubscribe = null;
                                initGame('online', { gameId: data.gameId, color: 'w', playerColor: 'w' }); // Jugador es Blancas
                            }
                        });
                    }
                });
            } catch (e) {
                console.error("Error en el matchmaking:", e);
                $('#matchmakingStatus').text("Error al buscar partida.");
            }
        }
        
        async function cancelMatchmaking() {
            if (matchmakingUnsubscribe) matchmakingUnsubscribe();
            if (myMatchmakingDocRef) await deleteDoc(myMatchmakingDocRef).catch(e => console.error(e));
            matchmakingUnsubscribe = null;
            myMatchmakingDocRef = null;
            showView('mainAppView');
        }

        function startFakeMatchmaking() {
            showView('fakeMatchmakingView');
            // El ELO del bot ahora es m√°s cercano al ELO del jugador por defecto.
            let opponentElo = userElo + Math.floor(Math.random() * 100) - 50; 
            // Asegurar que el ELO sea al menos 100
            currentOpponentElo = Math.max(100, opponentElo); 
            
            // Actualizar la vista con el ELO
            $('#fakeOpponentEloDisplay').text(Math.round(currentOpponentElo));

            const delay = Math.random() * 2000 + 2000;
            fakeMatchmakingTimer = setTimeout(() => {
                const playerStartsAs = (Math.random() > 0.5) ? 'w' : 'b';
                currentOpponentName = botNames[Math.floor(Math.random() * botNames.length)];
                initGame('bot_match', {
                    skillLevel: currentOpponentElo,
                    opponentElo: currentOpponentElo,
                    playerColor: playerStartsAs
                });
            }, delay);
        }

        async function fetchPuzzles() {
            if (puzzles.length > 0) return; 
            try {
                const response = await fetch('https://logise1.github.io/chess/puzzles.fen');
                if (!response.ok) throw new Error('No se pudo cargar puzzles.fen');
                const data = await response.text();
                puzzles = data.split('\n')
                                .filter(fen => fen.trim() !== '')
                                .map((fen, index) => {
                                    const parts = fen.split(' ');
                                    const piecePlacement = parts[0];
                                    const turn = parts[1] || 'w';
                                    return { 
                                        name: `Problema #${index + 1}`, 
                                        index: index, 
                                        fen: piecePlacement,
                                        turn: turn, 
                                        solution: []
                                    };
                                });
                console.log('Problemas cargados:', puzzles.length);
            } catch (error) {
                console.error('Error al cargar problemas:', error);
                puzzles = [];
            }
        }
        
        async function startRandomPuzzle() {
            if (!stockfishReady) {
                showView('gameView'); 
                $status.text("Iniciando IA..."); 
                initStockfish(startRandomPuzzle);
                return;
            }
            if (puzzles.length === 0) {
                showView('gameView'); 
                $status.text("Cargando problemas...");
                await fetchPuzzles();
            }
            if (puzzles.length === 0) {
                $status.text("Error al cargar problemas.");
                showView('mainAppView');
                return;
            }
            const randomIndex = Math.floor(Math.random() * puzzles.length);
            initGame('puzzle', { puzzleIndex: randomIndex });
        }
        
        function getSolutionMove(fullFen, callback) {
            if (!stockfishReady) {
                console.error("Stockfish no est√° listo.");
                return;
            }
            const moveCallback = (event) => {
                var message = event.data;
                if (message.startsWith('bestmove')) {
                    var bestmove = message.split(' ')[1];
                    stockfish.removeEventListener('message', moveCallback);
                    callback(bestmove);
                }
            };
            stockfish.addEventListener('message', moveCallback);
            stockfish.postMessage('ucinewgame');
            stockfish.postMessage('position fen ' + fullFen);
            // Stockfish siempre debe buscar la mejor jugada para los problemas
            stockfish.postMessage('go depth 15'); 
        }
        
        function showHint() {
            if (!currentPuzzle || currentPuzzle.solution.length === 0) return;
            const fromSquare = currentPuzzle.solution[0].substring(0, 2);
            const $squareEl = $('#myBoard .square-' + fromSquare);
            $squareEl.addClass('highlight-hint');
            setTimeout(() => $squareEl.removeClass('highlight-hint'), 1000);
        }

        function loadFriends() {
            if (friendsUnsubscribe) friendsUnsubscribe();
            const friendsRef = collection(db, 'artifacts', appId, 'users', userId, 'friends');
            const $list = $('#friendsListContainer');
            friendsUnsubscribe = onSnapshot(friendsRef, (snapshot) => {
                $list.empty();
                if (snapshot.empty) {
                    $list.html('<p style="color: var(--text-secondary);">No tienes amigos a√±adidos.</p>');
                    return;
                }
                snapshot.forEach((doc) => {
                    const friend = doc.data();
                    $list.append(`<div class="list-item"><span>${friend.username}</span></div>`);
                });
            });
        }
        
        async function addFriend() {
            const friendUsername = $('#addFriendUsernameInput').val().trim();
            const $status = $('#addFriendStatus');
            $status.text('');
            if (!friendUsername) {
                $status.text('Introduce un nombre de usuario.').css('color', 'var(--danger-accent)');
                return;
            }
            if (friendUsername === username) {
                $status.text('No puedes a√±adarte a ti mismo.').css('color', 'var(--danger-accent)');
                return;
            }
            $status.text('Buscando usuario...').css('color', 'var(--text-secondary)');
            try {
                const q = query(collection(db, 'artifacts', appId, 'public/data', 'userProfiles'), where("username", "==", friendUsername), limit(1));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    $status.text('Usuario no encontrado.').css('color', 'var(--danger-accent)');
                    return;
                }
                const friendId = querySnapshot.docs[0].id;
                const friendRef = doc(db, 'artifacts', appId, 'users', userId, 'friends', friendId);
                await setDoc(friendRef, { username: friendUsername, addedAt: serverTimestamp() });
                $status.text(`¬°${friendUsername} a√±adido!`).css('color', 'var(--secondary-accent)');
                $('#addFriendUsernameInput').val('');
            } catch (e) {
                console.error("Error al a√±adir amigo:", e);
                $status.text('Error al a√±adir amigo.').css('color', 'var(--danger-accent)');
            }
        }
        
        async function handleLogin() {
            const username = $('#loginUsername').val().trim();
            const password = $('#loginPassword').val().trim();
            if (!username || !password) {
                $('#loginError').text('Por favor, introduce usuario y contrase√±a.');
                return;
            }
            const email = username + '@email.com';
            $('#loginError').text('Iniciando sesi√≥n...');
            try {
                await signInWithEmailAndPassword(auth, email, password);
                $('#loginError').text('');
            } catch (error) {
                console.error("Error al iniciar sesi√≥n:", error.message);
                $('#loginError').text(getFirebaseAuthErrorMessage(error));
            }
        }

        async function handleRegister() {
            const username = $('#loginUsername').val().trim();
            const password = $('#loginPassword').val().trim();
            if (!username || !password) {
                $('#loginError').text('Por favor, introduce usuario y contrase√±a.');
                return;
            }
            if (password.length < 6) {
                $('#loginError').text('La contrase√±a debe tener al menos 6 caracteres.');
                return;
            }
            const email = username + '@email.com';
            $('#loginError').text('Registrando...');

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const newUser = userCredential.user;
                const profileRef = doc(db, 'artifacts', appId, 'public/data', 'userProfiles', newUser.uid);
                await setDoc(profileRef, { 
                    username: username, 
                    joinedAt: serverTimestamp(),
                    elo: 100
                });
                userElo = 100;
                $('#loginError').text('');
            } catch (error) {
                console.error("Error al registrar:", error.message);
                $('#loginError').text(getFirebaseAuthErrorMessage(error));
            }
        }

        async function handleLogout() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Error al cerrar sesi√≥n:", error.message);
            }
        }

        function getFirebaseAuthErrorMessage(error) {
            switch (error.code) {
                case 'auth/invalid-email': return 'El formato del usuario no es v√°lido.';
                case 'auth/user-not-found':
                case 'auth/wrong-password':
                case 'auth/invalid-credential': return 'Usuario o contrase√±a incorrectos.';
                case 'auth/email-already-in-use': return 'Este nombre de usuario ya est√° en uso.';
                case 'auth/weak-password': return 'La contrase√±a es demasiado d√©bil (m√≠n. 6 caracteres).';
                default: return 'Error: ' + error.message.replace('Firebase: ', '');
            }
        }

        // --- 6. Nuevas Funciones de Juego y Revisi√≥n ---

        /**
         * NUEVO: Obtiene la evaluaci√≥n de una posici√≥n FEN de Stockfish
         * @param {string} fen - La posici√≥n FEN a evaluar
         * @returns {Promise<number>} - La evaluaci√≥n en centipawns (CP)
         */
        function getStockfishEval(fen) {
            return new Promise((resolve, reject) => {
                if (!stockfishReady) {
                    reject("Stockfish no est√° listo");
                    return;
                }
                
                let eval_cp = 0;
                let mate_in = 0;

                const evalListener = (event) => {
                    const message = event.data;
                    
                    if (message.startsWith('info depth') && message.includes('score cp')) {
                        const parts = message.split(' ');
                        const cpIndex = parts.indexOf('cp');
                        if (cpIndex > -1) {
                            eval_cp = parseInt(parts[cpIndex + 1], 10);
                        }
                    } else if (message.startsWith('info depth') && message.includes('score mate')) {
                        const parts = message.split(' ');
                        const mateIndex = parts.indexOf('mate');
                        if (mateIndex > -1) {
                            mate_in = parseInt(parts[mateIndex + 1], 10);
                            // Convertir mate a un valor de CP muy alto
                            eval_cp = (mate_in > 0) ? (30000 - mate_in) : (-30000 + mate_in);
                        }
                    }

                    if (message.startsWith('bestmove')) {
                        stockfish.removeEventListener('message', evalListener);
                        // Si hay mate, la eval_cp ya est√° ajustada
                        resolve(eval_cp);
                    }
                };
                
                stockfish.addEventListener('message', evalListener);
                stockfish.postMessage('position fen ' + fen);
                // Usamos un tiempo fijo para la evaluaci√≥n para que sea r√°pido (1 segundo)
                stockfish.postMessage('go movetime 1000'); 
            });
        }
        
        /**
         * NUEVO: Calcula la p√©rdida de CP de una jugada
         */
        function calculateEvalLoss(eval_before, eval_after, color) {
            let loss = 0;
            if (color === 'w') {
                // Para blancas, una eval m√°s baja es peor
                loss = eval_before - eval_after;
            } else {
                // Para negras, una eval m√°s alta es peor (m√°s positiva para blancas)
                loss = eval_after - eval_before;
            }
            // Si la p√©rdida es negativa, significa que la jugada fue buena
            return loss;
        }

        /**
         * NUEVO: Devuelve el nombre de la evaluaci√≥n basado en la p√©rdida
         */
        function getEvaluationNameFromLoss(cp_loss) {
            if (cp_loss <= 5) return "best"; // Casi perfecto
            if (cp_loss <= 25) return "excellent";
            if (cp_loss <= 60) return "ok";
            if (cp_loss <= 120) return "inaccuracy";
            if (cp_loss <= 250) return "mistake";
            return "blunder";
        }

        
        function handleResign() {
            if (currentGameMode !== 'bot_match' && currentGameMode !== 'ai' && currentGameMode !== 'online') {
                backToMenu();
                return;
            }
            
            if (game.game_over()) {
                backToMenu();
                return;
            }
            
            game.game_over = () => true;
            stopGameTimer();
            
            let result = 0; // Derrota
            let status = "Te has rendido.";
            
            if (currentGameMode === 'bot_match') {
                const newElo = calculateElo(userElo, currentOpponentElo, result);
                const eloChange = Math.round(newElo - userElo);
                status += ` (ELO: ${Math.round(userElo)} ${eloChange} -> ${Math.round(newElo)})`;
                // El ELO del usuario ya est√° asegurado como m√≠nimo 100 en calculateElo
                userElo = newElo;
                $('#userClassicElo').text(Math.round(userElo));
                updateEloInFirebase(newElo);
            }
            
            $status.text(status);
            playSound('audioGameEnd');
            finalPgn = game.pgn(); // Guardar PGN al rendirse
            
            $('#newGameButton').text('Revisar Partida')
                .show()
                .off('click')
                .on('click', () => initReview(finalPgn));

            currentGameMode = null;
        }
        
        function backToMenu() {
            if (stockfish) stockfish.postMessage('stop');
            if (gameUnsubscribe) gameUnsubscribe();
            if (matchmakingUnsubscribe) matchmakingUnsubscribe();
            if (myMatchmakingDocRef) deleteDoc(myMatchmakingDocRef);
            if (fakeMatchmakingTimer) clearTimeout(fakeMatchmakingTimer);
            
            stopGameTimer();
            gameUnsubscribe = null;
            matchmakingUnsubscribe = null;
            myMatchmakingDocRef = null;
            currentGameMode = null;
            
            if (reviewBoard) {
                reviewBoard.destroy();
                reviewBoard = null;
            }
            
            showView('mainAppView');
            showTabView('dashboardView');
        }

        // --- Funciones de Emojis ---
        async function handleEmojiClick() {
            const emoji = $(this).data('emoji');
            
            // Mostrar emoji del jugador
            $('#emoji-display-player').text(emoji).stop().fadeIn(200).delay(1500).fadeOut(300);

            if (currentGameMode === 'bot_match') {
                setTimeout(botEmojiReaction, 1000 + Math.random() * 1500);
            } else if (currentGameMode === 'online' && currentGameRef) {
                // Enviar emoji a Firebase
                try {
                    const fieldToUpdate = (playerColor === 'w') ? 'playerWhiteEmoji' : 'playerBlackEmoji';
                    await updateDoc(currentGameRef, { 
                        [fieldToUpdate]: { 
                            emoji: emoji, 
                            sentAt: serverTimestamp() 
                        } 
                    });
                } catch (e) {
                    console.error("Error al enviar emoji:", e);
                }
            }
        }

        function botEmojiReaction() {
            const emojis = ['üëç', 'üòÇ', 'ü§î', 'üî•', 'üòÆ', 'üëé'];
            const botEmoji = emojis[Math.floor(Math.random() * emojis.length)];
            // Mostrar emoji del oponente
            $('#emoji-display-opponent').text(botEmoji).stop().fadeIn(200).delay(1500).fadeOut(300);
        }

        // --- Funciones de Revisi√≥n de Partida ---
        function initReview(pgn) {
            showView('reviewView');
            reviewHistory = [];
            reviewMoveIndex = -1;
            finalPgn = pgn; // Asegurarse de que est√© guardado

            if (reviewBoard) {
                reviewBoard.destroy();
            }
            
            const reviewConfig = {
                position: 'start',
                pieceTheme: getPieceTheme,
                snapSpeed: 100,
                moveSpeed: 300
            };
            reviewBoard = Chessboard('reviewBoard', reviewConfig);
            
            reviewGame.load_pgn(pgn);
            reviewHistory = reviewGame.history({ verbose: true });
            reviewGame.reset(); // Volver al inicio
            
            $('#reviewPgn').val(pgn);
            // MODIFICADO: Llamar a la funci√≥n de evaluaci√≥n con -1
            showMoveEvaluationAsync(-1);
        }

        function navigateReview(direction) {
            let newIndex = reviewMoveIndex;

            if (direction === 'first') {
                newIndex = -1;
                reviewGame.reset();
            } else if (direction === 'last') {
                newIndex = reviewHistory.length - 1;
                reviewGame.load_pgn(finalPgn); // Cargar todo el PGN
            } else if (direction === 1) { // Next
                if (reviewMoveIndex < reviewHistory.length - 1) {
                    newIndex++;
                    reviewGame.move(reviewHistory[newIndex].san);
                }
            } else if (direction === -1) { // Prev
                if (reviewMoveIndex > -1) {
                    newIndex--;
                    reviewGame.undo();
                }
            }

            reviewMoveIndex = newIndex;
            reviewBoard.position(reviewGame.fen(), true); // Animar movimiento
            // MODIFICADO: Llamar a la nueva funci√≥n as√≠ncrona
            showMoveEvaluationAsync(reviewMoveIndex);
        }

        // MODIFICADO: Convertida a funci√≥n as√≠ncrona
        async function showMoveEvaluationAsync(moveIndex) {
            if (moveIndex < 0) {
                $('#reviewMoveEval').html('<span>Inicio de la partida</span>');
                return;
            }
            
            const move = reviewHistory[moveIndex];
            const moveNumber = Math.floor(moveIndex / 2) + 1;
            const dots = (move.color === 'b') ? '...' : '';

            // Mostrar "Analizando..."
            $('#reviewMoveEval').html(`
                <span>${moveNumber}. ${dots}${move.san}</span>
                <span class="eval-icon" style="font-size: 1rem; color: var(--text-secondary);">...</span>
                <span>(Analizando...)</span>
            `);

            try {
                // Crear FEN anterior
                const tempGame = new Chess();
                for (let i = 0; i < moveIndex; i++) {
                    tempGame.move(reviewHistory[i].san);
                }
                const fen_before = tempGame.fen();
                
                // FEN actual ya est√° en reviewGame
                const fen_after = reviewGame.fen();

                // Obtener evaluaciones (esto toma tiempo)
                const eval_before = await getStockfishEval(fen_before);
                const eval_after = await getStockfishEval(fen_after);
                
                // Calcular p√©rdida y nombre
                const cp_loss = calculateEvalLoss(eval_before, eval_after, move.color);
                const eval_name = getEvaluationNameFromLoss(cp_loss);
                
                // Actualizar UI con la evaluaci√≥n real
                $('#reviewMoveEval').html(`
                    <span>${moveNumber}. ${dots}${move.san}</span>
                    <img src="https://logise1.github.io/chess/assets/ratings/${eval_name}.png" class="eval-icon" alt="${eval_name}">
                    <span style="text-transform: capitalize;">(${eval_name})</span>
                `);
                
            } catch (e) {
                console.error("Error al evaluar:", e);
                $('#reviewMoveEval').html(`
                    <span>${moveNumber}. ${dots}${move.san}</span>
                    <span style="color: var(--danger-accent);">(Error de an√°lisis)</span>
                `);
            }
        }

        // --- Cargar nombres de bots desde usernames.json ---
        async function loadBotNames() {
            try {
                const response = await fetch('usernames.json');
                if (!response.ok) throw new Error('Error al cargar usernames.json');
                botNames = await response.json();
                console.log('Bot names loaded:', botNames);
            } catch (error) {
                console.error('Error loading bot names:', error);
                botNames = ["AlphaZero", "DeepBot", "Checkmate", "RookStorm"]; // Fallback names
            }
        }

        $(document).ready(function() {
            $status = $('#status');
            $pgn = $('#pgn');
            initFirebase();
            
            $('#loginButton').on('click', handleLogin);
            $('#registerButton').on('click', handleRegister);
            $('#logoutButton').on('click', handleLogout);

            $('#navPlay').on('click', () => showTabView('dashboardView'));
            $('#navPuzzles').on('click', () => showTabView('puzzlesView'));
            $('#navFriends').on('click', () => showTabView('friendsView'));
            
            $('#playQuickMatchButton').on('click', startFakeMatchmaking);
            // CORRECCI√ìN: El bot√≥n de IA siempre debe ir a la vista de configuraci√≥n
            $('#playAiButton').on('click', () => {
                showView('gameSetupView');
                currentOpponentName = "Stockfish"; // Nombre por defecto para la IA
            });
            $('#playMatchmakingButton').on('click', startMatchmaking);
            
            $('#startPuzzleButton').on('click', startRandomPuzzle);

            $('#addFriendButton').on('click', addFriend);
            
            $('#eloSlider').attr('min', 100); // Set minimum ELO to 100
            $('#eloSlider').on('input', function() {
                $('#eloValue').text(Math.max(100, $(this).val())); // Ensure minimum ELO is 100
            });
            $('#startAiGameButton').on('click', () => {
                initGame('ai', { 
                    skillLevel: $('#eloSlider').val(),
                    // Asignar color aleatorio al jugador
                    playerColor: (Math.random() > 0.5) ? 'w' : 'b'
                });
            });
            $('#backButtonSetup').on('click', () => showView('mainAppView'));
            $('#cancelMatchmakingButton').on('click', cancelMatchmaking);
            $('#cancelFakeMatchmakingButton').on('click', () => {
                clearTimeout(fakeMatchmakingTimer);
                showView('mainAppView');
            });
            
            // Botones de Juego
            $('#backToMenuButton').on('click', () => {
                if ((currentGameMode === 'bot_match' || currentGameMode === 'online' || currentGameMode === 'ai') && !game.game_over()) {
                    handleResign();
                } else {
                    backToMenu();
                }
            });
            $('#resignButton').on('click', handleResign);
            $('#drawButton').on('click', () => {
                $status.text('El oponente no acepta las tablas.');
            });
            // 'newGameButton' se maneja en updateStatus y initGame
            $('#hintButton').on('click', showHint);

            // Listeners de Emojis y Revisi√≥n
            $('.emoji-btn').on('click', handleEmojiClick);
            $('#reviewNextBtn').on('click', () => navigateReview(1));
            $('#reviewPrevBtn').on('click', () => navigateReview(-1));
            $('#reviewFirstBtn').on('click', () => navigateReview('first'));
            $('#reviewLastBtn').on('click', () => navigateReview('last'));
            $('#backToMenuFromReviewButton').on('click', backToMenu);

            // Cargar nombres de bots al iniciar
            loadBotNames();
            $('#toggleSoundButton').on('click', function() {
                const video = document.getElementById('background-video');
                if (video.muted) {
                    video.muted = false;
                    $(this).text('üîá Silenciar');
                } else {
                    video.muted = true;
                    $(this).text('üîä Activar Sonido');
                }
            });
        });

    </script>
    
    <!-- Bibliotecas JS (jQuery, Chessboard, Chess.js) -->
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    
    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <!-- Chess.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Wall Jumper - Turbo</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- Fuente Pixel Art -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- FIREBASE SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAQOCfjlM3HbeJe9d5A7Cgvul5RmndlCbE",
            authDomain: "jumper-4e0b2.firebaseapp.com",
            projectId: "jumper-4e0b2",
            storageBucket: "jumper-4e0b2.firebasestorage.app",
            messagingSenderId: "397169417542",
            appId: "1:397169417542:web:9ec619008be7d20579d947",
            measurementId: "G-GTD3T9FYKK"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const APP_ID = "pixel-jumper-turbo"; 
        const COLLECTION_PATH = `artifacts/${APP_ID}/public/data/players`;

        window.myPlayerId = null;
        window.remotePlayers = {}; 
        window.dbRef = { db, collection, doc, setDoc, onSnapshot, deleteDoc, COLLECTION_PATH };
        
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    const userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                    window.myPlayerId = userCredential.user.uid;
                } else {
                    throw new Error("No token");
                }
            } catch (error) {
                try {
                    const userCredential = await signInAnonymously(auth);
                    window.myPlayerId = userCredential.user.uid;
                } catch (e) { console.error(e); }
            }
            if (window.myPlayerId) setupNetworkListeners();
        };

        initAuth();

        function setupNetworkListeners() {
            const q = collection(db, 'artifacts', APP_ID, 'public', 'data', 'players');
            onSnapshot(q, (snapshot) => {
                const now = Date.now();
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    if (pid === window.myPlayerId) return;

                    if (change.type === "added" || change.type === "modified") {
                        window.remotePlayers[pid] = {
                            x: data.x,
                            y: data.y,
                            vx: data.vx,
                            color: data.color || '#ffffff',
                            name: data.name || 'PX',
                            lastUpdate: now
                        };
                    }
                    if (change.type === "removed") delete window.remotePlayers[pid];
                });
            });
        }

        setInterval(() => {
            const now = Date.now();
            for (let pid in window.remotePlayers) {
                if (now - window.remotePlayers[pid].lastUpdate > 10000) delete window.remotePlayers[pid];
            }
        }, 5000);
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #201a2e;
            touch-action: none;
            font-family: 'Press Start 2P', cursive;
            image-rendering: pixelated;
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .interactive { pointer-events: auto; }
        
        .pixel-card {
            background-color: #2d2345;
            border: 4px solid #fff;
            box-shadow: 8px 8px 0px #000;
            padding: 2rem;
            text-align: center;
        }
        
        .pixel-btn {
            background-color: #ffcc00;
            border: 4px solid #fff;
            color: #000;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 4px 4px 0px #000;
            transition: transform 0.1s;
            margin-top: 20px;
            width: 100%;
        }
        .pixel-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px #000;
        }

        .pixel-input {
            background-color: #000;
            border: 2px solid #fff;
            color: #00ff00;
            font-family: 'Press Start 2P', cursive;
            padding: 10px;
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            outline: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="startScreen" class="pixel-card interactive max-w-md w-full">
            <h1 class="text-3xl text-yellow-400 mb-6 leading-relaxed text-shadow-md">PIXEL<br>JUMPER</h1>
            
            <input type="text" id="playerNameInput" class="pixel-input" placeholder="NAME" maxlength="6">

            <p class="text-gray-300 text-xs mb-6 mt-4 leading-loose">
                CLICK = SALTAR + GIRAR<br>
                ¡SUBE RAPIDO!<br>
                <span class="text-red-400">EVITA EL ROJO</span>
            </p>
            
            <button id="startBtn" class="pixel-btn">START</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden pixel-card interactive">
            <h1 class="text-2xl text-red-500 mb-4">GAME OVER</h1>
            <p class="text-white text-sm mb-4">SCORE: <span id="finalScore" class="text-yellow-400">0</span></p>
            <p class="text-white text-sm mb-6">NIVEL: <span id="finalLevel" class="text-green-400">1</span></p>
            <button id="restartBtn" class="pixel-btn" style="background-color: #ff4444; color: white;">RETRY</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
            <div>
                <p class="text-white text-xs mb-2 shadow-black drop-shadow-md bg-black/50 p-2 border-2 border-white">SCORE: <span id="scoreDisplay" class="text-yellow-400">0</span></p>
                <p class="text-white text-xs shadow-black drop-shadow-md bg-black/50 p-2 border-2 border-white">LEVEL: <span id="levelDisplay" class="text-green-400">1</span></p>
            </div>
            <div class="text-right">
                <p id="onlineCount" class="text-blue-400 text-xs bg-black/50 p-2 border-2 border-white">ONLINE: 1</p>
            </div>
        </div>

        <div id="levelNotification" class="absolute top-1/4 pointer-events-none text-center hidden">
            <h2 class="text-4xl text-yellow-400 shadow-black drop-shadow-lg animate-bounce stroke-black">LEVEL UP!</h2>
        </div>
    </div>

    <script>
        // --- RNG DETERMINISTA ---
        class SeededRandom {
            constructor(seed) { this.seed = seed; }
            next() {
                var t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
            range(min, max) { return min + this.next() * (max - min); }
        }
        const GAME_SEED = 42; 

        // --- CONFIGURACIÓN ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalLevelDisplay = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const levelNotification = document.getElementById('levelNotification');
        const nameInput = document.getElementById('playerNameInput');
        const onlineCountDisplay = document.getElementById('onlineCount');

        // Estado
        let gameState = 'MENU';
        let score = 0;
        let level = 1;
        let frames = 0;
        let cameraY = 0;
        let playerName = "PX";

        // Física (Más rápida = Más diversión)
        const GRAVITY = 0.65;
        const JUMP_FORCE = -12.5; 
        const HORIZONTAL_SPEED = 7.5; 
        const MAX_FALL_SPEED = 15;

        // Fondos por nivel (Ciclo de colores vibrantes oscuros)
        const LEVEL_COLORS = [
            '#201a2e', // Nvl 1: Púrpura
            '#0d2b2a', // Nvl 2: Cian oscuro
            '#3b1e1e', // Nvl 3: Rojo ladrillo
            '#1e3b22', // Nvl 4: Verde bosque
            '#3b341e', // Nvl 5: Dorado oscuro
            '#000000'  // Nvl 6: Vacío
        ];

        // --- AUDIO ---
        let synth, noise;
        let audioInit = false;

        async function initAudio() {
            if (audioInit) return;
            await Tone.start();
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            }).toDestination();
            synth.volume.value = -12;
            noise = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0 }
            }).toDestination();
            noise.volume.value = -15;
            audioInit = true;
        }

        function playJump() { if(audioInit) synth.triggerAttackRelease("C4", "32n"); }
        function playBounce() { if(audioInit) synth.triggerAttackRelease("A3", "32n"); }
        function playDead() { if(audioInit) { noise.triggerAttackRelease("8n"); synth.triggerAttackRelease(["C2", "C1"], "8n"); }}
        function playLvlUp() { if(audioInit) synth.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "16n"); }

        // --- CLASES ---

        class Player {
            constructor(isLocal = true) {
                this.w = 24; this.h = 24;
                this.isLocal = isLocal;
                this.reset();
            }

            reset() {
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 150;
                this.vx = HORIZONTAL_SPEED;
                this.vy = 0;
                const colors = ['#FF00FF', '#00FFFF', '#00FF00', '#FFFF00']; // Neón 8-bit
                this.color = this.isLocal ? colors[Math.floor(Math.random()*colors.length)] : '#fff';
                this.isDead = false;
            }

            update() {
                if (!this.isLocal || this.isDead) return;

                this.vy += GRAVITY;
                if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;
                
                this.x += this.vx;
                this.y += this.vy;

                // Rebote Paredes
                if (this.x <= 0) {
                    this.x = 0; this.vx *= -1; playBounce();
                    createParticles(this.x, this.y + this.h/2, '#fff', 4);
                } else if (this.x + this.w >= canvas.width) {
                    this.x = canvas.width - this.w; this.vx *= -1; playBounce();
                    createParticles(this.x + this.w, this.y + this.h/2, '#fff', 4);
                }

                // Muerte (Más margen abajo)
                if (this.y > cameraY + canvas.height + 100) die();
            }

            jump() {
                if (this.isDead) return;
                this.vy = JUMP_FORCE;
                this.vx *= -1; // CLICK = SALT + GIRO
                playJump();
                createParticles(this.x + this.w/2, this.y + this.h, this.color, 6);
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.w, this.h);
                
                // Efecto bisel
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.strokeRect(Math.floor(this.x), Math.floor(this.y), this.w, this.h);

                // Ojos
                const eyeXOffset = (this.vx > 0) ? 14 : 4;
                ctx.fillStyle = 'white';
                ctx.fillRect(Math.floor(this.x + eyeXOffset), Math.floor(this.y + 6), 6, 6);
                ctx.fillStyle = 'black';
                ctx.fillRect(Math.floor(this.x + eyeXOffset + (this.vx > 0 ? 4 : 0)), Math.floor(this.y + 8), 2, 2);

                if (this.name) {
                    ctx.fillStyle = "#fff";
                    ctx.font = "8px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.fillText(this.name, this.x + this.w/2, this.y - 8);
                }
            }
        }

        class Obstacle {
            constructor(y, lvl, seed) {
                const rng = new SeededRandom(seed + Math.floor(y));
                this.y = y;
                this.h = 32;
                
                // DIFICULTAD: Siempre hay obstáculos, incluso en nivel 1
                let moveProb = 0.3; // 30% bloques móviles nivel 1
                if (lvl >= 2) moveProb = 0.5;
                if (lvl >= 4) moveProb = 0.8;

                this.type = rng.next() < moveProb ? 'MOVING' : 'STATIC';
                
                this.spikeColor = '#ff0040'; // Rojo neón peligroso

                if (this.type === 'STATIC') {
                    // Pinchos laterales
                    let maxLen = Math.min(150, 60 + lvl * 10);
                    this.w = 60 + rng.next() * maxLen;
                    this.side = rng.next() > 0.5 ? 'LEFT' : 'RIGHT';
                    this.x = this.side === 'LEFT' ? 0 : canvas.width - this.w;
                    this.isSpike = true; 
                } else {
                    // Bloques centrales móviles
                    this.w = Math.max(70, 120 - (lvl * 5));
                    this.x = rng.next() * (canvas.width - this.w);
                    let speed = 2 + (lvl * 0.5); 
                    this.vx = speed * (rng.next() > 0.5 ? 1 : -1);
                    this.isSpike = false; 
                }
            }

            update() {
                if (this.type === 'MOVING') {
                    this.x += this.vx;
                    if (this.x <= 0 || this.x + this.w >= canvas.width) this.vx *= -1;
                }
            }

            draw() {
                if (this.isSpike) {
                    ctx.fillStyle = this.spikeColor;
                    const steps = 4;
                    const stepH = this.h / steps;
                    if (this.side === 'LEFT') {
                        ctx.fillRect(0, this.y, this.w/2, this.h); // Base
                        for(let i=0; i<steps; i++) { // Puntas pixeladas
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(this.w/2, this.y + (i*stepH), width, stepH);
                        }
                    } else {
                        ctx.fillRect(canvas.width - this.w/2, this.y, this.w/2, this.h);
                        for(let i=0; i<steps; i++) {
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(canvas.width - this.w/2 - width, this.y + (i*stepH), width, stepH);
                        }
                    }
                } else {
                    // Bloque móvil
                    ctx.fillStyle = '#ffbb00'; 
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    ctx.fillStyle = '#ffe082'; // Brillo
                    ctx.fillRect(this.x + 4, this.y + 4, this.w - 8, this.h - 8);
                    
                    // Cara Bloque
                    ctx.fillStyle = 'black';
                    ctx.fillRect(this.x + 15, this.y + 12, 4, 4);
                    ctx.fillRect(this.x + this.w - 19, this.y + 12, 4, 4);
                    ctx.fillRect(this.x + 20, this.y + 20, this.w - 40, 2); // Boca
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1; this.color = color; 
                this.size = Math.floor(Math.random() * 5 + 3);
            }
            update() { 
                this.x += this.vx; this.y += this.vy; 
                this.life -= 0.08; this.vy += 0.5; 
            }
            draw() { 
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color; 
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.size, this.size);
                ctx.globalAlpha = 1; 
            }
        }

        // --- GLOBAL ---
        const player = new Player(true);
        let obstacles = [];
        let particles = [];
        let nextObstacleY = 0;
        let lastNetUpdate = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'MENU') player.reset();
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            playerName = nameInput.value.trim() || "PX";
            player.name = playerName;

            initAudio();
            gameState = 'PLAYING';
            score = 0;
            level = 1;
            frames = 0;
            cameraY = 0;
            obstacles = [];
            particles = [];
            player.reset();
            
            // GENERACIÓN INICIAL MASIVA
            nextObstacleY = canvas.height - 250; 
            
            // Pre-llenar pantalla + 1 pantalla extra arriba
            while (nextObstacleY > -canvas.height) {
                spawnObstacle();
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            loop();
        }

        function spawnObstacle() {
            obstacles.push(new Obstacle(nextObstacleY, level, GAME_SEED));
            
            let baseGap = 160; 
            let gap = baseGap - (Math.min(level, 15) * 4); // Se estrecha
            gap += Math.random() * 50; 
            
            nextObstacleY -= Math.max(130, gap); // Mínimo 130px para asegurar jugabilidad
        }

        function die() {
            if (gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER';
            playDead();
            createParticles(player.x, player.y, player.color, 25);
            
            finalScoreDisplay.innerText = Math.floor(score);
            finalLevelDisplay.innerText = level;
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            if (window.myPlayerId && window.dbRef) {
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.deleteDoc(docRef).catch(()=>{});
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function checkCollisions() {
            let pBox = {l: player.x, r: player.x + player.w, t: player.y, b: player.y + player.h};
            
            for (let obs of obstacles) {
                let oBox;
                if (obs.isSpike) {
                    let width = obs.w - 8; // Hitbox indulgente
                    let x = (obs.side === 'LEFT') ? 0 : canvas.width - width;
                    oBox = {l: x, r: x + width, t: obs.y, b: obs.y + obs.h};
                } else {
                    oBox = {l: obs.x, r: obs.x + obs.w, t: obs.y, b: obs.y + obs.h};
                }

                if (pBox.l < oBox.r && pBox.r > oBox.l && pBox.t < oBox.b && pBox.b > oBox.t) {
                    die();
                }
            }
        }

        function sendNetUpdate() {
            const now = Date.now();
            if (now - lastNetUpdate > 100 && window.myPlayerId && gameState === 'PLAYING') {
                lastNetUpdate = now;
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.setDoc(docRef, {
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    vx: player.vx, 
                    color: player.color,
                    name: playerName,
                    updatedAt: window.dbRef.serverTimestamp ? window.dbRef.serverTimestamp() : now
                }).catch(()=>{});
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;
            frames++;
            player.update();
            checkCollisions();
            sendNetUpdate();

            // Cámara y Progresión ACELERADA
            let targetY = player.y - canvas.height * 0.6;
            if (targetY < cameraY) {
                let diff = cameraY - targetY;
                cameraY = targetY;
                
                // SISTEMA DE PUNTOS BOOSTED (1 pixel = 1 punto)
                score += diff; 
                
                // SUBIR NIVEL CADA 600 PUNTOS (aprox 2 pantallas)
                let newLevel = Math.floor(score / 600) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    playLvlUp();
                    levelNotification.classList.remove('hidden');
                    levelNotification.classList.add('level-up-anim');
                    setTimeout(() => levelNotification.classList.add('hidden'), 2000);
                }
            } else {
                // AUTO-SCROLL RÁPIDO QUE ESCALA
                cameraY -= (2.0 + level * 0.3); 
            }

            // Generar
            if (cameraY < nextObstacleY + canvas.height + 300) {
                spawnObstacle();
            }

            // Limpieza
            obstacles = obstacles.filter(obs => obs.y < cameraY + canvas.height + 300);
            obstacles.forEach(obs => obs.update());
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            scoreDisplay.innerText = Math.floor(score);
            levelDisplay.innerText = level;
            
            let count = 1;
            if (window.remotePlayers) count += Object.keys(window.remotePlayers).length;
            onlineCountDisplay.innerText = `ONLINE: ${count}`;
        }

        function draw() {
            // COLOR DE FONDO POR NIVEL
            let bgIndex = (level - 1) % LEVEL_COLORS.length;
            ctx.fillStyle = LEVEL_COLORS[bgIndex];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Estrellas
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            for(let i=0; i<20; i++) {
                let x = (i * 83) % canvas.width;
                let y = (i * 113 - cameraY*0.8) % canvas.height;
                if(y < 0) y += canvas.height;
                ctx.fillRect(x, y, 3, 3);
            }

            ctx.save();
            ctx.translate(0, -Math.floor(cameraY));

            obstacles.forEach(obs => obs.draw());

            // Jugadores Online
            if (window.remotePlayers) {
                for (let pid in window.remotePlayers) {
                    const rp = window.remotePlayers[pid];
                    ctx.fillStyle = rp.color;
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(rp.x, rp.y, 24, 24);
                    ctx.fillStyle = 'white';
                    let eyeOff = (rp.vx > 0) ? 14 : 4;
                    ctx.fillRect(rp.x + eyeOff, rp.y + 6, 6, 6);
                    ctx.fillStyle = "#fff";
                    ctx.font = "8px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.fillText(rp.name, rp.x + 12, rp.y - 10);
                    ctx.globalAlpha = 1;
                }
            }

            if (gameState === 'PLAYING') player.draw();
            particles.forEach(p => p.draw());

            ctx.restore();
        }

        function loop() {
            update();
            draw();
            if (gameState === 'PLAYING') requestAnimationFrame(loop);
        }

        // INPUTS
        function handleInput(e) {
            e.preventDefault();
            if (gameState === 'PLAYING') player.jump();
        }

        window.addEventListener('mousedown', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        });
        window.addEventListener('touchstart', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        }, {passive: false});
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (gameState === 'PLAYING') player.jump();
            }
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', () => {
             startScreen.classList.remove('hidden');
             gameOverScreen.classList.add('hidden');
        });

        player.y = canvas.height - 150;
        draw();

    </script>
</body>
</html>

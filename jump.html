<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Wall Jumper - Multiplayer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- Fuente Pixel Art -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- FIREBASE SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAQOCfjlM3HbeJe9d5A7Cgvul5RmndlCbE",
            authDomain: "jumper-4e0b2.firebaseapp.com",
            projectId: "jumper-4e0b2",
            storageBucket: "jumper-4e0b2.firebasestorage.app",
            messagingSenderId: "397169417542",
            appId: "1:397169417542:web:9ec619008be7d20579d947",
            measurementId: "G-GTD3T9FYKK"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const APP_ID = "pixel-jumper-v2-revert"; 
        const COLLECTION_PATH = `artifacts/${APP_ID}/public/data/players`;

        window.myPlayerId = null;
        window.remotePlayers = {}; 
        window.dbRef = { db, collection, doc, setDoc, onSnapshot, deleteDoc, COLLECTION_PATH };
        
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    const userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                    window.myPlayerId = userCredential.user.uid;
                    console.log("Auth: Custom Token");
                } else {
                    throw new Error("No token");
                }
            } catch (error) {
                console.warn("Auth: Fallback Anónimo");
                try {
                    const userCredential = await signInAnonymously(auth);
                    window.myPlayerId = userCredential.user.uid;
                } catch (anonError) {
                    console.error("Auth Error Total", anonError);
                }
            }
            if (window.myPlayerId) setupNetworkListeners();
        };

        initAuth();

        function setupNetworkListeners() {
            const q = collection(db, 'artifacts', APP_ID, 'public', 'data', 'players');
            onSnapshot(q, (snapshot) => {
                const now = Date.now();
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    if (pid === window.myPlayerId) return;

                    if (change.type === "added" || change.type === "modified") {
                        window.remotePlayers[pid] = {
                            x: data.x,
                            y: data.y,
                            vx: data.vx, // Sincronizamos dirección para los ojos
                            color: data.color || '#ffffff',
                            name: data.name || 'PX',
                            lastUpdate: now
                        };
                    }
                    if (change.type === "removed") delete window.remotePlayers[pid];
                });
            });
        }

        setInterval(() => {
            const now = Date.now();
            for (let pid in window.remotePlayers) {
                if (now - window.remotePlayers[pid].lastUpdate > 10000) delete window.remotePlayers[pid];
            }
        }, 5000);
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #201a2e; /* Fondo oscuro retro */
            touch-action: none;
            font-family: 'Press Start 2P', cursive; /* Fuente Retro */
            image-rendering: pixelated; /* Renderizado Pixel Perfect */
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .interactive { pointer-events: auto; }
        
        .pixel-card {
            background-color: #2d2345;
            border: 4px solid #fff;
            box-shadow: 8px 8px 0px #000;
            padding: 2rem;
            text-align: center;
        }
        
        .pixel-btn {
            background-color: #ffcc00;
            border: 4px solid #fff;
            color: #000;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 4px 4px 0px #000;
            transition: transform 0.1s;
            margin-top: 20px;
            width: 100%;
        }
        .pixel-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px #000;
        }

        .pixel-input {
            background-color: #000;
            border: 2px solid #fff;
            color: #00ff00;
            font-family: 'Press Start 2P', cursive;
            padding: 10px;
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            outline: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="startScreen" class="pixel-card interactive max-w-md w-full">
            <h1 class="text-2xl text-yellow-400 mb-6 leading-relaxed">PIXEL<br>JUMPER</h1>
            
            <input type="text" id="playerNameInput" class="pixel-input" placeholder="NAME" maxlength="6">

            <p class="text-gray-300 text-xs mb-6 mt-4 leading-loose">
                CLICK = SALT + GIRO<br>
                PARED = REBOTE<br>
                <span class="text-red-400">NO TOQUES ROJO</span>
            </p>
            
            <button id="startBtn" class="pixel-btn">START</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden pixel-card interactive">
            <h1 class="text-2xl text-red-500 mb-4">GAME OVER</h1>
            <p class="text-white text-sm mb-4">SCORE: <span id="finalScore" class="text-yellow-400">0</span></p>
            <p class="text-white text-sm mb-6">NIVEL: <span id="finalLevel" class="text-green-400">1</span></p>
            <button id="restartBtn" class="pixel-btn" style="background-color: #ff4444; color: white;">RETRY</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
            <div>
                <p class="text-white text-xs mb-2 shadow-black drop-shadow-md">SC: <span id="scoreDisplay" class="text-yellow-400">0</span></p>
                <p class="text-white text-xs shadow-black drop-shadow-md">LV: <span id="levelDisplay" class="text-green-400">1</span></p>
            </div>
            <div class="text-right">
                <p class="text-xs text-gray-400 mb-1">ONLINE</p>
                <p id="onlineCount" class="text-blue-400 text-xs">1</p>
            </div>
        </div>

        <div id="levelNotification" class="absolute top-1/4 pointer-events-none text-center hidden">
            <h2 class="text-2xl text-yellow-400 shadow-black drop-shadow-lg">LEVEL UP!</h2>
        </div>
    </div>

    <script>
        // --- RNG DETERMINISTA ---
        class SeededRandom {
            constructor(seed) { this.seed = seed; }
            next() {
                var t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
            range(min, max) { return min + this.next() * (max - min); }
        }
        const GAME_SEED = 999; 

        // --- CONFIGURACIÓN ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Desactivar suavizado para Pixel Art
        ctx.imageSmoothingEnabled = false;

        // UI
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalLevelDisplay = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const levelNotification = document.getElementById('levelNotification');
        const nameInput = document.getElementById('playerNameInput');
        const onlineCountDisplay = document.getElementById('onlineCount');

        let gameState = 'MENU';
        let score = 0;
        let level = 1;
        let frames = 0;
        let cameraY = 0;
        let playerName = "PX";

        // Física ajustada
        const GRAVITY = 0.5;
        const JUMP_FORCE = -10;
        const HORIZONTAL_SPEED = 6; // Velocidad cómoda
        const MAX_FALL_SPEED = 12;

        // --- AUDIO (Tone.js 8-bit Style) ---
        let synth, noise, metal;
        let audioInit = false;

        async function initAudio() {
            if (audioInit) return;
            await Tone.start();
            
            // Sonido tipo Gameboy
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "square" }, // Onda cuadrada = 8bit
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            }).toDestination();
            synth.volume.value = -10;

            noise = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0 }
            }).toDestination();
            noise.volume.value = -12;

            audioInit = true;
        }

        function playJump() { if(audioInit) synth.triggerAttackRelease("C4", "32n"); }
        function playBounce() { if(audioInit) synth.triggerAttackRelease("E3", "32n"); }
        function playDead() { if(audioInit) { noise.triggerAttackRelease("8n"); synth.triggerAttackRelease(["C2", "G1"], "8n"); }}
        function playLvlUp() { if(audioInit) synth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "16n"); }

        // --- CLASES PIXEL ART ---

        class Player {
            constructor(isLocal = true) {
                this.w = 24; // Un poco más grande para ver los pixeles
                this.h = 24;
                this.isLocal = isLocal;
                this.reset();
            }

            reset() {
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 100; // Empezamos abajo
                this.vx = HORIZONTAL_SPEED; // Siempre moviéndose
                this.vy = 0;
                // Colores pastel retro
                const colors = ['#FF77A8', '#29ADFF', '#00E436', '#FFCC00'];
                this.color = this.isLocal ? colors[Math.floor(Math.random()*colors.length)] : '#fff';
                this.isDead = false;
            }

            update() {
                if (!this.isLocal || this.isDead) return;

                this.vy += GRAVITY;
                if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;
                
                // Movimiento constante horizontal
                this.x += this.vx;
                this.y += this.vy;

                // Rebote en paredes
                if (this.x <= 0) {
                    this.x = 0; 
                    this.vx *= -1; // Invertir velocidad
                    playBounce();
                    createPixelParticles(this.x, this.y + this.h/2, '#fff', 4);
                } else if (this.x + this.w >= canvas.width) {
                    this.x = canvas.width - this.w; 
                    this.vx *= -1; // Invertir velocidad
                    playBounce();
                    createPixelParticles(this.x + this.w, this.y + this.h/2, '#fff', 4);
                }

                if (this.y > cameraY + canvas.height + 50) die();
            }

            jump() {
                if (this.isDead) return;
                // SALTO Y CAMBIO DE DIRECCIÓN
                this.vy = JUMP_FORCE;
                this.vx *= -1; // CAMBIO DE DIRECCIÓN AL CLICKAR
                playJump();
                createPixelParticles(this.x + this.w/2, this.y + this.h, this.color, 6);
            }

            draw() {
                // Dibujar Sprite Pixelado
                ctx.fillStyle = this.color;
                // Cuerpo (bloque sólido con borde)
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.w, this.h);
                
                // Borde interior para efecto 3D simple
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y + this.h - 4), this.w, 4);
                ctx.fillRect(Math.floor(this.x + this.w - 4), Math.floor(this.y), 4, this.h);

                // Ojos (Pixel blanco + pupila negra)
                const eyeXOffset = (this.vx > 0) ? 14 : 4; // Mirar dirección
                
                ctx.fillStyle = 'white';
                ctx.fillRect(Math.floor(this.x + eyeXOffset), Math.floor(this.y + 6), 6, 6);
                ctx.fillStyle = 'black';
                ctx.fillRect(Math.floor(this.x + eyeXOffset + (this.vx > 0 ? 4 : 0)), Math.floor(this.y + 8), 2, 2);

                // Nombre
                if (this.name) {
                    ctx.fillStyle = "#aaa";
                    ctx.font = "10px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.fillText(this.name, this.x + this.w/2, this.y - 8);
                }
            }
        }

        class Obstacle {
            constructor(y, lvl, seed) {
                const rng = new SeededRandom(seed + Math.floor(y));
                this.y = y;
                this.h = 32; // Bloques de 32px
                
                let moveProb = 0;
                if (lvl >= 2) moveProb = 0.3;
                if (lvl >= 5) moveProb = 0.6;

                this.type = rng.next() < moveProb ? 'BLOCK' : 'SPIKE';
                
                if (this.type === 'SPIKE') {
                    // Pinchos en paredes
                    let maxLen = Math.min(100, 40 + lvl * 5);
                    this.w = 40 + rng.next() * maxLen;
                    this.side = rng.next() > 0.5 ? 'LEFT' : 'RIGHT';
                    this.x = this.side === 'LEFT' ? 0 : canvas.width - this.w;
                    this.color = (lvl % 2 === 0) ? '#ff0044' : '#ff4400'; // Rojo/Naranja
                } else {
                    // Bloques flotantes
                    this.w = Math.max(50, 90 - (lvl * 3));
                    this.x = rng.next() * (canvas.width - this.w);
                    let speed = 2 + (lvl * 0.5);
                    this.vx = speed * (rng.next() > 0.5 ? 1 : -1);
                    this.color = '#ffcc00'; // Dorado
                }
            }

            update() {
                if (this.type === 'BLOCK') {
                    this.x += this.vx;
                    if (this.x <= 0 || this.x + this.w >= canvas.width) this.vx *= -1;
                }
            }

            draw() {
                // Dibujar estilo ladrillo pixelado
                if (this.type === 'SPIKE') {
                    ctx.fillStyle = this.color;
                    // Dibujar pinchos como "escaleras" (pixels)
                    const steps = 4;
                    const stepH = this.h / steps;
                    
                    if (this.side === 'LEFT') {
                        // Base sólida
                        ctx.fillRect(0, this.y, this.w/2, this.h);
                        // Pinchos
                        for(let i=0; i<steps; i++) {
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(this.w/2, this.y + (i*stepH), width, stepH);
                        }
                    } else {
                        // Base
                        ctx.fillRect(canvas.width - this.w/2, this.y, this.w/2, this.h);
                        // Pinchos
                        for(let i=0; i<steps; i++) {
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(canvas.width - this.w/2 - width, this.y + (i*stepH), width, stepH);
                        }
                    }
                } else {
                    // Bloque flotante (Ladrillo)
                    ctx.fillStyle = '#8B4513'; // Marrón ladrillo
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    
                    // Detalles de ladrillo
                    ctx.fillStyle = '#A0522D'; // Ladrillo claro
                    ctx.fillRect(this.x + 4, this.y + 4, this.w/2 - 6, this.h/2 - 6);
                    ctx.fillRect(this.x + this.w/2 + 2, this.y + this.h/2 + 2, this.w/2 - 6, this.h/2 - 6);
                    
                    // Borde Pixel
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.w, this.h);
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1; 
                this.color = color; 
                this.size = Math.floor(Math.random() * 6 + 2);
            }
            update() { 
                this.x += this.vx; this.y += this.vy; this.life -= 0.05; 
                this.vy += 0.2; // Gravedad partículas
            }
            draw() { 
                ctx.globalAlpha = this.life; 
                ctx.fillStyle = this.color; 
                // Cuadrados perfectos
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.size, this.size);
                ctx.globalAlpha = 1; 
            }
        }

        // --- GLOBAL ---
        const player = new Player(true);
        let obstacles = [];
        let particles = [];
        let nextObstacleY = 0;
        let lastNetUpdate = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'MENU') player.reset();
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            const name = nameInput.value.trim() || "PX";
            playerName = name;
            player.name = playerName;

            initAudio();
            gameState = 'PLAYING';
            score = 0;
            level = 1;
            frames = 0;
            cameraY = 0;
            obstacles = [];
            particles = [];
            player.reset();
            
            // --- GENERACIÓN INICIAL ---
            // Llenar la pantalla de plataformas desde abajo para que no esté vacío
            nextObstacleY = canvas.height - 100;
            while (nextObstacleY > -200) { // Generar hasta un poco por encima de la pantalla
                spawnObstacle();
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            loop();
        }

        function spawnObstacle() {
            obstacles.push(new Obstacle(nextObstacleY, level, GAME_SEED));
            let gap = 160 - (Math.min(level, 10) * 5); // Reduce distancia con nivel
            gap += Math.random() * 40;
            nextObstacleY -= Math.max(100, gap);
        }

        function die() {
            if (gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER';
            playDead();
            createPixelParticles(player.x, player.y, player.color, 20);
            
            finalScoreDisplay.innerText = Math.floor(score);
            finalLevelDisplay.innerText = level;
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            if (window.myPlayerId && window.dbRef) {
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.deleteDoc(docRef).catch(console.error);
            }
        }

        function createPixelParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function checkCollisions() {
            // Colisión AABB simple
            for (let obs of obstacles) {
                // Definir cajas de colisión
                let pBox = {l: player.x, r: player.x + player.w, t: player.y, b: player.y + player.h};
                let oBox;

                if (obs.type === 'SPIKE') {
                    // Hitbox un poco más pequeña para ser justos
                    let width = obs.w - 10;
                    let x = (obs.side === 'LEFT') ? 0 : canvas.width - width;
                    oBox = {l: x, r: x + width, t: obs.y, b: obs.y + obs.h};
                } else {
                    oBox = {l: obs.x, r: obs.x + obs.w, t: obs.y, b: obs.y + obs.h};
                }

                if (pBox.l < oBox.r && pBox.r > oBox.l && pBox.t < oBox.b && pBox.b > oBox.t) {
                    die();
                }
            }
        }

        function sendNetUpdate() {
            const now = Date.now();
            if (now - lastNetUpdate > 100 && window.myPlayerId && gameState === 'PLAYING') {
                lastNetUpdate = now;
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.setDoc(docRef, {
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    vx: player.vx, // Importante para renderizar ojos remotos
                    color: player.color,
                    name: playerName,
                    updatedAt: window.dbRef.serverTimestamp ? window.dbRef.serverTimestamp() : now
                }).catch(e => {});
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;
            frames++;
            player.update();
            checkCollisions();
            sendNetUpdate();

            // Cámara
            let targetY = player.y - canvas.height * 0.6;
            if (targetY < cameraY) {
                cameraY = targetY;
                score += (cameraY - targetY) * 0.1; // Puntos
                if (Math.floor(score/500) + 1 > level) {
                    level++;
                    playLvlUp();
                    levelNotification.classList.remove('hidden');
                    levelNotification.classList.add('level-up-anim');
                    setTimeout(() => levelNotification.classList.add('hidden'), 2000);
                }
            } else {
                cameraY -= (1 + level * 0.1); // Auto-scroll lento
            }

            // Generar y Limpiar
            if (cameraY < nextObstacleY + canvas.height + 200) spawnObstacle();
            obstacles = obstacles.filter(obs => obs.y < cameraY + canvas.height + 200);
            obstacles.forEach(obs => obs.update());
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            scoreDisplay.innerText = Math.floor(Math.abs(cameraY/10));
            levelDisplay.innerText = level;
            
            let count = 1;
            if (window.remotePlayers) count += Object.keys(window.remotePlayers).length;
            onlineCountDisplay.innerText = count;
        }

        function draw() {
            // Fondo color sólido retro
            ctx.fillStyle = '#201a2e'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Patrón de fondo (estrellas pixeladas estáticas)
            ctx.fillStyle = '#2a233e';
            for(let i=0; i<10; i++) {
                let x = (i * 100 + cameraY/2) % canvas.width;
                let y = (i * 200 + cameraY/2) % canvas.height;
                ctx.fillRect(x, y, 4, 4);
            }

            ctx.save();
            ctx.translate(0, -Math.floor(cameraY)); // Pixel perfect cam

            obstacles.forEach(obs => obs.draw());

            // Jugadores Remotos
            if (window.remotePlayers) {
                for (let pid in window.remotePlayers) {
                    const rp = window.remotePlayers[pid];
                    ctx.fillStyle = rp.color;
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(rp.x, rp.y, 24, 24);
                    // Ojos remotos
                    ctx.fillStyle = 'white';
                    let eyeOff = (rp.vx > 0) ? 14 : 4;
                    ctx.fillRect(rp.x + eyeOff, rp.y + 6, 6, 6);
                    // Nombre
                    ctx.fillStyle = "#aaa";
                    ctx.font = "10px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.fillText(rp.name, rp.x + 12, rp.y - 8);
                    ctx.globalAlpha = 1;
                }
            }

            if (gameState === 'PLAYING') player.draw();
            particles.forEach(p => p.draw());

            ctx.restore();
        }

        function loop() {
            update();
            draw();
            if (gameState === 'PLAYING') requestAnimationFrame(loop);
        }

        // INPUTS
        function handleInput(e) {
            e.preventDefault();
            if (gameState === 'PLAYING') player.jump();
        }

        window.addEventListener('mousedown', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        });
        window.addEventListener('touchstart', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        }, {passive: false});
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (gameState === 'PLAYING') player.jump();
            }
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', () => {
             startScreen.classList.remove('hidden');
             gameOverScreen.classList.add('hidden');
        });

        // Render inicial
        player.y = canvas.height - 100;
        draw();

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Wall Jumper - Fixed Score</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- Fuente Pixel Art -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- FIREBASE SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAQOCfjlM3HbeJe9d5A7Cgvul5RmndlCbE",
            authDomain: "jumper-4e0b2.firebaseapp.com",
            projectId: "jumper-4e0b2",
            storageBucket: "jumper-4e0b2.firebasestorage.app",
            messagingSenderId: "397169417542",
            appId: "1:397169417542:web:9ec619008be7d20579d947",
            measurementId: "G-GTD3T9FYKK"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const APP_ID = "pixel-jumper-fixed-score"; 
        const COLLECTION_PATH = `artifacts/${APP_ID}/public/data/players`;

        window.myPlayerId = null;
        window.remotePlayers = {}; 
        window.dbRef = { db, collection, doc, setDoc, onSnapshot, deleteDoc, COLLECTION_PATH };
        
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    const userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                    window.myPlayerId = userCredential.user.uid;
                } else {
                    throw new Error("No token");
                }
            } catch (error) {
                try {
                    const userCredential = await signInAnonymously(auth);
                    window.myPlayerId = userCredential.user.uid;
                } catch (e) { console.error(e); }
            }
            if (window.myPlayerId) setupNetworkListeners();
        };

        initAuth();

        function setupNetworkListeners() {
            const q = collection(db, 'artifacts', APP_ID, 'public', 'data', 'players');
            onSnapshot(q, (snapshot) => {
                const now = Date.now();
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    if (pid === window.myPlayerId) return;

                    if (change.type === "added" || change.type === "modified") {
                        window.remotePlayers[pid] = {
                            x: data.x,
                            y: data.y,
                            vx: data.vx,
                            color: data.color || '#ffffff',
                            name: data.name || 'PX',
                            lastUpdate: now
                        };
                    }
                    if (change.type === "removed") delete window.remotePlayers[pid];
                });
            });
        }

        setInterval(() => {
            const now = Date.now();
            for (let pid in window.remotePlayers) {
                if (now - window.remotePlayers[pid].lastUpdate > 10000) delete window.remotePlayers[pid];
            }
        }, 5000);
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            font-family: 'Press Start 2P', cursive;
            image-rendering: pixelated;
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .interactive { pointer-events: auto; }
        
        /* SHAKE ANIMATION */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-screen {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        .pixel-card {
            background-color: #0f0f1a;
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.5);
            padding: 2rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        
        .pixel-btn {
            background-color: #222;
            border: 4px solid #fff;
            color: #fff;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 5px 0 #000;
            transition: transform 0.1s;
            margin-top: 20px;
            width: 100%;
        }
        .pixel-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #000;
        }

        .pixel-input {
            background-color: #000;
            border: 2px solid #555;
            color: #00ffaa;
            font-family: 'Press Start 2P', cursive;
            padding: 15px;
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            outline: none;
            text-transform: uppercase;
        }
        .pixel-input:focus {
            border-color: #00ffaa;
        }

        .homescreen-logo {
            text-shadow: 4px 4px 0px #000;
            line-height: 1.5;
        }
    </style>
</head>
<body id="gameBody">

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- Home Screen -->
        <div id="startScreen" class="pixel-card interactive">
            <h1 class="text-3xl text-purple-400 mb-8 homescreen-logo">NEON<br>JUMPER</h1>
            
            <div class="mb-6">
                <label class="text-xs text-gray-500 mb-2 block">NOMBRE DE PILOTO</label>
                <input type="text" id="playerNameInput" class="pixel-input" placeholder="JUGADOR" maxlength="8">
            </div>

            <p class="text-gray-400 text-[10px] mb-6 leading-loose">
                CLICK PARA SALTAR Y GIRAR<br>
                SUBE SIN PARAR<br>
                <span class="text-red-500">EVITA EL ROJO</span>
            </p>
            
            <button id="startBtn" class="pixel-btn text-purple-400 hover:text-white">JUGAR</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden pixel-card interactive">
            <h1 class="text-3xl text-red-500 mb-6 homescreen-logo">MUERTO</h1>
            
            <div class="grid grid-cols-2 gap-4 mb-6 text-sm">
                <div class="bg-black/50 p-2 border border-gray-700">
                    <div class="text-gray-500 text-[10px]">PUNTOS</div>
                    <span id="finalScore" class="text-yellow-400">0</span>
                </div>
                <div class="bg-black/50 p-2 border border-gray-700">
                    <div class="text-gray-500 text-[10px]">NIVEL</div>
                    <span id="finalLevel" class="text-purple-400">1</span>
                </div>
            </div>

            <button id="restartBtn" class="pixel-btn" style="border-color: #ff4444; color: #ff4444;">REINTENTAR</button>
            <button id="homeBtn" class="mt-4 text-[10px] text-gray-500 hover:text-white underline p-2">VOLVER AL MENU</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
            <div>
                <p class="text-gray-300 text-[10px] mb-2 bg-black/80 p-2 border border-gray-800 rounded shadow-lg">SCORE: <span id="scoreDisplay" class="text-yellow-200">0</span></p>
            </div>
            <div class="text-right">
                <p id="onlineCount" class="text-blue-300 text-[10px] bg-black/80 p-2 border border-gray-800 rounded shadow-lg">ONLINE: 1</p>
            </div>
        </div>

        <div id="levelNotification" class="absolute top-1/4 pointer-events-none text-center hidden">
            <h2 class="text-4xl text-purple-400 animate-pulse homescreen-logo">LEVEL UP!</h2>
        </div>
    </div>

    <script>
        // --- RNG ---
        class SeededRandom {
            constructor(seed) { this.seed = seed; }
            next() {
                var t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
            range(min, max) { return min + this.next() * (max - min); }
        }
        const GAME_SEED = 1234; 

        // --- CONFIGURACIÓN ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const body = document.getElementById('gameBody');
        ctx.imageSmoothingEnabled = false;

        // UI
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalLevelDisplay = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const homeBtn = document.getElementById('homeBtn');
        const levelNotification = document.getElementById('levelNotification');
        const nameInput = document.getElementById('playerNameInput');
        const onlineCountDisplay = document.getElementById('onlineCount');

        let gameState = 'MENU';
        let score = 0;
        let level = 1;
        let frames = 0;
        let cameraY = 0;
        let playerName = "PX";

        // --- CARGAR NOMBRE GUARDADO ---
        const savedName = localStorage.getItem('pixelJumperName');
        if (savedName) {
            nameInput.value = savedName;
            playerName = savedName;
        }

        // --- FÍSICA FÁCIL (EASY MODE) ---
        const GRAVITY = 0.55; 
        const JUMP_FORCE = -11.5; 
        const HORIZONTAL_SPEED = 6; 
        const MAX_FALL_SPEED = 12;

        const LEVEL_COLORS = [
            '#050510', // Deep Blue
            '#100505', // Deep Red
            '#051005', // Deep Green
            '#100510', // Deep Purple
            '#000000'  // Void
        ];

        // --- AUDIO ---
        let synth, noise;
        let audioInit = false;

        async function initAudio() {
            if (audioInit) return;
            await Tone.start();
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.02, decay: 0.2, sustain: 0.1, release: 0.5 }
            }).toDestination();
            synth.volume.value = -10;
            
            const reverb = new Tone.Reverb(2).toDestination();
            synth.connect(reverb);

            noise = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0 }
            }).toDestination();
            noise.volume.value = -12;
            audioInit = true;
        }

        function playJump() { if(audioInit) synth.triggerAttackRelease("C3", "16n"); }
        function playBounce() { if(audioInit) synth.triggerAttackRelease("G2", "32n"); }
        function playDead() { if(audioInit) { noise.triggerAttackRelease("8n"); synth.triggerAttackRelease(["C2", "G1"], "4n"); }}
        function playLvlUp() { if(audioInit) synth.triggerAttackRelease(["C3", "E3", "G3", "C4"], "8n"); }

        // --- CLASES ---

        class Player {
            constructor(isLocal = true) {
                this.w = 24; this.h = 24;
                this.isLocal = isLocal;
                this.reset();
            }

            reset() {
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 150;
                this.vx = HORIZONTAL_SPEED;
                this.vy = 0;
                const colors = ['#00ffaa', '#00ccff', '#ff00ff', '#ffff00']; 
                this.color = this.isLocal ? colors[Math.floor(Math.random()*colors.length)] : '#fff';
                this.isDead = false;
            }

            update() {
                if (!this.isLocal || this.isDead) return;

                this.vy += GRAVITY;
                if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;
                
                this.x += this.vx;
                this.y += this.vy;

                if (this.x <= 0) {
                    this.x = 0; this.vx *= -1; playBounce();
                    createParticles(this.x, this.y + this.h/2, '#fff', 4);
                } else if (this.x + this.w >= canvas.width) {
                    this.x = canvas.width - this.w; this.vx *= -1; playBounce();
                    createParticles(this.x + this.w, this.y + this.h/2, '#fff', 4);
                }

                if (this.y > cameraY + canvas.height + 200) die();
            }

            jump() {
                if (this.isDead) return;
                this.vy = JUMP_FORCE;
                this.vx *= -1; 
                playJump();
                createParticles(this.x + this.w/2, this.y + this.h, this.color, 6);
            }

            draw() {
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.w, this.h);
                ctx.shadowBlur = 0;

                const eyeXOffset = (this.vx > 0) ? 14 : 4;
                ctx.fillStyle = '#000';
                ctx.fillRect(Math.floor(this.x + eyeXOffset), Math.floor(this.y + 6), 6, 6);
                
                if (this.name) {
                    ctx.fillStyle = "#aaa";
                    ctx.font = "8px 'Press Start 2P'";
                    ctx.textAlign = "center";
                    ctx.fillText(this.name, this.x + this.w/2, this.y - 10);
                }
            }
        }

        class Obstacle {
            constructor(y, lvl, seed) {
                const rng = new SeededRandom(seed + Math.floor(y));
                this.y = y;
                this.h = 32;
                
                let moveProb = 0.2; 
                if (lvl >= 3) moveProb = 0.5;

                this.type = rng.next() < moveProb ? 'MOVING' : 'STATIC';
                this.spikeColor = '#ff0055'; 

                if (this.type === 'STATIC') {
                    let maxLen = Math.min(130, 50 + lvl * 8);
                    this.w = 50 + rng.next() * maxLen;
                    this.side = rng.next() > 0.5 ? 'LEFT' : 'RIGHT';
                    this.x = this.side === 'LEFT' ? 0 : canvas.width - this.w;
                    this.isSpike = true; 
                } else {
                    this.w = Math.max(80, 140 - (lvl * 5)); 
                    this.x = rng.next() * (canvas.width - this.w);
                    let speed = 1.5 + (lvl * 0.4); 
                    this.vx = speed * (rng.next() > 0.5 ? 1 : -1);
                    this.isSpike = false; 
                }
            }

            update() {
                if (this.type === 'MOVING') {
                    this.x += this.vx;
                    if (this.x <= 0 || this.x + this.w >= canvas.width) this.vx *= -1;
                }
            }

            draw() {
                if (this.isSpike) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.spikeColor;
                    ctx.fillStyle = this.spikeColor;
                    
                    const steps = 4;
                    const stepH = this.h / steps;
                    if (this.side === 'LEFT') {
                        ctx.fillRect(0, this.y, this.w/2, this.h);
                        for(let i=0; i<steps; i++) {
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(this.w/2, this.y + (i*stepH), width, stepH);
                        }
                    } else {
                        ctx.fillRect(canvas.width - this.w/2, this.y, this.w/2, this.h);
                        for(let i=0; i<steps; i++) {
                            let width = (this.w/2) * (1 - i/steps);
                            ctx.fillRect(canvas.width - this.w/2 - width, this.y + (i*stepH), width, stepH);
                        }
                    }
                    ctx.shadowBlur = 0;
                } else {
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ccaa00';
                    ctx.fillStyle = '#ccaa00'; 
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x + 4, this.y + 4, this.w - 8, this.h - 8); 
                    ctx.shadowBlur = 0;
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1; this.color = color; 
                this.size = Math.floor(Math.random() * 3 + 2);
            }
            update() { 
                this.x += this.vx; this.y += this.vy; 
                this.life -= 0.04; 
            }
            draw() { 
                ctx.globalAlpha = this.life; 
                ctx.shadowBlur = 5; ctx.shadowColor = this.color;
                ctx.fillStyle = this.color; 
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.size, this.size);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1; 
            }
        }

        // --- GLOBAL ---
        const player = new Player(true);
        let obstacles = [];
        let particles = [];
        let nextObstacleY = 0;
        let lastNetUpdate = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'MENU') player.reset();
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            const nameInputVal = nameInput.value.trim().toUpperCase() || "PX";
            playerName = nameInputVal;
            player.name = playerName;
            
            // GUARDAR NOMBRE
            localStorage.setItem('pixelJumperName', playerName);

            initAudio();
            gameState = 'PLAYING';
            score = 0;
            level = 1;
            frames = 0;
            cameraY = 0;
            obstacles = [];
            particles = [];
            player.reset();
            
            // Reset Shake
            body.classList.remove('shake-screen');

            // GENERACIÓN SEGURA
            nextObstacleY = canvas.height - 200; 
            while (nextObstacleY > -canvas.height) {
                spawnObstacle();
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            loop();
        }

        function spawnObstacle() {
            obstacles.push(new Obstacle(nextObstacleY, level, GAME_SEED));
            let baseGap = 180; 
            let gap = baseGap - (Math.min(level, 10) * 3);
            gap += Math.random() * 40; 
            nextObstacleY -= Math.max(150, gap); 
        }

        function die() {
            if (gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER';
            
            // SCREEN SHAKE EFECTO
            body.classList.add('shake-screen');
            setTimeout(() => body.classList.remove('shake-screen'), 500);

            playDead();
            createParticles(player.x, player.y, player.color, 25);
            
            finalScoreDisplay.innerText = Math.floor(score);
            finalLevelDisplay.innerText = level;
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            if (window.myPlayerId && window.dbRef) {
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.deleteDoc(docRef).catch(()=>{});
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function checkCollisions() {
            let pBox = {l: player.x + 4, r: player.x + player.w - 4, t: player.y + 4, b: player.y + player.h - 4}; 
            
            for (let obs of obstacles) {
                let oBox;
                if (obs.isSpike) {
                    let width = obs.w - 12; 
                    let x = (obs.side === 'LEFT') ? 0 : canvas.width - width;
                    oBox = {l: x, r: x + width, t: obs.y + 4, b: obs.y + obs.h - 4};
                } else {
                    oBox = {l: obs.x + 2, r: obs.x + obs.w - 2, t: obs.y + 2, b: obs.y + obs.h - 2};
                }

                if (pBox.l < oBox.r && pBox.r > oBox.l && pBox.t < oBox.b && pBox.b > oBox.t) {
                    die();
                }
            }
        }

        function sendNetUpdate() {
            const now = Date.now();
            if (now - lastNetUpdate > 100 && window.myPlayerId && gameState === 'PLAYING') {
                lastNetUpdate = now;
                const docRef = window.dbRef.doc(window.dbRef.db, window.dbRef.COLLECTION_PATH, window.myPlayerId);
                window.dbRef.setDoc(docRef, {
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    vx: player.vx, 
                    color: player.color,
                    name: playerName,
                    updatedAt: window.dbRef.serverTimestamp ? window.dbRef.serverTimestamp() : now
                }).catch(()=>{});
            }
        }

        function update() {
            if (gameState !== 'PLAYING') return;
            frames++;
            player.update();
            checkCollisions();
            sendNetUpdate();

            let targetY = player.y - canvas.height * 0.6;
            if (targetY < cameraY) {
                let diff = cameraY - targetY;
                cameraY = targetY;
                
                // CORRECCIÓN PUNTOS: SUMAMOS LA DIFERENCIA POSITIVA
                score += diff * 0.5;

                let newLevel = Math.floor(score / 500) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    playLvlUp();
                    levelNotification.classList.remove('hidden');
                    levelNotification.classList.add('level-up-anim');
                    setTimeout(() => levelNotification.classList.add('hidden'), 2000);
                }
            } else {
                cameraY -= (0.8 + level * 0.15); 
            }

            if (cameraY < nextObstacleY + canvas.height + 300) {
                spawnObstacle();
            }

            obstacles = obstacles.filter(obs => obs.y < cameraY + canvas.height + 300);
            obstacles.forEach(obs => obs.update());
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            scoreDisplay.innerText = Math.floor(score);
            
            let count = 1;
            if (window.remotePlayers) count += Object.keys(window.remotePlayers).length;
            onlineCountDisplay.innerText = `ONLINE: ${count}`;
        }

        function draw() {
            let bgIndex = (level - 1) % LEVEL_COLORS.length;
            ctx.fillStyle = LEVEL_COLORS[bgIndex];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            for(let i=0; i<30; i++) {
                let x = (i * 47) % canvas.width;
                let y = (i * 93 - cameraY*0.2) % canvas.height;
                if(y < 0) y += canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }

            ctx.save();
            ctx.translate(0, -Math.floor(cameraY));

            obstacles.forEach(obs => obs.draw());

            if (window.remotePlayers) {
                for (let pid in window.remotePlayers) {
                    const rp = window.remotePlayers[pid];
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = rp.color;
                    ctx.fillStyle = rp.color;
                    ctx.globalAlpha = 0.4;
                    ctx.fillRect(rp.x, rp.y, 24, 24);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }

            if (gameState === 'PLAYING') player.draw();
            particles.forEach(p => p.draw());

            ctx.restore();

            let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.height/3, canvas.width/2, canvas.height/2, canvas.height);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.8)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }

        function loop() {
            update();
            draw();
            if (gameState === 'PLAYING') requestAnimationFrame(loop);
        }

        function handleInput(e) {
            e.preventDefault();
            if (gameState === 'PLAYING') player.jump();
        }

        window.addEventListener('mousedown', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        });
        window.addEventListener('touchstart', (e) => {
            if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') handleInput(e);
        }, {passive: false});
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (gameState === 'PLAYING') player.jump();
            }
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        
        homeBtn.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            gameState = 'MENU';
            player.reset();
            player.y = canvas.height - 150;
            cameraY = 0;
            body.classList.remove('shake-screen');
            draw();
        });

        player.y = canvas.height - 150;
        draw();

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- 
      IMPORTANTE: Cargar los módulos de Three.js desde un CDN
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- 
      Cargamos el generador de ruido Simplex para el terreno 
    -->
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>

    <!-- 
      CAMBIO: Cargar Firebase (App, Auth, RTDB)
      NOTA: Este bloque <script> se ha fusionado con el script principal del juego más abajo.
    -->
    
    <!-- NUEVO: Importar fuente Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CAMBIO DE NOMBRE -->
    <title>Cliente 3D MainCraft</title>
    <style>
        /* --- NUEVO: Estilos Modernos (Modo Oscuro) --- */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif; /* Fuente Inter */
            background-color: #1a1a1a; /* Fondo oscuro */
            color: #f0f0f0;
        }
        canvas {
            display: block;
        }
        
        /* --- Contenedores de Pantalla --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 26, 0.95); /* Fondo oscuro semitransparente */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99;
        }
        
        /* Ocultar pantallas por defecto */
        #homescreen, #game-ui, #crosshair {
            display: none;
        }

        /* --- Estilos de Cajas de Formulario --- */
        .form-box {
            width: 380px;
            padding: 30px;
            background-color: #2c2c2c; /* Gris oscuro para el formulario */
            border-radius: 12px;
            text-align: center;
            color: #f0f0f0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
        
        .form-box h2 {
            margin-top: 0;
            color: #66bb6a; /* Verde claro */
            font-weight: 700;
        }

        .input-group {
            margin-bottom: 18px;
            text-align: left;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
            font-size: 0.9em;
            color: #aaa;
        }
        
        .input-group input {
            width: 95%; /* Ajustado para padding */
            padding: 12px 10px;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #3a3a3a; /* Fondo de input oscuro */
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            font-size: 1em;
        }
        
        /* Placeholder styling */
        .input-group input::placeholder {
            color: #888;
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            font-size: 18px;
            background-color: #66bb6a; /* Verde claro */
            color: #111; /* Texto oscuro para mejor contraste */
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 99;
            margin-top: 10px;
            font-weight: 700;
            transition: background-color 0.2s ease;
        }
        .btn:hover {
            background-color: #81c784;
        }
        .btn:disabled {
            background-color: #555;
            color: #888;
        }
        
        .status-message {
            margin-top: 15px;
            color: #f44336; /* Rojo */
            font-weight: bold;
        }
        
        /* --- Estilos del Homescreen (Selector de Servidor) --- */
        #server-list-container {
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 6px;
            margin-bottom: 15px;
            background: #3a3a3a; /* Fondo oscuro */
        }
        
        .server-item {
            padding: 14px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s ease;
            /* CAMBIO: Añadido flex para alinear botón */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .server-item:hover {
            background-color: #4a5a4a; /* Verde oscuro hover */
        }
        .server-item:last-child {
            border-bottom: none;
        }
        
        /* CAMBIO: Contenedor para el nombre y creador */
        .server-item-name {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            flex-grow: 1; /* Ocupa el espacio */
        }
        .server-item-name span {
            font-size: 1.1em;
            color: #f0f0f0;
        }
        
        /* Estilo para el nombre del creador */
        .creator-name {
            font-size: 0.8em;
            color: #aaa;
            /* margin-left: 10px; (Eliminado, ahora está debajo) */
        }
        
        /* CAMBIO: Estilo para el botón de eliminar */
        .delete-world-btn {
            width: auto;
            padding: 6px 12px;
            font-size: 0.9em;
            background-color: #f44336; /* Rojo */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px; /* Espacio del nombre */
            transition: background-color 0.2s ease;
            font-weight: 700;
        }
        .delete-world-btn:hover {
            background-color: #e57373;
        }
        
        #create-world-group {
            display: flex;
            gap: 10px;
        }
        
        #create-world-group input {
            flex-grow: 1; 
            width: 60%;
        }
        
        #createWorldButton {
            width: auto;
            flex-grow: 0;
            font-size: 16px;
        }
        
        #logoutButton {
            background-color: #f44336; /* Rojo */
            color: white;
            margin-top: 20px;
        }
        #logoutButton:hover {
            background-color: #e57373;
        }

        /* --- Estilos del Juego --- */
        
        /* NUEVO: Contenedor para las etiquetas de nombres (CSS2D) */
        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* No intercepta clics */
            z-index: 5; /* Detrás de la UI pero delante del juego */
        }
        
        /* NUEVO: Estilo para la etiqueta del nombre del jugador */
        .player-label {
            color: white;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 700;
            text-shadow: 1px 1px 2px black;
            user-select: none;
            white-space: nowrap; /* Evita que el nombre se parta */
        }

        /* Mirilla (crosshair) en el centro */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border: 1px solid rgba(0,0,0,0.5);
            border-radius: 50%; /* Punto circular */
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none; /* Evita que la mirilla bloquee los clics */
        }

        /* Interfaz de Usuario (Vida y Hotbar) */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            /* display: none; Oculto por #game-ui */
            flex-direction: column; /* Apila la vida encima de la hotbar */
            align-items: center;
            z-index: 20;
            pointer-events: none; /* No intercepta clics */
        }
        
        /* Barra de Vida */
        #health-bar {
            display: flex;
            margin-bottom: 5px; /* Espacio entre vida y hotbar */
        }
        
        .heart {
            font-size: 20px;
            margin: 0 1px;
            user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); 
        }

        /* Estilos de la Hotbar 3D */
        #hotbar {
            display: flex;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 5px;
        }

        .hotbar-slot {
            width: 50px;
            height: 50px;
            margin: 2px;
            border: 2px solid #888;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow: hidden; 
            position: relative; /* NUEVO: Para posicionar la cantidad */
        }
        
        .hotbar-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hotbar-slot.active {
            border: 3px solid #ffffff;
            transform: scale(1.05); /* Resaltar */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        /* NUEVO: Estilo para la cantidad en la hotbar */
        .hotbar-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            display: none; /* Oculto por defecto */
        }
    </style>
</head>
<body>
    <!-- PANTALLA 1: LOGIN -->
    <div id="login-screen" class="screen">
        <div class="form-box">
            <!-- CAMBIO DE NOMBRE -->
            <h2>MainCraft Online</h2>
            <div class="input-group">
                <label for="username">Usuario:</label>
                <!-- CAMBIO: Eliminado 'value' y añadido 'placeholder' -->
                <input type="text" id="username" placeholder="TuUsuario">
            </div>
            <div class="input-group">
                <label for="password">Contraseña:</label>
                <!-- CAMBIO: Eliminado 'value' y añadido 'placeholder' -->
                <input type="password" id="password" placeholder="TuContraseña">
            </div>
            <button id="loginButton" class="btn">Login / Registrarse</button>
            <div id="loginStatus" class="status-message"></div>
        </div>
    </div>

    <!-- PANTALLA 2: HOMESCREEN (SELECTOR DE MUNDO) -->
    <div id="homescreen" class="screen">
        <div class="form-box">
            <h2>Selecciona un Mundo</h2>
            <div id="server-list-container">
                <div id="server-list">
                    <!-- Los servidores se llenan con JS -->
                </div>
            </div>
            
            <div class="input-group">
                <label for="newWorldName">O crea uno nuevo:</label>
                <div id="create-world-group">
                    <input type="text" id="newWorldName" placeholder="Nombre del nuevo mundo...">
                    <button id="createWorldButton" class="btn">Crear</button>
                </div>
            </div>
            
            <button id="logoutButton" class="btn">Cerrar Sesión</button>
        </div>
    </div>

    <!-- PANTALLA 3: JUEGO -->
    
    <!-- NUEVO: Contenedor para las etiquetas de nombres -->
    <div id="label-container"></div>
    
    <!-- La mirilla -->
    <div id="crosshair"></div>

    <!-- Contenedor de la Interfaz (Vida + Hotbar) -->
    <div id="game-ui">
        <div id="ui-container">
            <!-- Barra de vida -->
            <div id="health-bar">
                <!-- Los corazones se generan dinámicamente con JS -->
            </div>
            <!-- Contenedor de la Hotbar -->
            <div id="hotbar">
                <!-- Los slots y canvas se generan dinámicamente con JS -->
            </div>
        </div>
    </div>

    <!-- 
      Script principal del juego
    -->
    <script type="module">
        
        // --- Configuración de Firebase (dada por el usuario) ---
        const firebaseConfig = {
          apiKey: "AIzaSyCvqvernkGHCvBuGArnJSXcka40lCFBKGk",
          authDomain: "maincraft-e2b8c.firebaseapp.com",
          // CORRECCIÓN: Faltaba una 't' en firebasedatabase.app
          databaseURL: "https://maincraft-e2b8c-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "maincraft-e2b8c",
          storageBucket: "maincraft-e2b8c.firebasestorage.app",
          messagingSenderId: "10833551639",
          appId: "1:10833551639:web:d2f83d3967b38710f31752",
          measurementId: "G-E2FMTZZ92P"
        };
        
        // --- CORRECCIÓN: Imports de Firebase movidos aquí ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        // CORRECCIÓN: Arreglado 'httpsS' a 'https'
        import { getDatabase, ref, set, onValue, onChildAdded, onChildRemoved, serverTimestamp, query, orderByChild, remove, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // --- Imports de Three.js ---
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        // NUEVO: Importar CSS2DRenderer para nombres de jugadores
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- CORRECCIÓN: Imports de Firebase (desde el objeto window) ---
        // Este bloque ya no es necesario, las variables están importadas localmente.
        /*
        const {
            initializeApp, getAuth, signInWithEmailAndPassword,
            createUserWithEmailAndPassword, signOut, getDatabase, ref,
            set, onValue, onChildAdded, onChildRemoved, serverTimestamp,
            query, orderByChild, remove, off
        } = window.firebase;
        */


        // --- Variables Globales ---
        let scene, camera, renderer, controls, raycaster;
        let noise; // Generador de ruido
        
        // NUEVO: Renderer para las etiquetas 2D
        let labelRenderer;
        
        // --- Constantes del Jugador ---
        const playerHeight = 1.9; // Altura del jugador
        const playerWidth = 0.4; 
        const gravity = -30.0; 
        const jumpForce = 12.0; 
        const moveSpeed = 40.0; 

        // --- Variables de Firebase ---
        let db, auth;
        let worldName; // El "servidor"
        let userId;    // Nuestro ID de Firebase
        let userName;  // NUEVO: Nuestro nombre de usuario
        let lastFirebaseUpdate = 0;
        let players = new Map(); // Mapa para [userId, { mesh, label }] de otros jugadores
        const playerMeshGeometry = new THREE.BoxGeometry(playerWidth * 2, playerHeight, playerWidth * 2);
        const playerMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, opacity: 0.6, transparent: true });
        
        // Listeners de Firebase (para poder desconectarlos)
        let playersListener = null;
        let blocksListener = { added: null, removed: null }; 
        let worldsListener = null;
        // NUEVO: Listener para nuestro inventario
        let inventoryListener = null; 


        // --- Sistema de Chunks ---
        const worldBlocks = new Map(); 
        const blockData = new Map(); // Guarda la Mesh
        
        const chunkSize = 16; 
        // CAMBIO: Render Distance 3x3 (1 de cada lado)
        const renderDistance = 1;
        
        let currentChunk = new THREE.Vector2(Infinity, Infinity); 

        // --- Variables del Jugador ---
        let playerVelocity = new THREE.Vector3();
        let playerDirection = new THREE.Vector3();
        let playerOnFloor = false; 
        let playerBox = new THREE.Box3(); 
        let lastPlayerVelY = 0; // Para calcular daño por caída

        // --- Sistema de Vida ---
        let playerHealth = 20;
        let playerMaxHealth = 20;

        // --- Variables de Movimiento ---
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        
        let prevTime = performance.now(); 

        // --- Sistema de Minería ---
        let isMining = false;
        let miningTimer = 0;
        let currentMiningBlock = null; 
        const blockBreakTime = 0.5; 
        
        // --- Animación de Rotura ---
        let destroyTextures = []; 
        let breakingBlockOverlay = null; 
        let breakingMaterial; 

        // --- CAMBIO: Variables de Inventario y Hotbar 3D ---
        let hotbarElement;
        let hotbarSlots = []; 
        let selectedSlot = 0; 
        let inventory = []; // Ahora será un array de { type, quantity }
        let materials = {}; 
        
        let hotbarScenes = [];      
        let hotbarRenderers = [];   
        let hotbarMeshes = [];      
        let hotbarCamera;           

        // --- URLs de Texturas ---
        const textureBaseUrl = 'https://logise1.github.io/maincraft/';
        const textureLoader = new THREE.TextureLoader();
        
        // --- URL de Texturas de Rotura ---
        // CORRECCIÓN: Eliminada la URL base de rotura, usaremos textureBaseUrl
        // const breakTextureBaseUrl = '...'; 
        
        // --- CAMBIO: Constantes del Mundo (revertidas) ---
        const terrainHeight = 6;
        const terrainScale = 0.05; 
        const worldDepth = 0; // Revertido
        
        // Geometría y material de los bloques (reutilizables)
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

        // --- ¡CARGA DE TEXTURAS! ---
        const stoneTexture = textureLoader.load(`${textureBaseUrl}stone.png`);
        const dirtTexture = textureLoader.load(`${textureBaseUrl}dirt.png`);
        const grassTopTexture = textureLoader.load(`${textureBaseUrl}grass_block_top.png`);
        const grassSideTexture = textureLoader.load(`${textureBaseUrl}grass_block_side.png`);
        
        stoneTexture.magFilter = THREE.NearestFilter;
        dirtTexture.magFilter = THREE.NearestFilter;
        grassTopTexture.magFilter = THREE.NearestFilter;
        grassSideTexture.magFilter = THREE.NearestFilter;


        // --- ¡MATERIALES ACTUALIZADOS CON TEXTURAS! ---
        const grassMaterial = [
            new THREE.MeshStandardMaterial({ map: grassSideTexture }),     // Lado (right)
            new THREE.MeshStandardMaterial({ map: grassSideTexture }),     // Lado (left)
            new THREE.MeshStandardMaterial({ map: grassTopTexture, color: 0x90ee90 }),  // Arriba (top) - Tinte verde
            new THREE.MeshStandardMaterial({ map: dirtTexture }),          // Abajo (bottom)
            new THREE.MeshStandardMaterial({ map: grassSideTexture }),     // Lado (front)
            new THREE.MeshStandardMaterial({ map: grassSideTexture })      // Lado (back)
        ];
        
        const dirtMaterial = new THREE.MeshStandardMaterial({ map: dirtTexture });
        const stoneMaterial = new THREE.MeshStandardMaterial({ map: stoneTexture });

        // --- OPTIMIZACIÓN DE COLISIÓN ---
        const collisionCheckBlockBox = new THREE.Box3();
        const boxMin = new THREE.Vector3();
        const boxMax = new THREE.Vector3();


        // --- Inicialización ---
        function init() {
            // CAMBIO: Inicializar inventario vacío
            inventory = [];
            for (let i = 0; i < 9; i++) {
                inventory.push({ type: null, quantity: 0 });
            }
            
            materials = {
                'dirt': dirtMaterial,
                'grass': grassMaterial,
                'stone': stoneMaterial
            };

            // 1. Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 0, (renderDistance + 1) * chunkSize); 

            // 2. Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = terrainHeight + 5; 

            // 3. Renderer (WebGL)
            renderer = new THREE.WebGLRenderer({ antias: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            document.body.appendChild(renderer.domElement);
            
            // NUEVO: 3b. Renderer (CSS2D para etiquetas)
            const labelContainer = document.getElementById('label-container');
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelContainer.appendChild(labelRenderer.domElement);

            // 4. Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; 
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // 5. Controles (Pointer Lock)
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); 
            
            // --- Lógica de desbloqueo de cursor ---
            controls.addEventListener('unlock', () => {
                if (worldName) {
                    // 1. Desconectar listeners del mundo
                    if (playersListener) off(ref(db, `worlds/${worldName}/players`), 'value', playersListener);
                    if (blocksListener.added) off(ref(db, `worlds/${worldName}/blocks`), 'child_added', blocksListener.added);
                    if (blocksListener.removed) off(ref(db, `worlds/${worldName}/blocks`), 'child_removed', blocksListener.removed);
                    // NUEVO: Desconectar listener de inventario
                    if (inventoryListener) off(ref(db, `worlds/${worldName}/inventories/${userId}`), 'value', inventoryListener);
                    
                    
                    // 2. Limpiar variables del mundo
                    playersListener = null;
                    blocksListener = { added: null, removed: null };
                    inventoryListener = null;
                    worldName = null;
                    
                    // Limpiar jugadores
                    players.forEach(player => {
                        scene.remove(player.mesh);
                        player.mesh.remove(player.label); // Quitar etiqueta del mesh
                    });
                    players.clear();
                    
                    // 3. Mostrar homescreen
                    document.getElementById('game-ui').style.display = 'none';
                    document.getElementById('crosshair').style.display = 'none';
                    document.getElementById('ui-container').style.display = 'none';
                    showHomescreen(); // Volver a la lista de servidores
                }
            });
            
            // --- NUEVO: Lógica del Login ---
            initLoginScreen();
            
            // 6. Raycaster (para poner/quitar bloques)
            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 5); // 5 unidades de alcance

            // 7. Generador de Ruido
            noise = new window.SimplexNoise(); 
            
            // Cargar texturas de rotura
            for (let i = 0; i < 10; i++) {
                // CORRECCIÓN: Usar textureBaseUrl y el nuevo formato de nombre
                const texture = textureLoader.load(`${textureBaseUrl}destroy_stage_${i}.png`);
                texture.magFilter = THREE.NearestFilter;
                destroyTextures.push(texture);
            }
            
            // Material de rotura
            breakingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                depthTest: false,
                depthWrite: false
            });
            
            // --- Configurar UI (Vida y Hotbar) ---
            setupHealthBar();
            setupHotbar(); // Prepara la ESTRUCTURA de la hotbar
            
            // --- Eventos de Teclado y Ratón ---
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp); 
            document.addEventListener('wheel', onMouseWheel); 

            // --- Manejador de Redimensión de Ventana ---
            window.addEventListener('resize', onWindowResize);
            
            // Iniciar AMBOS bucles del juego
            animate();
            animateHotbar(); 
        }
        
        // --- NUEVO: Flujo de Autenticación y Lobby ---
        
        function initLoginScreen() {
            const loginButton = document.getElementById('loginButton');
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            const loginStatus = document.getElementById('loginStatus');

            loginButton.addEventListener('click', async () => {
                const username = usernameInput.value;
                const password = passwordInput.value;
                const email = username + "@email.org";

                if (!username || !password) {
                    loginStatus.textContent = "Rellena todos los campos.";
                    return;
                }
                
                loginStatus.textContent = "Conectando...";
                loginButton.disabled = true;
                
                // NUEVO: Guardar nombre de usuario
                userName = username;

                try {
                    // 1. Inicializar Firebase
                    // CORRECCIÓN: Usar las variables importadas (initializeApp, getAuth, etc.)
                    const app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getDatabase(app); // CAMBIO: getDatabase() para RTDB

                    // 2. Intentar Iniciar Sesión
                    try {
                        const userCredential = await signInWithEmailAndPassword(auth, email, password);
                        userId = userCredential.user.uid;
                    } catch (signInError) {
                        // 3. Si falla el login (usuario no existe O contraseña incorrecta)
                        //    El error 'auth/invalid-credential' es el nuevo estándar.
                        if (signInError.code === 'auth/user-not-found' || signInError.code === 'auth/invalid-credential') {
                            // Intentamos crear la cuenta
                            try {
                                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                                userId = userCredential.user.uid;
                            } catch (createError) {
                                // Si 'email-already-in-use', significa que el usuario SÍ existe,
                                // y la contraseña del login era incorrecta.
                                if (createError.code === 'auth/email-already-in-use') {
                                    loginStatus.textContent = "Contraseña incorrecta.";
                                    loginButton.disabled = false;
                                    return; // No continuar
                                } else {
                                    // Otro error al crear
                                    throw createError;
                                }
                            }
                        } else {
                            // Otro error de login (red, etc.)
                            throw signInError; 
                        }
                    }
                    
                    // 4. Si todo va bien, ir al Homescreen
                    loginStatus.textContent = "";
                    showHomescreen();

                } catch (error) {
                    console.error("Error de autenticación:", error);
                    loginStatus.textContent = `Error: ${error.message}`;
                    loginButton.disabled = false;
                }
            });
        }
        
        function showHomescreen() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('homescreen').style.display = 'flex';
            
            const createButton = document.getElementById('createWorldButton');
            const newWorldInput = document.getElementById('newWorldName');
            const logoutButton = document.getElementById('logoutButton');
            
            createButton.onclick = async () => {
                const newWorld = newWorldInput.value.trim();
                if (newWorld) {
                    // 1. Crear la entrada en la lista de mundos (RTDB)
                    const worldListRef = ref(db, "worldList/" + newWorld);
                    
                    // CAMBIO: Añadir creatorId y creatorName
                    await set(worldListRef, { 
                        createdAt: serverTimestamp(),
                        creatorId: userId,
                        creatorName: userName // Usar el nombre de usuario guardado
                    });
                    
                    // 2. Unirse al mundo
                    joinWorld(newWorld);
                }
            };
            
            logoutButton.onclick = async () => {
                await signOut(auth);
                // Desconectar listeners
                if (worldsListener) {
                    off(ref(db, "worldList"), 'value', worldsListener);
                }
                
                document.getElementById('homescreen').style.display = 'none';
                document.getElementById('login-screen').style.display = 'flex';
                document.getElementById('loginButton').disabled = false;
                document.getElementById('loginStatus').textContent = "Sesión cerrada.";
            };

            // Empezar a escuchar la lista de mundos (RTDB)
            const worldListRef = ref(db, "worldList");
            const q = query(worldListRef, orderByChild("createdAt"));
            
            // Desconectar listener anterior si existe
            if (worldsListener) off(ref(db, "worldList"), 'value', worldsListener);
            
            worldsListener = onValue(q, (snapshot) => {
                const serverList = document.getElementById('server-list');
                serverList.innerHTML = ''; // Limpiar lista
                
                if(!snapshot.exists()) {
                    serverList.innerHTML = '<div style="padding: 10px; color: #777;">No hay mundos. ¡Crea uno!</div>';
                    return;
                }
                
                // CAMBIO: RTDB onValue da los datos, hay que iterar y revertir para orden desc.
                const worlds = [];
                snapshot.forEach(childSnapshot => {
                    worlds.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                
                worlds.reverse().forEach(world => {
                    const serverItem = document.createElement('div');
                    serverItem.className = 'server-item';
                    
                    // Contenedor del nombre (para clic)
                    const serverNameDiv = document.createElement('div');
                    serverNameDiv.className = 'server-item-name';
                    
                    const creator = world.creatorName || 'Desconocido';
                    serverNameDiv.innerHTML = `<span>${world.id}</span> <span class="creator-name">(Creador: ${creator})</span>`;
                    
                    serverNameDiv.onclick = () => {
                        joinWorld(world.id);
                    };
                    serverItem.appendChild(serverNameDiv);
                    
                    // CAMBIO: Lógica de AJUSTES (Botón Eliminar)
                    if (world.creatorId === userId) {
                        const deleteButton = document.createElement('button');
                        deleteButton.className = 'delete-world-btn';
                        deleteButton.textContent = 'Eliminar';
                        deleteButton.onclick = async (e) => {
                            e.stopPropagation(); // Evitar unirse al mundo
                            if (confirm(`¿Seguro que quieres eliminar el mundo "${world.id}"? Esta acción no se puede deshacer.`)) {
                                await deleteWorld(world.id);
                            }
                        };
                        serverItem.appendChild(deleteButton);
                    }
                    
                    serverList.appendChild(serverItem);
                });
            });
        }
        
        // CAMBIO: Nueva función para eliminar mundos
        async function deleteWorld(worldId) {
            // Eliminar de la lista de mundos
            const worldListRef = ref(db, `worldList/${worldId}`);
            await remove(worldListRef);
            
            // Eliminar todos los datos del mundo (bloques, jugadores)
            const worldDataRef = ref(db, `worlds/${worldId}`);
            await remove(worldDataRef);
            
            // El listener 'onValue' de la lista de mundos se actualizará solo
        }
        
        // CAMBIO: joinWorld ahora carga el inventario
        async function joinWorld(selectedWorldName) {
            worldName = selectedWorldName;
            
            // Desconectar el listener de la lista de mundos
            if (worldsListener) {
                off(ref(db, "worldList"), 'value', worldsListener);
            }
            
            // Ocultar homescreen y mostrar UI del juego
            document.getElementById('homescreen').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block'; // Es el contenedor
            document.getElementById('ui-container').style.display = 'flex';
            document.getElementById('crosshair').style.display = 'block';
            
            // NUEVO: Cargar inventario ANTES de entrar
            await loadInventory();
            
            controls.lock(); // Bloquear el cursor
            
            // Iniciar listeners de Firebase para ESE mundo
            initFirebaseWorldListeners();
        }
        
        // NUEVO: Cargar/crear inventario
        async function loadInventory() {
            const invRef = ref(db, `worlds/${worldName}/inventories/${userId}`);
            
            // Escuchar cambios en el inventario
            inventoryListener = onValue(invRef, (snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    // Asegurarse de que el inventario tenga 9 slots
                    if (Array.isArray(data) && data.length === 9) {
                        inventory = data;
                    } else {
                        // Datos corruptos, crear uno nuevo
                        createEmptyInventory(invRef);
                    }
                } else {
                    // No existe inventario, crear uno vacío
                    createEmptyInventory(invRef);
                }
                // Actualizar la UI de la hotbar con los datos cargados/nuevos
                updateHotbarInventoryUI();
            });
        }
        
        // NUEVO: Función helper para crear y guardar un inventario vacío
        function createEmptyInventory(invRef) {
             inventory = [];
             for (let i = 0; i < 9; i++) {
                 inventory.push({ type: null, quantity: 0 });
             }
             set(invRef, inventory); // Guardar el inventario vacío
        }
        
        // NUEVO: Guardar inventario en Firebase
        async function saveInventory() {
            if (!db || !worldName || !userId) return;
            const invRef = ref(db, `worlds/${worldName}/inventories/${userId}`);
            // No usamos await para no bloquear el juego
            set(invRef, inventory);
        }

        
        // --- CAMBIO: Función para escuchar cambios de Firebase (RTDB) ---
        function initFirebaseWorldListeners() {
            
            // --- 1. Listener para Jugadores (RTDB) ---
            const playersRef = ref(db, `worlds/${worldName}/players`);
            playersListener = onValue(playersRef, (snapshot) => {
                const activePlayers = new Set();
                
                if (!snapshot.exists()) return; // Salir si no hay jugadores

                snapshot.forEach(childSnapshot => {
                    const data = childSnapshot.val();
                    const playerId = childSnapshot.key;
                    
                    if (playerId === userId) return; // Somos nosotros
                    
                    activePlayers.add(playerId);
                    
                    const now = Date.now();
                    if (data.timestamp && (now - data.timestamp > 10000)) {
                        return; // Ignorar jugador desconectado
                    }

                    let player = players.get(playerId);
                    if (!player) {
                        // NUEVO: Crear Mesh
                        const playerMesh = new THREE.Mesh(playerMeshGeometry, playerMeshMaterial);
                        
                        // NUEVO: Crear Label (Etiqueta de nombre)
                        const labelDiv = document.createElement('div');
                        labelDiv.className = 'player-label';
                        labelDiv.textContent = data.username || 'Jugador'; // Usar el nombre de Firebase
                        
                        const playerLabel = new CSS2DObject(labelDiv);
                        playerLabel.position.set(0, playerHeight / 2 + 0.5, 0); // Posicionar encima de la cabeza
                        playerMesh.add(playerLabel); // Añadir etiqueta al mesh
                        
                        scene.add(playerMesh);
                        player = { mesh: playerMesh, label: playerLabel };
                        players.set(playerId, player);
                    }
                    
                    player.mesh.position.set(data.x, data.y - (playerHeight / 2), data.z);
                });
                
                // Limpiar jugadores que ya no están
                for (const [playerId, player] of players.entries()) {
                    if (!activePlayers.has(playerId)) {
                        scene.remove(player.mesh);
                        player.mesh.remove(player.label); // Quitar etiqueta
                        players.delete(playerId);
                    }
                }
            });
            
            // --- 2. Listener para Bloques (RTDB) ---
            const blocksRef = ref(db, `worlds/${worldName}/blocks`);
            
            // Listener para bloques AÑADIDOS
            blocksListener.added = onChildAdded(blocksRef, (snapshot) => {
                const data = snapshot.val();
                const blockKey = `${data.x}_${data.y}_${data.z}`; // CAMBIO: Usar _
                const existingBlock = blockData.get(blockKey);

                if (!existingBlock) {
                    const material = materials[data.type];
                    if (material) {
                        addBlock(data.x, data.y, data.z, material, data.type, null, false); // false = no notificar
                    }
                }
            });
            
            // Listener para bloques ELIMINADOS
            blocksListener.removed = onChildRemoved(blocksRef, (snapshot) => {
                const data = snapshot.val();
                const blockKey = `${data.x}_${data.y}_${data.z}`; // CAMBIO: Usar _
                const existingBlock = blockData.get(blockKey);
                
                if (existingBlock) {
                    removeBlock(existingBlock, false); // false = no notificar
                }
            });
        }
        
        // --- FUNCIONES DE CHUNKS ---

        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }
        
        function getBlock(x, y, z) {
            return blockData.get(`${x}_${y}_${z}`); // CAMBIO: Usar _
        }

        // CAMBIO: Mundo revertido
        function loadChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            if (worldBlocks.has(chunkKey)) {
                return;
            }

            const chunkBlocks = [];
            const startX = chunkX * chunkSize;
            const startZ = chunkZ * chunkSize;

            for (let x = 0; x < chunkSize; x++) {
                for (let z = 0; z < chunkSize; z++) {
                    const worldX = startX + x;
                    const worldZ = startZ + z;
                    
                    const noiseVal = noise.noise2D(worldX * terrainScale, worldZ * terrainScale);
                    const height = THREE.MathUtils.mapLinear(noiseVal, -1, 1, 0, terrainHeight);
                    const y = Math.floor(height);

                    // Solo añade si Firebase no ha puesto "aire"
                    if (!getBlock(worldX, y, worldZ)) { 
                         addBlock(worldX, y, worldZ, materials.grass, 'grass', chunkBlocks, false);
                    }

                    for (let y_fill = y - 1; y_fill > y - 4 && y_fill >= 0; y_fill--) {
                         if (!getBlock(worldX, y_fill, worldZ)) {
                            addBlock(worldX, y_fill, worldZ, materials.dirt, 'dirt', chunkBlocks, false);
                         }
                    }
                    
                    // CAMBIO: Bucle de piedra revertido
                    for (let y_fill = y - 4; y_fill >= worldDepth; y_fill--) {
                         if (!getBlock(worldX, y_fill, worldZ)) {
                            addBlock(worldX, y_fill, worldZ, materials.stone, 'stone', chunkBlocks, false);
                         }
                    }
                }
            }
            worldBlocks.set(chunkKey, chunkBlocks);
        }

        function unloadChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            if (worldBlocks.has(chunkKey)) {
                const chunkBlocks = worldBlocks.get(chunkKey);
                for (const block of chunkBlocks) {
                    scene.remove(block);
                    blockData.delete(`${block.position.x}_${block.position.y}_${block.position.z}`); // CAMBIO: Usar _
                }
                worldBlocks.delete(chunkKey);
            }
        }

        // CAMBIO: addBlock ahora guarda el 'type' en userData
        function addBlock(x, y, z, material, blockType, chunkArray = null, notifyFirebase = true) {
            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            
            // NUEVO: Guardar el tipo de bloque para saber qué 'dropear'
            block.userData = { type: blockType };
            
            scene.add(block);
            
            blockData.set(`${x}_${y}_${z}`, block); // CAMBIO: Usar _
            
            if (chunkArray) {
                chunkArray.push(block);
            } else {
                const chunkX = Math.floor(x / chunkSize);
                const chunkZ = Math.floor(z / chunkSize);
                const chunkKey = getChunkKey(chunkX, chunkZ);
                
                if (worldBlocks.has(chunkKey)) {
                    worldBlocks.get(chunkKey).push(block);
                } else {
                    const newChunkBlocks = [block];
                    worldBlocks.set(chunkKey, newChunkBlocks);
                }
            }
            
            // CAMBIO: Escribir en RTDB
            if (notifyFirebase && db && worldName) {
                const blockKey = `${x}_${y}_${z}`; // CAMBIO: Usar _
                // const blockType = (material === materials.grass) ? 'grass' : (material === materials.dirt) ? 'dirt' : 'stone';
                const blockRef = ref(db, `worlds/${worldName}/blocks/${blockKey}`);
                set(blockRef, { x, y, z, type: blockType });
            }
        }

        function removeBlock(object, notifyFirebase = true) {
            const pos = object.position;
            const blockKey = `${pos.x}_${pos.y}_${pos.z}`; // CAMBIO: Usar _
            
            scene.remove(object);
            
            blockData.delete(blockKey);
            
            const chunkX = Math.floor(pos.x / chunkSize);
            const chunkZ = Math.floor(pos.z / chunkSize);
            const chunkKey = getChunkKey(chunkX, chunkZ);

            if (worldBlocks.has(chunkKey)) {
                const chunkBlocks = worldBlocks.get(chunkKey);
                const index = chunkBlocks.indexOf(object);
                if (index > -1) {
                    chunkBlocks.splice(index, 1);
                }
            }
            
            // CAMBIO: Eliminar de RTDB
            if (notifyFirebase && db && worldName) {
                const blockRef = ref(db, `worlds/${worldName}/blocks/${blockKey}`);
                remove(blockRef);
            }
        }
        
        function updatePlayerBox(position) {
            playerBox.setFromCenterAndSize(
                position,
                new THREE.Vector3(playerWidth * 2, playerHeight, playerWidth * 2)
            );
            playerBox.min.y = position.y - (playerHeight / 2);
            playerBox.max.y = position.y + (playerHeight / 2);
        }

        function checkCollision() {
            const minX = Math.floor(playerBox.min.x);
            const maxX = Math.ceil(playerBox.max.x);
            const minY = Math.floor(playerBox.min.y);
            const maxY = Math.ceil(playerBox.max.y);
            const minZ = Math.floor(playerBox.min.z);
            const maxZ = Math.ceil(playerBox.max.z);

            for (let x = minX; x < maxX; x++) {
                for (let y = minY; y < maxY; y++) {
                    for (let z = minZ; z < maxZ; z++) {
                        
                        if (getBlock(x, y, z)) { 
                            boxMin.set(x - 0.5, y - 0.5, z - 0.5);
                            boxMax.set(x + 0.5, y + 0.5, z + 0.5);
                            collisionCheckBlockBox.set(boxMin, boxMax);
                            
                            if (playerBox.intersectsBox(collisionCheckBlockBox)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }


        function updateChunks() {
            const playerPos = controls.getObject().position;
            const chunkX = Math.floor(playerPos.x / chunkSize);
            const chunkZ = Math.floor(playerPos.z / chunkSize);

            if (currentChunk.x === chunkX && currentChunk.y === chunkZ) {
                return; 
            }
            
            currentChunk.set(chunkX, chunkZ); 

            for (let x = chunkX - renderDistance; x <= chunkX + renderDistance; x++) {
                for (let z = chunkZ - renderDistance; z <= chunkZ + renderDistance; z++) {
                    loadChunk(x, z);
                }
            }

            for (const chunkKey of worldBlocks.keys()) {
                const [cx, cz] = chunkKey.split(',').map(Number);
                const dist_x = Math.abs(cx - chunkX);
                const dist_z = Math.abs(cz - chunkZ);
                
                if (dist_x > renderDistance || dist_z > renderDistance) {
                    unloadChunk(cx, cz);
                }
            }
        }


        // --- Bucle del Juego (Animación) ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            
            let delta = (time - prevTime) / 1000;
            delta = Math.min(delta, 0.05); 

            if (controls.isLocked === true) {
                
                updateChunks();

                lastPlayerVelY = playerVelocity.y;

                // Fricción
                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                // Gravedad
                playerVelocity.y += gravity * delta;
                
                // Dirección
                playerDirection.z = Number(moveForward) - Number(moveBackward);
                playerDirection.x = Number(moveRight) - Number(moveLeft);
                playerDirection.normalize(); 

                // Aplicar movimiento
                if (moveForward || moveBackward) playerVelocity.z -= playerDirection.z * moveSpeed * delta;
                if (moveLeft || moveRight) playerVelocity.x -= playerDirection.x * moveSpeed * delta;

                // Colisión por ejes
                const playerPos = controls.getObject().position;
                const deltaVelX = -playerVelocity.x * delta;
                const deltaVelZ = -playerVelocity.z * delta;
                const deltaVelY = playerVelocity.y * delta;

                controls.moveRight(deltaVelX);
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    controls.moveRight(-deltaVelX); 
                    playerVelocity.x = 0;
                }

                controls.moveForward(deltaVelZ);
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    controls.moveForward(-deltaVelZ); 
                    playerVelocity.z = 0;
                }

                playerPos.y += deltaVelY;
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    playerPos.y -= deltaVelY; 
                    if (lastPlayerVelY < 0) {
                        canJump = true; 
                        handleFallDamage(lastPlayerVelY); 
                    }
                    playerVelocity.y = 0;
                } else {
                    canJump = false;
                }
                
                // --- OPTIMIZACIÓN: Generar lista de bloques una vez por frame ---
                const allBlocks = Array.from(worldBlocks.values()).flat();
                
                // Lógica de Minería (REFACTORIZADA)
                raycaster.setFromCamera(new THREE.Vector2(), camera);
                const intersects = raycaster.intersectObjects(allBlocks);

                if (isMining) {
                    if (intersects.length > 0 && intersects[0].object.userData.type) {
                        const intersectedBlock = intersects[0].object;

                        // Si es la primera vez que se detecta el minado o se cambia de bloque
                        if (currentMiningBlock === null) {
                            // Empezar a minar este bloque
                            currentMiningBlock = intersectedBlock;
                            miningTimer = 0;
                            
                            // Crear superposición de rotura
                            if (breakingBlockOverlay) scene.remove(breakingBlockOverlay);
                            breakingBlockOverlay = new THREE.Mesh(blockGeometry, breakingMaterial.clone());
                            breakingBlockOverlay.position.copy(currentMiningBlock.position);
                            breakingBlockOverlay.renderOrder = 1; 
                            breakingBlockOverlay.material.map = destroyTextures[0];
                            scene.add(breakingBlockOverlay);

                        } 
                        // Si seguimos minando el MISMO bloque (comprobando por posición)
                        else if (currentMiningBlock && intersectedBlock.position.equals(currentMiningBlock.position)) {
                            miningTimer += delta;
                            const breakStage = Math.min(9, Math.floor((miningTimer / blockBreakTime) * 10));
                            
                            if (breakingBlockOverlay) {
                                breakingBlockOverlay.material.map = destroyTextures[breakStage];
                                breakingBlockOverlay.material.needsUpdate = true;
                            }

                            // Si se completó el tiempo
                            if (miningTimer >= blockBreakTime) {
                                // 1. Añadir al inventario
                                const blockType = currentMiningBlock.userData.type;
                                const dropType = getBlockDrop(blockType);
                                if (dropType) {
                                    addToInventory(dropType);
                                }
                                
                                // 2. Romper el bloque
                                removeBlock(currentMiningBlock, true);
                                stopMining(); // Resetear
                            }
                        }
                        // Si se movió el ratón a OTRO bloque
                        else {
                            stopMining();
                        }
                    } 
                    // Si se deja de apuntar a un bloque
                    else {
                        stopMining();
                    }
                }
                
                // Actualizar posición en Firebase (RTDB)
                if (worldName && db && userId && time - lastFirebaseUpdate > 200) { 
                    lastFirebaseUpdate = time;
                    const pos = controls.getObject().position;
                    const playerRef = ref(db, `worlds/${worldName}/players/${userId}`);
                    set(playerRef, { 
                        x: pos.x, 
                        y: pos.y, 
                        z: pos.z, 
                        timestamp: serverTimestamp(),
                        username: userName // NUEVO: Enviar nuestro nombre
                    });
                }
                
                if (playerPos.y < -50) {
                    respawnPlayer();
                }
            }
            
            prevTime = time;

            renderer.render(scene, camera);
            // NUEVO: Renderizar etiquetas 2D
            if (labelRenderer) {
                labelRenderer.render(scene, camera);
            }
        }
        
        // NUEVO: Determina qué item 'dropear'
        function getBlockDrop(blockType) {
            if (blockType === 'grass' || blockType === 'dirt') {
                return 'dirt';
            }
            if (blockType === 'stone') {
                return 'stone';
            }
            return null;
        }
        
        // NUEVO: Añadir item al inventario
        function addToInventory(itemType) {
            // 1. Intentar apilar en un slot existente
            let targetSlot = inventory.find(slot => slot.type === itemType);
            
            // 2. Si no existe, buscar un slot vacío
            if (!targetSlot) {
                // CORRECCIÓN: Buscar un slot vacío (type null) O un slot con cantidad 0
                targetSlot = inventory.find(slot => slot.type === null || slot.quantity === 0);
            }
            
            // 3. Si encontramos un slot
            if (targetSlot) {
                targetSlot.type = itemType;
                targetSlot.quantity++;
                
                // 4. Actualizar UI y guardar
                updateHotbarInventoryUI();
                saveInventory();
            } else {
                // Inventario lleno (no se hace nada por ahora)
                console.log("Inventario lleno!");
            }
        }

        
        function stopMining() {
            // CORRECCIÓN: NO cambiar isMining aquí. Solo en onMouseUp.
            // isMining = false; 
            miningTimer = 0;
            currentMiningBlock = null;
            if (breakingBlockOverlay) {
                scene.remove(breakingBlockOverlay);
                breakingBlockOverlay = null;
            }
        }

        // --- Manejadores de Eventos ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    if (canJump === true) playerVelocity.y += jumpForce;
                    canJump = false;
                    break;
                
                // Controles de Hotbar (1-9)
                case 'Digit1': selectedSlot = 0; updateHotbarActiveSlotUI(); break;
                case 'Digit2': selectedSlot = 1; updateHotbarActiveSlotUI(); break;
                case 'Digit3': selectedSlot = 2; updateHotbarActiveSlotUI(); break;
                case 'Digit4': selectedSlot = 3; updateHotbarActiveSlotUI(); break;
                case 'Digit5': selectedSlot = 4; updateHotbarActiveSlotUI(); break;
                case 'Digit6': selectedSlot = 5; updateHotbarActiveSlotUI(); break;
                case 'Digit7': selectedSlot = 6; updateHotbarActiveSlotUI(); break;
                case 'Digit8': selectedSlot = 7; updateHotbarActiveSlotUI(); break;
                case 'Digit9': selectedSlot = 8; updateHotbarActiveSlotUI(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        function onMouseDown(event) {
            if (!controls.isLocked) return; 

            // Botón Izquierdo (0): Iniciar minería
            if (event.button === 0) {
                isMining = true;
                // La lógica de raycast ahora se maneja en animate()
            } 
            
            // Botón Derecho (2): Poner bloque
            else if (event.button === 2) {
                stopMining(); // Detener minería si se estaba haciendo
                
                // CAMBIO: Lógica de inventario finito
                const selectedItem = inventory[selectedSlot];
                if (!selectedItem || selectedItem.quantity <= 0) return; 
                
                const selectedMaterial = materials[selectedItem.type];
                if (!selectedMaterial) return;
                
                // --- OPTIMIZACIÓN: Raycast solo para poner bloque ---
                raycaster.setFromCamera(new THREE.Vector2(), camera); 
                const allBlocks = Array.from(worldBlocks.values()).flat();
                const intersects = raycaster.intersectObjects(allBlocks);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const newBlockPos = intersect.object.position.clone().add(intersect.face.normal);
                    newBlockPos.round();
                    
                    const newBlockBox = new THREE.Box3(
                        newBlockPos.clone().subScalar(0.5),
                        newBlockPos.clone().addScalar(0.5)
                    );

                    if (!playerBox.intersectsBox(newBlockBox)) {
                        // Añadir bloque al mundo
                        // CORRECCIÓN DE BUG: Argumentos pasados incorrectamente. 
                        // 6to arg era 'true' (para notifyFirebase), pero se esperaba 'chunkArray'.
                        // Ahora pasamos 'null' para chunkArray y 'true' para notifyFirebase.
                        addBlock(newBlockPos.x, newBlockPos.y, newBlockPos.z, selectedMaterial, selectedItem.type, null, true);
                        
                        // Restar del inventario
                        selectedItem.quantity--;
                        if (selectedItem.quantity === 0) {
                            selectedItem.type = null; // Vaciar slot
                        }
                        updateHotbarInventoryUI();
                        saveInventory();
                    }
                }
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Botón Izquierdo
                isMining = false;
                // CAMBIO: Llamar a stopMining() para limpiar la UI y el estado
                stopMining();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // NUEVO: Redimensionar el renderer de etiquetas
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Funciones de Vida y Daño ---
        
        function setupHealthBar() {
            const healthBar = document.getElementById('health-bar');
            healthBar.innerHTML = '';
            for(let i = 0; i < playerMaxHealth / 2; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                healthBar.appendChild(heart);
            }
            updateHealthUI();
        }

        function updateHealthUI() {
            const hearts = document.querySelectorAll('#health-bar .heart');
            const fullHearts = Math.floor(playerHealth / 2);
            
            hearts.forEach((heart, index) => {
                if (index < fullHearts) {
                    heart.textContent = '❤️';
                } else {
                    heart.textContent = '🖤';
                }
            });
        }
        
        function handleFallDamage(fallVelocity) {
            const damageThreshold = -15; 
            
            if (fallVelocity < damageThreshold) {
                const damage = Math.round(Math.abs(fallVelocity) - Math.abs(damageThreshold));
                takeDamage(damage);
            }
        }
        
        function takeDamage(amount) {
            playerHealth -= amount;
            if (playerHealth < 0) {
                playerHealth = 0;
            }
            
            updateHealthUI();
            
            if (playerHealth === 0) {
                respawnPlayer();
            }
        }
        
        function respawnPlayer() {
            playerHealth = playerMaxHealth;
            updateHealthUI();
            controls.getObject().position.set(0, terrainHeight + 5, 0); 
            playerVelocity.set(0, 0, 0);
        }

        
        // --- FUNCIONES DE HOTBAR 3D ---

        function setupHotbar() {
            hotbarElement = document.getElementById('hotbar');
            
            hotbarCamera = new THREE.PerspectiveCamera(75, 1.0, 0.1, 10);
            hotbarCamera.position.z = 1.3; 

            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'hotbar-canvas';
                slot.appendChild(canvas);
                
                // NUEVO: Añadir div para la cantidad
                const quantityDiv = document.createElement('div');
                quantityDiv.className = 'hotbar-quantity';
                slot.appendChild(quantityDiv);
                
                hotbarElement.appendChild(slot);
                hotbarSlots.push(slot); 

                const scene = new THREE.Scene();
                const light = new THREE.AmbientLight(0xffffff, 2.0); 
                scene.add(light);
                const pointLight = new THREE.PointLight(0xffffff, 1.0);
                pointLight.position.set(1, 2, 3);
                scene.add(pointLight);
                hotbarScenes[i] = scene;

                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true, 
                    antialias: true 
                });
                renderer.setSize(50, 50); 
                hotbarRenderers[i] = renderer;

                // CAMBIO: Crear el mesh pero ocultarlo. Se mostrará en updateHotbarInventoryUI
                const mesh = new THREE.Mesh(blockGeometry); // Material se asigna después
                mesh.rotation.x = 0.5; 
                mesh.rotation.y = -0.7;
                mesh.visible = false; // Oculto por defecto
                scene.add(mesh);
                hotbarMeshes[i] = mesh;
            }
            updateHotbarActiveSlotUI();
        }

        // Bucle de animación SÓLO para la hotbar
        function animateHotbar() {
            requestAnimationFrame(animateHotbar);
            
            for(let i = 0; i < 9; i++) {
                const renderer = hotbarRenderers[i];
                const scene = hotbarScenes[i];
                if (renderer && scene && hotbarMeshes[i] && hotbarMeshes[i].visible) { // Solo renderizar si es visible
                    renderer.render(scene, hotbarCamera);
                }
            }
        }
        
        // NUEVO: Actualiza los items 3D y las cantidades
        function updateHotbarInventoryUI() {
            if (!inventory || inventory.length === 0) return;
            
            for (let i = 0; i < 9; i++) {
                const slotData = inventory[i];
                const mesh = hotbarMeshes[i];
                const quantityElement = hotbarSlots[i].querySelector('.hotbar-quantity');

                if (slotData && slotData.type && slotData.quantity > 0) {
                    mesh.material = materials[slotData.type];
                    mesh.visible = true;
                    quantityElement.textContent = slotData.quantity;
                    quantityElement.style.display = 'block';
                } else {
                    mesh.visible = false;
                    quantityElement.style.display = 'none';
                }
            }
            // Forzar un renderizado de la hotbar
            for(let i = 0; i < 9; i++) {
                if (hotbarRenderers[i] && hotbarScenes[i]) {
                    hotbarRenderers[i].render(hotbarScenes[i], hotbarCamera);
                }
            }
        }

        // CAMBIO: Renombrada. Solo actualiza el slot activo
        function updateHotbarActiveSlotUI() {
            for (let i = 0; i < 9; i++) {
                const slot = hotbarSlots[i];
                if (i === selectedSlot) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            }
        }

        function onMouseWheel(event) {
            stopMining(); 
            
            if (event.deltaY > 0) {
                selectedSlot++;
            } else {
                selectedSlot--;
            }

            if (selectedSlot > 8) selectedSlot = 0;
            if (selectedSlot < 0) selectedSlot = 8;

            updateHotbarActiveSlotUI();
        }

        // --- Iniciar el juego ---
        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel World con Crafteo Visual</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            user-select: none; /* Evitar seleccionar texto */
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; 
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            font-size: 2em;
            z-index: 10; 
        }

        #instructions {
            width: 50%;
            cursor: pointer;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border: 2px solid white;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 10; 
        }
        
        /* --- ESTILOS DEL INVENTARIO (HOTBAR) --- */
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            z-index: 10;
        }
        
        /* --- ESTILO DE SLOT GENÉRICO (para Hotbar, Inventario, Crafteo) --- */
        .slot {
            width: 55px;
            height: 55px;
            border: 2px solid #333;
            margin: 2px;
            color: white;
            box-sizing: border-box;
            position: relative;
            background-size: cover;
            background-position: center;
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background-color: rgba(0, 0, 0, 0.2); /* Fondo de slot */
        }
        
        .slot.selected { /* Solo para la hotbar */
            border-color: white;
            box-shadow: 0 0 10px white;
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        /* --- PANTALLA DE CRAFTEO (NUEVA UI) --- */
        #crafting-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: none; /* Oculto por defecto */
            justify-content: center;
            align-items: center;
            z-index: 20;
            color: white;
        }
        
        #crafting-ui {
            background-color: rgba(10, 10, 10, 0.9);
            border: 2px solid #888;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: grid;
            
            /* --- CORRECCIÓN DE LAYOUT --- */
            grid-template-areas:
                "title"
                "crafting"
                "inventory"
                "hotbar";
            grid-gap: 10px; /* Reducir espacio */
            justify-items: center; /* Centrar todo horizontalmente */
            align-items: center;
        }

        #crafting-ui h2 {
            grid-area: title;
            text-align: center;
            margin-top: 0;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }

        /* --- Área de Crafteo (Izquierda) --- */
        #crafting-area {
            grid-area: crafting;
            display: grid;
            grid-template-areas:
                "grid_2x2 . output"
                "grid_3x3 . output";
            grid-template-columns: auto 50px auto;
            grid-template-rows: auto auto;
            align-items: center;
            justify-self: center; /* Centrar esta área */
        }

        /* Cuadrícula 2x2 (Inventario) */
        #crafting-grid-2x2 {
            grid-area: grid_2x2;
            display: grid;
            grid-template-columns: repeat(2, 59px); /* 55px + 4px margin */
            width: 118px;
        }

        /* Cuadrícula 3x3 (Mesa) */
        #crafting-grid-3x3 {
            grid-area: grid_3x3;
            display: grid;
            grid-template-columns: repeat(3, 59px);
            width: 177px;
        }
        
        /* Ocultar la cuadrícula que no se usa */
        #crafting-grid-2x2.hidden,
        #crafting-grid-3x3.hidden {
            display: none;
        }

        /* Flecha y Slot de Salida */
        #crafting-output-area {
            grid-area: output;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #crafting-output-area::before {
             content: '->';
             font-size: 30px;
             margin-bottom: 10px;
        }
        
        #output-slot {
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        #output-slot:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* --- Área de Inventario (Derecha) --- */
        #player-inventory-area {
            grid-area: inventory;
            justify-self: center; /* Centrar esta área */
        }

        #player-inventory-grid {
            display: grid;
            grid-template-columns: repeat(9, 59px);
            border: 1px solid #333;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        /* --- Hotbar en UI de Crafteo --- */
        #player-hotbar-grid {
            grid-area: hotbar;
            display: grid;
            grid-template-columns: repeat(9, 59px);
            border: 1px solid #333;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            justify-self: center; /* Centrar esta área */
        }
        
        /* --- Item en el Cursor --- */
        #cursor-item {
            position: fixed;
            pointer-events: none; /* No interceptar clics */
            z-index: 100;
            width: 55px;
            height: 55px;
            display: none; /* Oculto por defecto */
            
            /* Mismos estilos que .slot */
            background-size: cover;
            background-position: center;
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }


    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            }
        }
    </script>
</head>
<body>
    <div id="blocker">
        <!-- El texto de esto se cambiará a "Cargando..." -->
        <div id="instructions">
            <h1>Voxel World Optimizado</h1>
            <p>(W, A, S, D = Moverse, Espacio = Saltar)</p>
            <p>(Clic Izquierdo = Destruir, Clic Derecho = Construir)</p>
            <p>(Rueda del ratón o 1-9 = Cambiar bloque)</p>
            <p>(E = Abrir/Cerrar Inventario/Crafteo)</p>
            <br>
            <strong>Haz clic aquí para jugar</strong>
        </div>
    </div>
    
    <!-- --- NUEVA PANTALLA DE CRAFTEO --- -->
    <div id="crafting-screen">
        <div id="crafting-ui">
            <h2 id="crafting-title">Inventario</h2> <!-- Título dinámico -->
            
            <!-- Área de Crafteo (Izquierda) -->
            <div id="crafting-area">
                <!-- Cuadrícula 2x2 (Inventario) -->
                <div id="crafting-grid-2x2">
                    <div class="slot" data-slot-type="crafting" data-slot-index="0"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="1"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="2"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="3"></div>
                </div>
                
                <!-- Cuadrícula 3x3 (Mesa) -->
                <div id="crafting-grid-3x3" class="hidden">
                    <div class="slot" data-slot-type="crafting" data-slot-index="0"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="1"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="2"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="3"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="4"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="5"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="6"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="7"></div>
                    <div class="slot" data-slot-type="crafting" data-slot-index="8"></div>
                </div>

                <!-- Slot de Salida -->
                <div id="crafting-output-area">
                    <div class="slot" id="output-slot" data-slot-type="output"></div>
                </div>
            </div>

            <!-- Área de Inventario (Derecha) -->
            <div id="player-inventory-area">
                <!-- --- CORRECCIÓN: h3 eliminado --- -->
                <div id="player-inventory-grid">
                    <!-- 27 slots de inventario (JS los generará) -->
                </div>
            </div>
            
            <!-- Hotbar (Abajo) -->
            <div id="player-hotbar-grid">
                 <!-- 9 slots de hotbar (JS los generará) -->
            </div>

        </div>
    </div>
    
    <!-- Item que sigue al cursor -->
    <div id="cursor-item">
        <span class="slot-count"></span>
    </div>
    
    <div id="crosshair"></div>
    <canvas id="game-canvas"></canvas>
    
    <!-- --- HTML DEL INVENTARIO (HOTBAR) --- -->
    <div id="hotbar">
        <!-- 9 slots (JS los generará) -->
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <!-- Para combinar geometrías: Three.js BufferGeometryUtils -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script> 

    <script>
        /* SimplexNoise (sin cambios) */
        function SimplexNoise(random) {
            // ... (código de SimplexNoise sin cambios)
            if (!random) random = Math.random;
            this.p = new Uint8Array(256);
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            for (var i = 0; i < 256; i++) {
                this.p[i] = random() * 256;
            }
            for (i = 0; i < 512; i++) {
                this.perm[i] = this.p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
        SimplexNoise.prototype = {
            grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
            noise2D: function(xin, yin) {
                var permMod12 = this.permMod12, perm = this.perm, grad3 = this.grad3;
                var n0 = 0, n1 = 0, n2 = 0;
                var s = (xin + yin) * 0.3660254037844386;
                var i = Math.floor(xin + s);
                var j = Math.floor(yin + s);
                var t = (i + j) * 0.21132486540518713;
                var X0 = i - t;
                var Y0 = j - t;
                var x0 = xin - X0;
                var y0 = yin - Y0;
                var i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
                var x1 = x0 - i1 + 0.21132486540518713;
                var y1 = y0 - j1 + 0.21132486540518713;
                var x2 = x0 - 1.0 + 0.42264973081037425;
                var y2 = y0 - 1.0 + 0.42264973081037425;
                var ii = i & 255;
                var jj = j & 255;
                var t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    t0 *= t0;
                    var gi0 = permMod12[ii + perm[jj]];
                    n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);
                }
                var t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    t1 *= t1;
                    var gi1 = permMod12[ii + i1 + perm[jj + j1]];
                    n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
                }
                var t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    t2 *= t2;
                    var gi2 = permMod12[ii + 1 + perm[jj + 1]];
                    n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
                }
                return 70.0 * (n0 + n1 + n2);
            }
        };
        // --- FIN SimplexNoise ---


        // --- Variables Globales ---
        let scene, camera, renderer, controls;
        let world; // Mundo de físicas (Cannon.js)
        let playerBody; // Cuerpo de físicas del jugador
        let noiseGenerator; // Generador de ruido
        
        const raycastResult = new CANNON.RaycastResult();
        const rayFrom = new CANNON.Vec3();
        const rayTo = new CANNON.Vec3();

        const playerMaterial = new CANNON.Material("playerMaterial");
        const worldMaterial = new CANNON.Material("worldMaterial");

        const GROUP_PLAYER = 1;
        const GROUP_WORLD = 2;

        let chunks = {}; 
        const CHUNK_SIZE = 15; 
        const renderDistance = 1; 
        let lastChunkCheck = 0; 

        const keys = {};
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        const moveSpeed = 5;
        const jumpSpeed = 10; 
        let onGround = false; 

        // Propiedades del mundo
        const MAX_HEIGHT = 14; 
        const BASE_HEIGHT = 1; 
        const SCALE_NOISE = 0.05; 

        const WORLD_MIN_HEIGHT = -30;
        const WORLD_MAX_HEIGHT = MAX_HEIGHT + BASE_HEIGHT + 1;
        const CHUNK_HEIGHT = WORLD_MAX_HEIGHT - WORLD_MIN_HEIGHT;
        
        // --- Texturas ---
        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager); 
        const TEXTURE_URL = "https://logise1.github.io/maincraft/";
        
        const textures = {}; 
        const materials = {}; 
        
        const textureNames = [
            'grass_block_top.png', 'grass_block_side.png', 'dirt.png',
            'stone.png', 'cobblestone.png',
            'oak_log.png', 'oak_log_top.png', 'oak_leaves.png',
            'coal_ore.png', 'iron_ore.png', 'diamond_ore.png',
            'destroy_stage_0.png', 'destroy_stage_1.png', 'destroy_stage_2.png',
            'destroy_stage_3.png', 'destroy_stage_4.png', 'destroy_stage_5.png',
            'destroy_stage_6.png', 'destroy_stage_7.png', 'destroy_stage_8.png', 'destroy_stage_9.png',
            'oak_planks.png', 'stick.png',
            'wooden_pickaxe.png', 'stone_pickaxe.png',
            'crafting_table_top.png', 'crafting_table_side.png', // <-- NUEVAS
        ];
        
        // --- Variables de Rotura ---
        let breakingMaterials = [];
        let breakingDecal;
        let isBreaking = false;
        let breakingStartTime = 0;
        let currentBreakingVoxelPos = null;
        let currentBlockBreakTime = Infinity;

        // --- CONSTANTE PARA MANO ---
        const HAND = { 
            id: 0, name: 'hand', isBlock: false, 
            toolType: null, toolTier: 0, icon: null, maxStack: 1
        };

        // --- REGISTRO DE BLOQUES (Mundo) ---
        const BLOCKS = {
            EMPTY: { id: 0, name: 'empty' }, 
            GRASS: {
                id: 1, name: 'grass',
                faces: { top: 'grass_block_top.png', bottom: 'dirt.png', side: 'grass_block_side.png' },
                hardness: 0.6, minTool: null, minTier: 0, drop: 2 // Suelta DIRT
            },
            DIRT: {
                id: 2, name: 'dirt',
                faces: { top: 'dirt.png', bottom: 'dirt.png', side: 'dirt.png' },
                hardness: 0.5, minTool: null, minTier: 0, drop: 2
            },
            STONE: {
                id: 3, name: 'stone',
                faces: { top: 'stone.png', bottom: 'stone.png', side: 'stone.png' },
                hardness: 1.5, minTool: 'pickaxe', minTier: 1, drop: 4 // Suelta COBBLESTONE
            },
            COBBLESTONE: {
                id: 4, name: 'cobblestone',
                faces: { top: 'cobblestone.png', bottom: 'cobblestone.png', side: 'cobblestone.png' },
                hardness: 2.0, minTool: 'pickaxe', minTier: 1, drop: 4
            },
            OAK_LOG: {
                id: 5, name: 'oak_log',
                faces: { top: 'oak_log_top.png', bottom: 'oak_log_top.png', side: 'oak_log.png' },
                hardness: 2.0, minTool: null, minTier: 0, drop: 5
            },
            OAK_LEAVES: {
                id: 6, name: 'oak_leaves',
                faces: { top: 'oak_leaves.png', bottom: 'oak_leaves.png', side: 'oak_leaves.png' },
                hardness: 0.2, minTool: null, minTier: 0, drop: 0 // No suelta nada
            },
            COAL_ORE: {
                id: 7, name: 'coal_ore',
                faces: { top: 'coal_ore.png', bottom: 'coal_ore.png', side: 'coal_ore.png' },
                hardness: 3.0, minTool: 'pickaxe', minTier: 1, drop: 7
            },
            IRON_ORE: {
                id: 8, name: 'iron_ore',
                faces: { top: 'iron_ore.png', bottom: 'iron_ore.png', side: 'iron_ore.png' },
                hardness: 3.0, minTool: 'pickaxe', minTier: 2, drop: 8
            },
            DIAMOND_ORE: {
                id: 9, name: 'diamond_ore',
                faces: { top: 'diamond_ore.png', bottom: 'diamond_ore.png', side: 'diamond_ore.png' },
                hardness: 3.0, minTool: 'pickaxe', minTier: 3, drop: 9
            },
            OAK_PLANKS: {
                id: 10, name: 'oak_planks',
                faces: { top: 'oak_planks.png', bottom: 'oak_planks.png', side: 'oak_planks.png' },
                hardness: 2.0, minTool: null, minTier: 0, drop: 10
            },
            CRAFTING_TABLE: { // <-- NUEVO BLOQUE
                id: 12, name: 'crafting_table',
                faces: { top: 'crafting_table_top.png', bottom: 'oak_planks.png', side: 'crafting_table_side.png' },
                hardness: 2.5, minTool: null, minTier: 0, drop: 12
            }
        };
        const BLOCKS_BY_ID = Object.fromEntries(Object.values(BLOCKS).map(b => [b.id, b]));
        
        // --- REGISTRO DE ITEMS (Inventario) ---
        const ITEMS = {
            EMPTY: { id: 0, name: 'empty', isBlock: false, icon: null, maxStack: 0 },
            GRASS: { id: 1, name: 'grass', isBlock: true, icon: 'grass_block_side.png', maxStack: 64 },
            DIRT: { id: 2, name: 'dirt', isBlock: true, icon: 'dirt.png', maxStack: 64 },
            STONE: { id: 3, name: 'stone', isBlock: true, icon: 'stone.png', maxStack: 64 },
            COBBLESTONE: { id: 4, name: 'cobblestone', isBlock: true, icon: 'cobblestone.png', maxStack: 64 },
            OAK_LOG: { id: 5, name: 'oak_log', isBlock: true, icon: 'oak_log.png', maxStack: 64 },
            OAK_LEAVES: { id: 6, name: 'oak_leaves', isBlock: true, icon: 'oak_leaves.png', maxStack: 64 },
            COAL_ORE: { id: 7, name: 'coal_ore', isBlock: true, icon: 'coal_ore.png', maxStack: 64 },
            IRON_ORE: { id: 8, name: 'iron_ore', isBlock: true, icon: 'iron_ore.png', maxStack: 64 },
            DIAMOND_ORE: { id: 9, name: 'diamond_ore', isBlock: true, icon: 'diamond_ore.png', maxStack: 64 },
            OAK_PLANKS: { id: 10, name: 'oak_planks', isBlock: true, icon: 'oak_planks.png', maxStack: 64 },
            STICK: { id: 11, name: 'stick', isBlock: false, icon: 'stick.png', maxStack: 64 },
            CRAFTING_TABLE: { id: 12, name: 'crafting_table', isBlock: true, icon: 'crafting_table_top.png', maxStack: 64 }, // <-- NUEVO ITEM
            WOODEN_PICKAXE: { 
                id: 101, name: 'wooden_pickaxe', isBlock: false, icon: 'wooden_pickaxe.png',
                toolType: 'pickaxe', toolTier: 1, maxStack: 1
            },
            STONE_PICKAXE: {
                id: 102, name: 'stone_pickaxe', isBlock: false, icon: 'stone_pickaxe.png',
                toolType: 'pickaxe', toolTier: 2, maxStack: 1
            }
        };
        const ITEMS_BY_ID = Object.fromEntries(Object.values(ITEMS).map(i => [i.id, i]));
        
        // --- NUEVO: REGISTRO DE RECETAS (VISUAL) ---
        // ' ' es vacío, 'P' es Plank, 'S' es Stick, 'L' es Log, 'C' es Cobblestone
        const RECIPES = [
            // Shapeless (Shapeless se maneja comprobando 1 slot)
            { type: 'shapeless', input: [{ id: ITEMS.OAK_LOG.id, count: 1 }], output: { id: ITEMS.OAK_PLANKS.id, count: 4 } },
            
            // Shaped (2x2)
            { 
                type: 'shaped', grid: 2, 
                shape: ['P', 'P'], 
                ingredients: { 'P': ITEMS.OAK_PLANKS.id },
                output: { id: ITEMS.STICK.id, count: 4 }
            },
            {
                type: 'shaped', grid: 2,
                shape: ['PP', 'PP'],
                ingredients: { 'P': ITEMS.OAK_PLANKS.id },
                output: { id: ITEMS.CRAFTING_TABLE.id, count: 1 }
            },
            
            // Shaped (3x3)
            {
                type: 'shaped', grid: 3,
                shape: ['PPP', ' S ', ' S '],
                ingredients: { 'P': ITEMS.OAK_PLANKS.id, 'S': ITEMS.STICK.id },
                output: { id: ITEMS.WOODEN_PICKAXE.id, count: 1 }
            },
            {
                type: 'shaped', grid: 3,
                shape: ['CCC', ' S ', ' S '],
                ingredients: { 'C': ITEMS.COBBLESTONE.id, 'S': ITEMS.STICK.id },
                output: { id: ITEMS.STONE_PICKAXE.id, count: 1 }
            }
        ];

        
        // --- NUEVO: SISTEMA DE INVENTARIO POR SLOTS ---
        // 36 slots = 9 hotbar + 27 inventario
        const playerInventorySlots = new Array(36).fill(null).map(() => ({ id: 0, count: 0 }));
        
        // 9 slots para la mesa 3x3 (la 2x2 usará los 4 primeros)
        const craftingGridSlots = new Array(9).fill(null).map(() => ({ id: 0, count: 0 }));
        const outputSlot = { id: 0, count: 0 };
        const cursorItem = { id: 0, count: 0 }; // Item en el cursor
        
        let currentUI = 'none'; // 'none', 'inventory', 'table'
        let selectedHotbarSlot = 0;
        // --- FIN SISTEMA DE INVENTARIO ---

        // Elementos DOM
        let cursorItemEl;

        // --- Geometrías de caras pre-rotadas (sin cambios) ---
        const faceGeometries = {
            top: new THREE.PlaneGeometry(1, 1).rotateX(-Math.PI / 2).translate(0, 0.5, 0),
            bottom: new THREE.PlaneGeometry(1, 1).rotateX(Math.PI / 2).translate(0, -0.5, 0),
            left: new THREE.PlaneGeometry(1, 1).rotateY(-Math.PI / 2).translate(-0.5, 0, 0),
            right: new THREE.PlaneGeometry(1, 1).rotateY(Math.PI / 2).translate(0.5, 0, 0),
            front: new THREE.PlaneGeometry(1, 1).translate(0, 0, 0.5),
            back: new THREE.PlaneGeometry(1, 1).rotateY(Math.PI).translate(0, 0, -0.5)
        };
        

        // --- Utilidades para voxels y chunks (sin cambios) ---
        function getChunkKey(x, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE) * CHUNK_SIZE;
            const chunkZ = Math.floor(z / CHUNK_SIZE) * CHUNK_SIZE;
            return `${chunkX},${chunkZ}`;
        }
        function getChunk(x, z) { return chunks[getChunkKey(x, z)]; }
        function getVoxelIndex(localX, localY, localZ) {
             const arrayY = localY - WORLD_MIN_HEIGHT;
             return localX + localZ * CHUNK_SIZE + arrayY * CHUNK_SIZE * CHUNK_SIZE;
        }
        function getVoxel(worldX, worldY, worldZ) {
            const chunk = getChunk(worldX, worldZ); 
            if (!chunk) return BLOCKS.EMPTY;
            const localX = (worldX % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (worldZ % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            if (worldY < WORLD_MIN_HEIGHT || worldY >= WORLD_MAX_HEIGHT) return BLOCKS.EMPTY;
            const index = getVoxelIndex(localX, worldY, localZ);
            if (index < 0 || index >= chunk.voxelData.length) return BLOCKS.EMPTY;
            const id = chunk.voxelData[index];
            return BLOCKS_BY_ID[id] || BLOCKS.EMPTY;
        }
        function setVoxel(worldX, worldY, worldZ, block) {
            const chunk = getChunk(worldX, worldZ);
            if (!chunk) return;
            const localX = (worldX % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (worldZ % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            if (worldY < WORLD_MIN_HEIGHT || worldY >= WORLD_MAX_HEIGHT) return;
            const index = getVoxelIndex(localX, worldY, localZ);
            if (index >= 0 && index < chunk.voxelData.length) {
                chunk.voxelData[index] = block.id;
            }
        }
        
        // --- Carga de Texturas (sin cambios) ---
        function loadTextures() {
            const instructions = document.getElementById('instructions');
            instructions.textContent = 'Cargando texturas...';
            textureLoader.setPath(TEXTURE_URL);
            
            for (const name of textureNames) {
                if (!name) continue;
                const texture = textureLoader.load(name, () => {}, undefined, () => {
                    console.error(`Error al cargar la textura: ${name}`);
                });
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                textures[name] = texture;
                
                if (name.startsWith('destroy_stage_')) {
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, transparent: true, alphaTest: 0.01, side: THREE.DoubleSide
                    });
                    breakingMaterials.push(material);
                } else {
                    const materialOptions = {
                        map: texture,
                        transparent: name.includes('leaves'),
                        alphaTest: name.includes('leaves') ? 0.1 : 0,
                        side: name.includes('leaves') ? THREE.DoubleSide : THREE.FrontSide
                    };
                    if (name === 'grass_block_top.png' || name === 'oak_leaves.png') {
                        materialOptions.color = new THREE.Color(0x416728); 
                    } else {
                        materialOptions.color = new THREE.Color(0xffffff); 
                    }
                    materials[name] = new THREE.MeshStandardMaterial(materialOptions);
                }
            }
        }
        
        // --- El juego empieza aquí ---
        loadingManager.onLoad = () => {
            const instructions = document.getElementById('instructions');
            instructions.innerHTML = `
                <h1>Voxel World con Crafteo</h1>
                <p>(W, A, S, D = Moverse, Espacio = Saltar)</p>
                <p>(Clic Izquierdo = Destruir, Clic Derecho = Construir)</p>
                <p>(Rueda del ratón o 1-9 = Cambiar bloque)</p>
                <p>(E = Abrir/Cerrar Inventario)</p>
                <br>
                <strong>Haz clic aquí para jugar</strong>
            `;
            init();
        };

        // --- Inicialización (MODIFICADO) ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            noiseGenerator = new SimplexNoise();

            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true; 
            world.solver.iterations = 10; 
            
            const playerWorldContactMaterial = new CANNON.ContactMaterial(
                worldMaterial, playerMaterial,
                { friction: 0, restitution: 0, contactEquationStiffness: 1e8, contactEquationRelaxation: 3 }
            );
            world.addContactMaterial(playerWorldContactMaterial);
            
            const playerShape = new CANNON.Sphere(0.5); // Esfera

            playerBody = new CANNON.Body({ 
                mass: 5, shape: playerShape, 
                position: new CANNON.Vec3(0, MAX_HEIGHT + BASE_HEIGHT + 5, 0), 
                material: playerMaterial,
                collisionFilterGroup: GROUP_PLAYER, 
                collisionFilterMask: GROUP_WORLD    
            });
            playerBody.fixedRotation = true;
            world.addBody(playerBody);

            controls = new THREE.PointerLockControls(camera, document.body);
            const blocker = document.getElementById('blocker');
            const crosshair = document.getElementById('crosshair');
            const craftingScreen = document.getElementById('crafting-screen');

            blocker.addEventListener('click', () => { controls.lock(); });

            controls.addEventListener('lock', () => {
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
                if (currentUI !== 'none') {
                    closeCraftingUI();
                }
            });

            controls.addEventListener('unlock', () => {
                if (currentUI === 'none') {
                    blocker.style.display = 'flex';
                }
                crosshair.style.display = 'none';
            });

            scene.add(controls.getObject());

            // --- INICIALIZAR DECAL DE ROTURA ---
            const decalGeo = new THREE.PlaneGeometry(1.01, 1.01);
            breakingDecal = new THREE.Mesh(decalGeo, breakingMaterials[0]);
            breakingDecal.visible = false;
            scene.add(breakingDecal);
            
            // --- NUEVO: Inicializar UI de Crafteo ---
            cursorItemEl = document.getElementById('cursor-item');
            initCraftingUI();
            
            // --- Pruebas: Dar items iniciales ---
            // addItemToInventory({ id: ITEMS.OAK_LOG.id, count: 64 });
            // addItemToInventory({ id: ITEMS.COBBLESTONE.id, count: 64 });
            
            updateVisibleChunks(); 
            
            // --- MANEJADORES DE EVENTOS (MODIFICADO) ---
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                if (e.code === 'KeyE' || (e.code === 'Escape' && currentUI !== 'none')) {
                    e.preventDefault();
                    toggleCraftingUI();
                    return;
                }
                
                if (controls.isLocked) { 
                    if (e.code.startsWith('Digit')) {
                        const slotIndex = parseInt(e.code.replace('Digit', ''), 10) - 1;
                        if (slotIndex >= 0 && slotIndex < 9) {
                            selectedHotbarSlot = slotIndex;
                            updateHotbarUI(); // Solo refrescar hotbar
                        }
                    }
                }
            });
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            
            document.addEventListener('wheel', (e) => {
                if (!controls.isLocked) return; 
                if (e.deltaY < 0) { selectedHotbarSlot--; } else { selectedHotbarSlot++; }
                selectedHotbarSlot = (selectedHotbarSlot + 9) % 9; 
                updateHotbarUI();
            });

            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            // Mover item con cursor
            document.addEventListener('mousemove', (e) => {
                if (currentUI !== 'none') {
                    cursorItemEl.style.left = `${e.clientX - 27}px`;
                    cursorItemEl.style.top = `${e.clientY - 27}px`;
                }
            });

            updateHotbarUI(); 
            animate();
        }

        // --- NUEVAS FUNCIONES DE UI Y LÓGICA DE INVENTARIO ---
        
        // Genera los slots en el HTML
        function initCraftingUI() {
            const hotbarGameEl = document.getElementById('hotbar');
            const hotbarUIEl = document.getElementById('player-hotbar-grid');
            const inventoryUIEl = document.getElementById('player-inventory-grid');
            
            // Generar Hotbar (en juego)
            for (let i = 0; i < 9; i++) {
                const slotEl = document.createElement('div');
                slotEl.className = 'slot';
                slotEl.id = `hotbar-slot-${i}`;
                hotbarGameEl.appendChild(slotEl);
            }
            
            // Generar Hotbar (en UI)
            for (let i = 0; i < 9; i++) {
                const slotEl = document.createElement('div');
                slotEl.className = 'slot';
                slotEl.dataset.slotType = 'inventory';
                slotEl.dataset.slotIndex = i; // 0-8
                hotbarUIEl.appendChild(slotEl);
            }
            
            // Generar Inventario (en UI)
            for (let i = 9; i < 36; i++) {
                const slotEl = document.createElement('div');
                slotEl.className = 'slot';
                slotEl.dataset.slotType = 'inventory';
                slotEl.dataset.slotIndex = i; // 9-35
                inventoryUIEl.appendChild(slotEl);
            }
            
            // Listeners de Clics en todos los slots
            document.getElementById('crafting-screen').addEventListener('mousedown', (e) => {
                const slotEl = e.target.closest('.slot');
                if (!slotEl) return;
                
                e.preventDefault(); // Evitar selección de texto
                
                const slotType = slotEl.dataset.slotType;
                const slotIndex = parseInt(slotEl.dataset.slotIndex, 10);
                
                handleSlotClick(e, slotType, slotIndex);
            });
        }
        
        // Refresca un slot individual (o todos)
        function renderSlot(slotEl, item) {
            if (!slotEl) return;
            
            const countEl = slotEl.querySelector('.slot-count') || document.createElement('span');
            countEl.className = 'slot-count';
            
            if (!item || item.id === 0) {
                slotEl.style.backgroundImage = 'none';
                countEl.textContent = '';
                if (countEl.parentElement) slotEl.removeChild(countEl);
            } else {
                const itemData = ITEMS_BY_ID[item.id];
                const textureName = itemData.icon;
                slotEl.style.backgroundImage = textureName ? `url(${TEXTURE_URL}${textureName})` : 'none';
                
                if (item.count > 1) {
                    countEl.textContent = item.count;
                    slotEl.appendChild(countEl);
                } else {
                    countEl.textContent = '';
                    if (countEl.parentElement) slotEl.removeChild(countEl);
                }
            }
        }
        
        // Refresca el item en el cursor
        function renderCursorItem() {
            if (cursorItem.id === 0) {
                cursorItemEl.style.display = 'none';
            } else {
                cursorItemEl.style.display = 'block';
                const itemData = ITEMS_BY_ID[cursorItem.id];
                const textureName = itemData.icon;
                cursorItemEl.style.backgroundImage = textureName ? `url(${TEXTURE_URL}${textureName})` : 'none';
                
                const countEl = cursorItemEl.querySelector('.slot-count');
                countEl.textContent = cursorItem.count > 1 ? cursorItem.count : '';
            }
        }
        
        // Refresca la hotbar del juego
        function updateHotbarUI() {
            for (let i = 0; i < 9; i++) {
                const slotEl = document.getElementById(`hotbar-slot-${i}`);
                const item = playerInventorySlots[i];
                renderSlot(slotEl, item);
                
                if (i === selectedHotbarSlot) {
                    slotEl.classList.add('selected');
                } else {
                    slotEl.classList.remove('selected');
                }
            }
        }
        
        // Refresca toda la UI de crafteo (slots de inv, crafteo y salida)
        function renderCraftingUI() {
            // Inventario (9-35)
            for (let i = 9; i < 36; i++) {
                const slotEl = document.querySelector(`#player-inventory-grid .slot[data-slot-index="${i}"]`);
                renderSlot(slotEl, playerInventorySlots[i]);
            }
            // Hotbar (0-8)
            for (let i = 0; i < 9; i++) {
                const slotEl = document.querySelector(`#player-hotbar-grid .slot[data-slot-index="${i}"]`);
                renderSlot(slotEl, playerInventorySlots[i]);
            }
            // Crafting (0-8)
            for (let i = 0; i < 9; i++) {
                const slotEl = document.querySelector(`.slot[data-slot-type="crafting"][data-slot-index="${i}"]`);
                renderSlot(slotEl, craftingGridSlots[i]);
            }
            // Salida
            renderSlot(document.getElementById('output-slot'), outputSlot);
        }

        // Abrir/Cerrar UI
        function toggleCraftingUI() {
            const craftingScreen = document.getElementById('crafting-screen');
            if (controls.isLocked) {
                // Abrir Inventario (2x2)
                currentUI = 'inventory';
                document.getElementById('crafting-title').textContent = 'Inventario';
                document.getElementById('crafting-grid-2x2').classList.remove('hidden');
                document.getElementById('crafting-grid-3x3').classList.add('hidden');
                craftingScreen.style.display = 'flex';
                renderCraftingUI();
                controls.unlock();
            } else {
                // Cerrar cualquier UI
                closeCraftingUI();
                controls.lock();
            }
        }
        
        function openCraftingTableUI() {
            currentUI = 'table';
            document.getElementById('crafting-title').textContent = 'Mesa de Crafteo';
            document.getElementById('crafting-grid-2x2').classList.add('hidden');
            document.getElementById('crafting-grid-3x3').classList.remove('hidden');
            document.getElementById('crafting-screen').style.display = 'flex';
            renderCraftingUI();
            controls.unlock();
        }
        
        function closeCraftingUI() {
            // Devolver items al inventario
            if (cursorItem.id > 0) {
                addItemToInventory(cursorItem);
                cursorItem.id = 0;
                cursorItem.count = 0;
            }
            for (let i = 0; i < 9; i++) {
                if (craftingGridSlots[i].id > 0) {
                    addItemToInventory(craftingGridSlots[i]);
                    craftingGridSlots[i] = { id: 0, count: 0 };
                }
            }
            // Limpiar output (no devolver)
            outputSlot.id = 0;
            outputSlot.count = 0;
            
            document.getElementById('crafting-screen').style.display = 'none';
            currentUI = 'none';
            renderCursorItem(); // Ocultar cursor
            updateHotbarUI(); // Sincronizar hotbar
        }
        
        // Añade un item al inventario (busca stacks o slots vacíos)
        function addItemToInventory(item) {
            const itemData = ITEMS_BY_ID[item.id];
            
            // 1. Intentar apilar
            if (itemData.maxStack > 1) {
                for (let i = 0; i < 36; i++) {
                    const slot = playerInventorySlots[i];
                    if (slot.id === item.id && slot.count < itemData.maxStack) {
                        const canAdd = itemData.maxStack - slot.count;
                        const toAdd = Math.min(item.count, canAdd);
                        slot.count += toAdd;
                        item.count -= toAdd;
                        if (item.count === 0) return true; // Añadido todo
                    }
                }
            }
            
            // 2. Buscar slot vacío
            for (let i = 0; i < 36; i++) {
                const slot = playerInventorySlots[i];
                if (slot.id === 0) {
                    slot.id = item.id;
                    slot.count = item.count;
                    return true; // Añadido
                }
            }
            
            return false; // Inventario lleno
        }

        // --- LÓGICA DE CLIC EN SLOTS ---
        function handleSlotClick(event, slotType, slotIndex) {
            const isLeftClick = event.button === 0;
            const isRightClick = event.button === 2;
            
            let slot = null;
            
            if (slotType === 'inventory') {
                slot = playerInventorySlots[slotIndex];
            } else if (slotType === 'crafting') {
                slot = craftingGridSlots[slotIndex];
            } else if (slotType === 'output') {
                handleOutputClick(isLeftClick);
                return;
            }
            
            if (!slot) return;
            
            const cursorId = cursorItem.id;
            const slotId = slot.id;
            const cursorCount = cursorItem.count;
            const slotCount = slot.count;
            
            if (isLeftClick) {
                if (cursorId === 0) {
                    // Coger: Clic en slot lleno con cursor vacío
                    if (slotId !== 0) {
                        cursorItem.id = slotId;
                        cursorItem.count = slotCount;
                        slot.id = 0;
                        slot.count = 0;
                    }
                } else {
                    // Dejar: Clic con cursor lleno
                    if (slotId === 0) {
                        // Dejar en slot vacío
                        slot.id = cursorId;
                        slot.count = cursorCount;
                        cursorItem.id = 0;
                        cursorItem.count = 0;
                    } else if (slotId === cursorId) {
                        // Apilar
                        const itemData = ITEMS_BY_ID[slotId];
                        const canAdd = itemData.maxStack - slotCount;
                        const toAdd = Math.min(cursorCount, canAdd);
                        slot.count += toAdd;
                        cursorItem.count -= toAdd;
                        if (cursorItem.count === 0) cursorItem.id = 0;
                    } else {
                        // Intercambiar
                        cursorItem.id = slotId;
                        cursorItem.count = slotCount;
                        slot.id = cursorId;
                        slot.count = cursorCount;
                    }
                }
            } else if (isRightClick) {
                if (cursorId === 0) {
                    // Coger mitad: Clic en slot lleno con cursor vacío
                    if (slotId !== 0) {
                        const takeCount = Math.ceil(slotCount / 2);
                        cursorItem.id = slotId;
                        cursorItem.count = takeCount;
                        slot.count -= takeCount;
                        if (slot.count === 0) slot.id = 0;
                    }
                } else {
                    // Dejar 1: Clic con cursor lleno
                    if (slotId === 0) {
                        // Dejar 1 en slot vacío
                        slot.id = cursorId;
                        slot.count = 1;
                        cursorItem.count--;
                        if (cursorItem.count === 0) cursorItem.id = 0;
                    } else if (slotId === cursorId) {
                        // Apilar 1
                        const itemData = ITEMS_BY_ID[slotId];
                        if (slotCount < itemData.maxStack) {
                            slot.count++;
                            cursorItem.count--;
                            if (cursorItem.count === 0) cursorItem.id = 0;
                        }
                    }
                    // (No intercambiar con clic derecho)
                }
            }
            
            // Refrescar UI
            renderCursorItem();
            renderCraftingUI();
            
            // Comprobar crafteo si se tocó la cuadrícula
            if (slotType === 'crafting') {
                checkCrafting();
            }
        }
        
        function handleOutputClick(isLeftClick) {
            if (outputSlot.id === 0) return; // Salida vacía
            
            if (cursorItem.id === 0) {
                // Coger item
                cursorItem.id = outputSlot.id;
                cursorItem.count = outputSlot.count;
            } else if (cursorItem.id === outputSlot.id) {
                // Apilar item
                const itemData = ITEMS_BY_ID[outputSlot.id];
                const canAdd = itemData.maxStack - cursorItem.count;
                if (canAdd >= outputSlot.count) {
                    cursorItem.count += outputSlot.count;
                } else {
                    return; // No hay espacio en el cursor
                }
            } else {
                return; // Cursor lleno con otro item
            }
            
            // Consumir ingredientes
            for (let i = 0; i < 9; i++) {
                const slot = craftingGridSlots[i];
                if (slot.id > 0) {
                    slot.count--;
                    if (slot.count === 0) slot.id = 0;
                }
            }
            
            // Refrescar
            checkCrafting(); // Comprobar si se puede craftear más
            renderCursorItem();
            renderCraftingUI();
        }

        // --- LÓGICA DE RECETAS (CORREGIDA) ---
        function checkCrafting() {
            const gridType = (currentUI === 'table') ? 3 : 2;
            let foundRecipe = null;
            
            // 1. Comprobar recetas sin forma (shapeless)
            const itemsInGrid = [];
            for (let i = 0; i < 9; i++) {
                // Solo comprobar los slots relevantes para la cuadrícula actual
                if (gridType === 2 && i >= 4) continue;
                if (craftingGridSlots[i].id > 0) {
                    itemsInGrid.push(craftingGridSlots[i]);
                }
            }
            
            if (itemsInGrid.length === 1) {
                const item = itemsInGrid[0];
                foundRecipe = RECIPES.find(r => 
                    r.type === 'shapeless' &&
                    r.input.length === 1 &&
                    r.input[0].id === item.id &&
                    item.count >= r.input[0].count
                );
            }
            
            // 2. Comprobar recetas con forma (shaped)
            if (!foundRecipe) {
                const ingredientsMap = {}; // {'A': 10, 'B': 11}
                let minX = gridType, maxX = -1, minY = gridType, maxY = -1;
                
                for(let y = 0; y < gridType; y++) {
                    for(let x = 0; x < gridType; x++) {
                        const i = y * gridType + x;
                        const item = craftingGridSlots[i];
                        if (item.id > 0) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                if (maxX >= minX) { // Si hay algo en la cuadrícula
                    let shapeString = '';
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            const i = y * gridType + x;
                            const item = craftingGridSlots[i];
                            
                            let char = ' ';
                            if (item.id > 0) {
                                let foundChar = Object.keys(ingredientsMap).find(k => ingredientsMap[k] === item.id);
                                if (!foundChar) {
                                    foundChar = String.fromCharCode(65 + Object.keys(ingredientsMap).length); // A, B, C...
                                    ingredientsMap[foundChar] = item.id;
                                }
                                char = foundChar;
                            }
                            shapeString += char;
                        }
                        if (y < maxY) shapeString += '/'; // Separador de fila
                    }
                    
                    // Buscar la receta que coincida
                    foundRecipe = RECIPES.find(r => {
                        if (r.type !== 'shaped' || r.grid !== gridType) return false;
                        
                        const recipeShapeString = r.shape.join('/');
                        
                        // --- INICIO DE LA CORRECCIÓN ---
                        
                        // 1. Crear un mapa de {ID_ITEM -> Char_Receta} ej: {10: 'P', 11: 'S'}
                        const recipeIdToChar = {};
                        for (const char in r.ingredients) {
                            recipeIdToChar[r.ingredients[char]] = char;
                        }

                        // 2. Crear un "mapa traducido" de {Char_Usuario -> Char_Receta} ej: {'A': 'P', 'B': 'S'}
                        const userCharToRecipeChar = {};
                        let validMap = true;
                        for (const userChar in ingredientsMap) {
                            const userId = ingredientsMap[userChar];
                            const recipeChar = recipeIdToChar[userId];
                            if (!recipeChar) {
                                validMap = false; // El item del usuario no está en la receta
                                break;
                            }
                            userCharToRecipeChar[userChar] = recipeChar;
                        }
                        
                        // 3. Comprobar que todos los ingredientes de la receta estén presentes
                        if (Object.keys(r.ingredients).length !== Object.keys(ingredientsMap).length) {
                             validMap = false;
                        }

                        if (!validMap) return false;

                        // 4. Traducir el shapeString del usuario (ej: "AA/AA") al shapeString de la receta (ej: "PP/PP")
                        const translatedShapeString = shapeString.split('')
                            .map(char => userCharToRecipeChar[char] || char) // Traduce A->P, / -> /
                            .join('');
                        
                        // 5. Comparar
                        return recipeShapeString === translatedShapeString;
                        // --- FIN DE LA CORRECCIÓN ---
                    });
                }
            } // Fin shaped
            
            // 3. Actualizar slot de salida
            if (foundRecipe) {
                outputSlot.id = foundRecipe.output.id;
                outputSlot.count = foundRecipe.output.count;
            } else {
                outputSlot.id = 0;
                outputSlot.count = 0;
            }
            renderSlot(document.getElementById('output-slot'), outputSlot);
        }

        // --- FIN LÓGICA DE INVENTARIO ---

        // --- Generación de Chunks (sin cambios) ---
        function initializeChunk(x, z) {
            const key = `${x},${z}`;
            if (chunks[key]) return chunks[key]; 
            const chunk = {
                x: x, z: z,
                voxelData: new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT).fill(BLOCKS.EMPTY.id), 
                meshes: [], body: null, isGenerated: false 
            };
            chunks[key] = chunk;
            return chunk;
        }

        function generateChunkData(chunk) {
            if (chunk.isGenerated) return; 
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = chunk.x + x;
                    const worldZ = chunk.z + z;
                    let noiseVal = noiseGenerator.noise2D(worldX * SCALE_NOISE, worldZ * SCALE_NOISE);
                    noiseVal = (noiseVal + 1) / 2; 
                    noiseVal = Math.pow(noiseVal, 2.2); 
                    const height = Math.floor(noiseVal * MAX_HEIGHT) + BASE_HEIGHT;
                    for (let y = 0; y <= height; y++) {
                        let block = BLOCKS.GRASS;
                        if (y < height) block = BLOCKS.DIRT;
                        if (y < height - 3) block = BLOCKS.STONE;
                        setVoxel(worldX, y, worldZ, block);
                    }
                    const stoneStartHeight = height - 3; 
                    for (let y = stoneStartHeight; y >= WORLD_MIN_HEIGHT; y--) {
                        const currentBlock = getVoxel(worldX, y, worldZ);
                        if (currentBlock === BLOCKS.STONE || currentBlock === BLOCKS.EMPTY) { 
                            let block = BLOCKS.STONE;
                            const rand = Math.random();
                            if (y < (WORLD_MIN_HEIGHT + 15) && rand < 0.03) block = BLOCKS.DIAMOND_ORE;
                            else if (y < 0 && rand < 0.08) block = BLOCKS.IRON_ORE;
                            else if (rand < 0.15) block = BLOCKS.COAL_ORE;
                            setVoxel(worldX, y, worldZ, block);
                        }
                    }
                    if (getVoxel(worldX, height, worldZ) === BLOCKS.GRASS && Math.random() < 0.05) {
                        const treeHeight = 4 + Math.floor(Math.random() * 2);
                        for(let i = 1; i <= treeHeight; i++) setVoxel(worldX, height + i, worldZ, BLOCKS.OAK_LOG);
                        for(let hx = -2; hx <= 2; hx++) {
                            for(let hy = -1; hy <= 2; hy++) {
                                for(let hz = -2; hz <= 2; hz++) {
                                    if (hx === 0 && hz === 0 && hy <= 0) continue; 
                                    const y = height + treeHeight + hy;
                                    if (hy > 0 && (Math.abs(hx) > 1 || Math.abs(hz) > 1)) continue;
                                    if(getVoxel(worldX + hx, y, worldZ + hz) === BLOCKS.EMPTY) {
                                        setVoxel(worldX + hx, y, worldZ + hz, BLOCKS.OAK_LEAVES);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            chunk.isGenerated = true;
        }


        // --- Construcción de Malla y Físicas (Trimesh, sin cambios) ---
        function buildChunkMeshAndPhysics(chunk) {
            chunk.meshes.forEach(m => {
                scene.remove(m);
                m.geometry.dispose();
            });
            chunk.meshes = [];
            if (chunk.body) {
                world.removeBody(chunk.body);
                chunk.body = null;
            }
            const geometriesByTexture = {};
            const physicsFaces = []; 
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let y = WORLD_MIN_HEIGHT; y < WORLD_MAX_HEIGHT; y++) {
                        const worldX = x + chunk.x;
                        const worldY = y;
                        const worldZ = z + chunk.z;
                        const block = getVoxel(worldX, worldY, worldZ);
                        if (block === BLOCKS.EMPTY) continue;
                        const neighbors = {
                            top: getVoxel(worldX, worldY + 1, worldZ), bottom: getVoxel(worldX, worldY - 1, worldZ),
                            left: getVoxel(worldX - 1, worldY, worldZ), right: getVoxel(worldX + 1, worldY, worldZ),
                            front: getVoxel(worldX, worldY, worldZ + 1), back: getVoxel(worldX, worldY, worldZ - 1)
                        };
                        for (const [faceName, neighbor] of Object.entries(neighbors)) {
                            const neighborIsTransparent = neighbor !== BLOCKS.EMPTY && neighbor.name.includes('leaves');
                            const thisIsTransparent = block.name.includes('leaves');
                            if (neighbor === BLOCKS.EMPTY || (neighborIsTransparent && !thisIsTransparent)) {
                                let textureName = (faceName === 'top' || faceName === 'bottom') ? block.faces[faceName] : block.faces.side;
                                if (!geometriesByTexture[textureName]) geometriesByTexture[textureName] = [];
                                const faceGeo = faceGeometries[faceName].clone().translate(worldX, worldY, worldZ);
                                geometriesByTexture[textureName].push(faceGeo);
                                if (block !== BLOCKS.OAK_LEAVES) { 
                                    const physicsFaceGeo = faceGeometries[faceName].clone().translate(worldX, worldY, worldZ);
                                    physicsFaces.push(physicsFaceGeo);
                                }
                            }
                        }
                    }
                }
            }
            for (const textureName in geometriesByTexture) {
                if (geometriesByTexture[textureName].length === 0) continue;
                const mergedGeo = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesByTexture[textureName]);
                if (!mergedGeo) continue; 
                const material = materials[textureName]; 
                const mesh = new THREE.Mesh(mergedGeo, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                chunk.meshes.push(mesh); 
            }
            if (physicsFaces.length > 0) {
                const combinedPhysicsGeo = THREE.BufferGeometryUtils.mergeBufferGeometries(physicsFaces);
                if (combinedPhysicsGeo && combinedPhysicsGeo.attributes.position && combinedPhysicsGeo.index) {
                    const vertices = combinedPhysicsGeo.attributes.position.array;
                    const faces = combinedPhysicsGeo.index.array; 
                    const trimeshShape = new CANNON.Trimesh(vertices, faces);
                    chunk.body = new CANNON.Body({ 
                        mass: 0, material: worldMaterial,
                        collisionFilterGroup: GROUP_WORLD, collisionFilterMask: GROUP_PLAYER
                    }); 
                    chunk.body.addShape(trimeshShape);
                    world.addBody(chunk.body);
                    combinedPhysicsGeo.dispose();
                }
                physicsFaces.forEach(g => g.dispose());
            }
        }

        // --- Carga dinámica de Chunks (sin cambios) ---
        function updateVisibleChunks() {
            const px = playerBody.position.x;
            const pz = playerBody.position.z;
            const playerChunkX = Math.floor(px / CHUNK_SIZE) * CHUNK_SIZE;
            const playerChunkZ = Math.floor(pz / CHUNK_SIZE) * CHUNK_SIZE;
            for (let x = -renderDistance; x <= renderDistance; x++) {
                for (let z = -renderDistance; z <= renderDistance; z++) {
                    const chunkX = playerChunkX + x * CHUNK_SIZE;
                    const chunkZ = playerChunkZ + z * CHUNK_SIZE;
                    const key = `${chunkX},${chunkZ}`;
                    if (!chunks[key]) initializeChunk(chunkX, chunkZ);
                    if (!chunks[key].isGenerated) generateChunkData(chunks[key]);
                    if (chunks[key].meshes.length === 0 && chunks[key].isGenerated) buildChunkMeshAndPhysics(chunks[key]);
                }
            }
        }

        // --- Lógica de romper bloque (MODIFICADA para nuevo inventario) ---
        function breakBlock(voxelPos, tool) {
            const destroyedBlock = getVoxel(voxelPos.x, voxelPos.y, voxelPos.z);
            if (destroyedBlock === BLOCKS.EMPTY) return;

            const requiredTool = destroyedBlock.minTool;
            const requiredTier = destroyedBlock.minTier;
            
            let canGetDrop = false;
            if (requiredTool === null) canGetDrop = true;
            else if (tool.toolType === requiredTool && tool.toolTier >= requiredTier) canGetDrop = true;
            
            if (canGetDrop) {
                const droppedItemId = destroyedBlock.drop || 0;
                if (droppedItemId !== 0) {
                    addItemToInventory({ id: droppedItemId, count: 1 });
                    updateHotbarUI(); // Refrescar hotbar por si el item cayó ahí
                }
            } 

            setVoxel(voxelPos.x, voxelPos.y, voxelPos.z, BLOCKS.EMPTY);
            
            // Regenerar chunks afectados (sin cambios)
            const chunk = getChunk(voxelPos.x, voxelPos.z);
            if(chunk) buildChunkMeshAndPhysics(chunk);
            const localX = (voxelPos.x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const localZ = (voxelPos.z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            if (localX === 0) {
                const neighborChunk = getChunk(voxelPos.x - 1, voxelPos.z);
                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
            } else if (localX === CHUNK_SIZE - 1) {
                const neighborChunk = getChunk(voxelPos.x + 1, voxelPos.z);
                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
            }
            if (localZ === 0) {
                const neighborChunk = getChunk(voxelPos.x, voxelPos.z - 1);
                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
            } else if (localZ === CHUNK_SIZE - 1) {
                const neighborChunk = getChunk(voxelPos.x, voxelPos.z + 1);
                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
            }
        }

        // --- Resetear estado de rotura (sin cambios) ---
        function resetBreakingState() {
            isBreaking = false;
            breakingStartTime = 0;
            currentBreakingVoxelPos = null;
            breakingDecal.visible = false;
            currentBlockBreakTime = Infinity;
        }

        // --- Calcular tiempo de rotura (sin cambios) ---
        function getBlockBreakTime(block, tool) {
            const baseHardnessMs = block.hardness * 1000;
            const HAND_PENALTY = 5.0;
            const WRONG_TOOL_PENALTY = 4.0; 
            if (block.minTool === null) {
                let speedMultiplier = 1;
                if (tool.toolTier > 0) speedMultiplier = tool.toolTier * 2;
                return baseHardnessMs / speedMultiplier;
            }
            if (tool.toolType !== block.minTool) return baseHardnessMs * HAND_PENALTY;
            if (tool.toolTier < block.minTier) return baseHardnessMs * HAND_PENALTY;
            let speedMultiplier = 1;
            if (tool.toolTier === 1) speedMultiplier = 2.5;
            if (tool.toolTier === 2) speedMultiplier = 4.0;
            if (tool.toolTier === 3) speedMultiplier = 6.0;
            if (tool.toolTier === 4) speedMultiplier = 8.0; 
            return baseHardnessMs / speedMultiplier;
        }


        // --- Empezar a romper (MODIFICADO para nuevo inventario) ---
        function startBreaking(voxelPos, face) {
            const block = getVoxel(voxelPos.x, voxelPos.y, voxelPos.z);
            if (block === BLOCKS.EMPTY) return;
            
            isBreaking = true;
            breakingStartTime = Date.now();
            currentBreakingVoxelPos = voxelPos.clone();
            
            // Obtener item actual de la hotbar
            const currentTool = playerInventorySlots[selectedHotbarSlot] || HAND;
            const itemData = currentTool.id > 0 ? ITEMS_BY_ID[currentTool.id] : HAND;
            currentBlockBreakTime = getBlockBreakTime(block, itemData);

            const normal = face.normal.clone();
            breakingDecal.position.copy(voxelPos).add(normal.clone().multiplyScalar(0.501));
            if (normal.x === 1) breakingDecal.rotation.set(0, Math.PI / 2, 0);
            else if (normal.x === -1) breakingDecal.rotation.set(0, -Math.PI / 2, 0);
            else if (normal.y === 1) breakingDecal.rotation.set(-Math.PI / 2, 0, 0);
            else if (normal.y === -1) breakingDecal.rotation.set(Math.PI / 2, 0, 0);
            else if (normal.z === 1) breakingDecal.rotation.set(0, 0, 0);
            else if (normal.z === -1) breakingDecal.rotation.set(0, Math.PI, 0);
            breakingDecal.material = breakingMaterials[0];
            breakingDecal.visible = true;
        }

        // --- Soltar el ratón (sin cambios) ---
        function onMouseUp(event) {
            if (event.button === 0) { // Clic Izquierdo
                resetBreakingState();
            }
        }

        // --- Manejo de Eventos (MODIFICADO) ---
        function onMouseDown(event) {
            if (currentUI !== 'none') return; // No interactuar si la UI está abierta
            if (!controls.isLocked) return;
            
            const intersect = getIntersection();
            
            if (event.button === 0) { // Clic Izquierdo (Empezar a romper)
                if (intersect) { 
                    const intersectedVoxelPos = getIntersectedVoxelCoordinates(intersect, false);
                    if (intersectedVoxelPos) {
                        startBreaking(intersectedVoxelPos, intersect.face);
                    }
                }
            
            } else if (event.button === 2) { // Clic Derecho (Construir / Interactuar)
                if (intersect) { 
                    
                    // --- NUEVO: Interactuar con bloques ---
                    const blockPos = getIntersectedVoxelCoordinates(intersect, false);
                    const block = getVoxel(blockPos.x, blockPos.y, blockPos.z);
                    
                    if (block.id === BLOCKS.CRAFTING_TABLE.id) {
                        event.preventDefault(); // Evitar que coloque un bloque
                        openCraftingTableUI();
                        return; // No colocar bloque
                    }
                    
                    // --- Lógica de construcción (MODIFICADA para nuevo inventario) ---
                    const slotToPlace = playerInventorySlots[selectedHotbarSlot];
                    if (!slotToPlace || slotToPlace.id === 0) return;
                    
                    const itemToPlace = ITEMS_BY_ID[slotToPlace.id];
                    if (!itemToPlace.isBlock) return; // Es un pico
                    
                    const blockToPlace = BLOCKS_BY_ID[itemToPlace.id];
                    if (!blockToPlace) return; 
                    
                    const intersectedVoxelPos = getIntersectedVoxelCoordinates(intersect, true); 
                    if (intersectedVoxelPos) {
                        const newX = intersectedVoxelPos.x;
                        const newY = intersectedVoxelPos.y;
                        const newZ = intersectedVoxelPos.z;

                        if (newY < WORLD_MIN_HEIGHT || newY >= WORLD_MAX_HEIGHT) return;
                        
                        const playerPos = playerBody.position;
                        const playerBox = new CANNON.Box(new CANNON.Vec3(0.5, 1, 0.5)); 
                        const playerBodySimple = new CANNON.Body({ position: playerPos });
                        playerBodySimple.addShape(playerBox);
                        const blockBox = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)); 
                        const blockBody = new CANNON.Body({ position: new CANNON.Vec3(newX, newY, newZ) });
                        blockBody.addShape(blockBox);
                        if (playerBodySimple.aabb.overlaps(blockBody.aabb)) {
                            return; 
                        }

                        if (getVoxel(newX, newY, newZ) === BLOCKS.EMPTY) {
                            
                            // Consumir item del slot
                            if (itemToPlace.maxStack > 0) { // No consumir si es "infinito" (herramientas)
                                slotToPlace.count--;
                                if (slotToPlace.count === 0) {
                                    slotToPlace.id = 0;
                                }
                                updateHotbarUI();
                            }
                            
                            let chunk = getChunk(newX, newZ);
                            if(!chunk) {
                                const chunkX = Math.floor(newX / CHUNK_SIZE) * CHUNK_SIZE;
                                const chunkZ = Math.floor(newZ / CHUNK_SIZE) * CHUNK_SIZE;
                                chunk = initializeChunk(chunkX, chunkZ);
                                if (!chunk.isGenerated) generateChunkData(chunk);
                            }

                            setVoxel(newX, newY, newZ, blockToPlace);
                            buildChunkMeshAndPhysics(chunk); 
                            
                            // Regenerar vecinos (sin cambios)
                            const localX = (newX % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                            const localZ = (newZ % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                            if (localX === 0) {
                                const neighborChunk = getChunk(newX - 1, newZ);
                                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
                            } else if (localX === CHUNK_SIZE - 1) {
                                const neighborChunk = getChunk(newX + 1, newZ);
                                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
                            }
                            if (localZ === 0) {
                                const neighborChunk = getChunk(newX, newZ - 1);
                                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
                            } else if (localZ === CHUNK_SIZE - 1) {
                                const neighborChunk = getChunk(newX, newZ + 1);
                                if (neighborChunk) buildChunkMeshAndPhysics(neighborChunk);
                            }
                        }
                    }
                }
            }
        }

        // --- Funciones de ayuda (sin cambios) ---
        function getIntersectedVoxelCoordinates(intersect, forPlacing = false) {
            const centeredPos = intersect.point.clone();
            const normal = intersect.face.normal.clone();
            if (forPlacing) {
                centeredPos.add(normal.multiplyScalar(0.5));
            } else {
                centeredPos.sub(normal.multiplyScalar(0.5));
            }
            const finalX = Math.round(centeredPos.x);
            const finalY = Math.round(centeredPos.y);
            const finalZ = Math.round(centeredPos.z);
            return new THREE.Vector3(finalX, finalY, finalZ);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function getIntersection() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const chunkMeshes = [];
            Object.values(chunks).forEach(c => {
                if (c.meshes) chunkMeshes.push(...c.meshes);
            });
            if (chunkMeshes.length === 0) return null;
            const intersects = raycaster.intersectObjects(chunkMeshes); 
            if (intersects.length > 0 && intersects[0].distance < 5) {
                return intersects[0];
            }
            return null;
        }

        // --- Bucle del Juego (Update) (MODIFICADO) ---
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            const elapsedTime = clock.getElapsedTime();
            
            world.step(1 / 60, delta, 5); 

            if (controls.isLocked) {
                handleMovement(delta);
                updateBreakingAnimation(); 
            }

            if (elapsedTime - lastChunkCheck > 1.0) {
                updateVisibleChunks();
                lastChunkCheck = elapsedTime;
            }

            camera.position.copy(playerBody.position);
            camera.position.y += 0.4; // Ajuste de altura de cámara
            
            renderer.render(scene, camera);
        }

        // --- Actualizar animación de rotura (MODIFICADO) ---
        function updateBreakingAnimation() {
            if (!isBreaking) return;
            const intersect = getIntersection();
            if (!intersect) {
                resetBreakingState();
                return;
            }
            const currentVoxel = getIntersectedVoxelCoordinates(intersect, false);
            if (!currentVoxel.equals(currentBreakingVoxelPos)) {
                resetBreakingState();
                startBreaking(currentVoxel, intersect.face); // Empezar en el nuevo bloque
                return;
            }
            const elapsed = Date.now() - breakingStartTime;
            const stage = Math.floor((elapsed / currentBlockBreakTime) * 10);
            if (stage >= 10) {
                const currentTool = playerInventorySlots[selectedHotbarSlot] || HAND;
                const itemData = currentTool.id > 0 ? ITEMS_BY_ID[currentTool.id] : HAND;
                breakBlock(currentBreakingVoxelPos, itemData); 
                resetBreakingState();
            } else {
                if (breakingMaterials[stage]) {
                     breakingDecal.material = breakingMaterials[stage];
                }
            }
        }


        // --- Lógica de Movimiento (sin cambios) ---
        function handleMovement(delta) {
            const inputVelocity = new THREE.Vector3();
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(camera.quaternion);
            const raycastOptions = {
                collisionFilterGroup: GROUP_PLAYER, 
                collisionFilterMask: GROUP_WORLD,    
                skipBackfaces: true
            };
            rayFrom.copy(playerBody.position);
            rayTo.set(playerBody.position.x, playerBody.position.y - 0.51, playerBody.position.z);
            raycastResult.reset();
            world.raycastClosest(rayFrom, rayTo, raycastOptions, raycastResult); 
            onGround = raycastResult.hasHit;
            if (keys['KeyW']) inputVelocity.z = -1;
            if (keys['KeyS']) inputVelocity.z = 1;
            if (keys['KeyA']) inputVelocity.x = -1; 
            if (keys['KeyD']) inputVelocity.x = 1;
            if (keys['Space'] && onGround) { 
                playerBody.velocity.y = jumpSpeed;
                onGround = false; 
            }
            inputVelocity.normalize().multiplyScalar(moveSpeed);
            inputVelocity.applyEuler(euler);
            playerBody.wakeUp(); 
            playerBody.velocity.x = inputVelocity.x;
            playerBody.velocity.z = inputVelocity.z;
        }
        
        // --- Iniciar Carga ---
        loadTextures();

    </script>
</body>
</html>

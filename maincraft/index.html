<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- 
      IMPORTANTE: Cargar los módulos de Three.js desde un CDN
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- 
      Cargamos el generador de ruido Simplex para el terreno 
    -->
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    
    <!-- NUEVO: Importar fuente Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CAMBIO DE NOMBRE -->
    <title>Cliente 3D MainCraft</title>
    <style>
        /* --- NUEVO: Estilos Modernos (Modo Oscuro) --- */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif; /* Fuente Inter */
            background-color: #1a1a1a; /* Fondo oscuro */
            color: #f0f0f0;
            user-select: none; /* Evitar seleccionar texto */
        }
        
        /* CORRECCIÓN: Lienzo 3D oculto al inicio */
        #game-canvas {
            display: none; /* Oculto hasta unirse al mundo */
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* --- Contenedores de Pantalla --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 26, 0.95); /* Fondo oscuro semitransparente */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99;
        }
        
        /* Ocultar pantallas por defecto */
        #homescreen, #game-ui, #crosshair, #inventory-screen {
            display: none;
        }

        /* --- Estilos de Cajas de Formulario --- */
        .form-box {
            width: 380px;
            padding: 30px;
            background-color: #2c2c2c; /* Gris oscuro para el formulario */
            border-radius: 12px;
            text-align: center;
            color: #f0f0f0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
        
        .form-box h2 {
            margin-top: 0;
            color: #66bb6a; /* Verde claro */
            font-weight: 700;
        }

        .input-group {
            margin-bottom: 18px;
            text-align: left;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
            font-size: 0.9em;
            color: #aaa;
        }
        
        .input-group input {
            width: 95%; /* Ajustado para padding */
            padding: 12px 10px;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #3a3a3a; /* Fondo de input oscuro */
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            font-size: 1em;
        }
        
        /* Placeholder styling */
        .input-group input::placeholder {
            color: #888;
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            font-size: 18px;
            background-color: #66bb6a; /* Verde claro */
            color: #111; /* Texto oscuro para mejor contraste */
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 99;
            margin-top: 10px;
            font-weight: 700;
            transition: background-color 0.2s ease;
        }
        .btn:hover {
            background-color: #81c784;
        }
        .btn:disabled {
            background-color: #555;
            color: #888;
        }
        
        .status-message {
            margin-top: 15px;
            color: #f44336; /* Rojo */
            font-weight: bold;
        }
        
        /* --- Estilos del Homescreen (Selector de Servidor) --- */
        #server-list-container {
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 6px;
            margin-bottom: 15px;
            background: #3a3a3a; /* Fondo oscuro */
        }
        
        .server-item {
            padding: 14px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .server-item:hover {
            background-color: #4a5a4a; /* Verde oscuro hover */
        }
        .server-item:last-child {
            border-bottom: none;
        }
        
        .server-item-name {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            flex-grow: 1; /* Ocupa el espacio */
        }
        .server-item-name span {
            font-size: 1.1em;
            color: #f0f0f0;
        }
        
        /* Estilo para el nombre del creador */
        .creator-name {
            font-size: 0.8em;
            color: #aaa;
        }
        
        .delete-world-btn {
            width: auto;
            padding: 6px 12px;
            font-size: 0.9em;
            background-color: #f44336; /* Rojo */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px; /* Espacio del nombre */
            transition: background-color 0.2s ease;
            font-weight: 700;
        }
        .delete-world-btn:hover {
            background-color: #e57373;
        }
        
        #create-world-group {
            display: flex;
            gap: 10px;
        }
        
        #create-world-group input {
            flex-grow: 1; 
            width: 60%;
        }
        
        #createWorldButton {
            width: auto;
            flex-grow: 0;
            font-size: 16px;
        }
        
        #logoutButton {
            background-color: #f44336; /* Rojo */
            color: white;
            margin-top: 20px;
        }
        #logoutButton:hover {
            background-color: #e57373;
        }

        /* --- Estilos del Juego --- */
        
        /* Contenedor para las etiquetas de nombres (CSS2D) */
        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* No intercepta clics */
            z-index: 5; /* Detrás de la UI pero delante del juego */
            display: none; /* CORRECCIÓN: Oculto por defecto */
        }
        
        /* Estilo para la etiqueta del nombre del jugador */
        .player-label {
            color: white;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 700;
            text-shadow: 1px 1px 2px black;
            user-select: none;
            white-space: nowrap; /* Evita que el nombre se parta */
        }

        /* Mirilla (crosshair) en el centro */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border: 1px solid rgba(0,0,0,0.5);
            border-radius: 50%; /* Punto circular */
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none; /* Evita que la mirilla bloquee los clics */
        }

        /* Interfaz de Usuario (Vida y Hotbar) */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: column; /* Apila la vida encima de la hotbar */
            align-items: center;
            z-index: 20;
            pointer-events: none; /* No intercepta clics */
        }
        
        /* Barra de Vida */
        #health-bar {
            display: flex;
            margin-bottom: 5px; /* Espacio entre vida y hotbar */
        }
        
        .heart {
            font-size: 20px;
            margin: 0 1px;
            user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); 
        }

        /* Clase de Slot Genérica */
        .slot {
            width: 50px;
            height: 50px;
            margin: 2px;
            border: 2px solid #888;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            position: relative; 
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box; /* Importante para que el borde no sume */
        }
        
        /* Hotbar (in-game) */
        #hotbar {
            display: flex;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 5px;
            pointer-events: auto; /* La hotbar SÍ recibe clics */
        }

        .hotbar-slot.active {
            border: 3px solid #ffffff;
            transform: scale(1.05); /* Resaltar */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        /* Estilos de Item (Icono y Cantidad) */
        .item-icon {
            width: 36px;
            height: 36px;
            image-rendering: pixelated; /* Mantiene los píxeles nítidos */
            display: none; /* Oculto por defecto */
            pointer-events: none; /* No bloquear clics */
        }

        .item-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            display: none; /* Oculto por defecto */
        }
        
        /* Estilos de la Pantalla de Inventario/Crafteo */
        #inventory-screen {
            z-index: 100;
            flex-direction: column;
            background-color: rgba(26, 26, 26, 0.85); /* Más suave */
        }
        
        #inventory-modal {
            width: auto;
            padding: 20px;
            background-color: #2c2c2c;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            
            display: grid;
            grid-template-areas: 
                "title title"
                "crafting result"
                "main-inv main-inv"
                "hotbar-inv hotbar-inv";
            gap: 20px;
        }
        
        #inventory-modal h2 {
            grid-area: title;
            margin: 0;
            color: #66bb6a;
            text-align: center;
        }

        /* Contenedor de Crafteo */
        #crafting-area {
            grid-area: crafting;
            display: grid;
            grid-template-columns: auto auto; /* 2x2 grid */
            gap: 5px;
            --grid-cols: 2; 
        }
        
        /* Grid de Crafteo (2x2 o 3x3) */
        #crafting-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), 54px);
            gap: 2px;
            align-self: start;
        }
        
        /* Flecha y Resultado */
        #crafting-arrow {
            grid-area: result;
            display: flex;
            align-items: center;
            justify-content: space-evenly;
            padding: 0 10px;
        }
        
        #crafting-arrow::before {
            content: "➡️";
            font-size: 24px;
            color: #888;
        }
        
        /* Grid del Inventario Principal (27 slots) */
        #player-inventory-grid {
            grid-area: main-inv;
            display: grid;
            grid-template-columns: repeat(9, 54px);
            gap: 2px;
        }
        
        /* Grid de la Hotbar (en el inventario) (9 slots) */
        #player-hotbar-grid {
            grid-area: hotbar-inv;
            display: grid;
            grid-template-columns: repeat(9, 54px);
            gap: 2px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        
        /* Item en el cursor (Drag-and-Drop) */
        #item-cursor {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(100, 100, 255, 0.3);
            border: 2px solid white;
            border-radius: 6px;
            z-index: 999;
            pointer-events: none; /* No bloquear clics */
            
            display: none; /* Oculto por defecto, 'flex' al coger item */
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        
    </style>
</head>
<body>
    <!-- PANTALLA 1: LOGIN -->
    <div id="login-screen" class="screen">
        <div class="form-box">
            <h2>MainCraft Online</h2>
            <div class="input-group">
                <label for="username">Usuario:</label>
                <input type="text" id="username" placeholder="TuUsuario">
            </div>
            <div class="input-group">
                <label for="password">Contraseña:</label>
                <input type="password" id="password" placeholder="TuContraseña">
            </div>
            <button id="loginButton" class="btn">Login / Registrarse</button>
            <div id="loginStatus" class="status-message"></div>
        </div>
    </div>

    <!-- PANTALLA 2: HOMESCREEN (SELECTOR DE MUNDO) -->
    <div id="homescreen" class="screen">
        <div class="form-box">
            <h2>Selecciona un Mundo</h2>
            <div id="server-list-container">
                <div id="server-list">
                    <!-- Los servidores se llenan con JS -->
                </div>
            </div>
            
            <div class="input-group">
                <label for="newWorldName">O crea uno nuevo:</label>
                <div id="create-world-group">
                    <input type="text" id="newWorldName" placeholder="Nombre del nuevo mundo...">
                    <button id="createWorldButton" class="btn">Crear</button>
                </div>
            </div>
            
            <button id="logoutButton" class="btn">Cerrar Sesión</button>
        </div>
    </div>

    <!-- PANTALLA 3: JUEGO -->
    
    <!-- Lienzo 3D (Oculto al inicio) -->
    <canvas id="game-canvas"></canvas>
    
    <!-- Contenedor para las etiquetas de nombres -->
    <div id="label-container"></div>
    
    <!-- La mirilla -->
    <div id="crosshair"></div>
    
    <!-- Pantalla de Inventario (oculta) -->
    <div id="inventory-screen" class="screen">
        <div id="inventory-modal">
            <h2 id="inventory-title">Inventario</h2>
            
            <!-- Crafteo (Grid + Flecha + Resultado) -->
            <div id="crafting-area">
                <div id="crafting-grid">
                    <!-- Slots 0-8 (se muestran/ocultan 2x2 vs 3x3) -->
                    <div class="slot slot-2x2" data-slot-type="crafting" data-slot-index="0">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-2x2" data-slot-type="crafting" data-slot-index="1">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-3x3" data-slot-type="crafting" data-slot-index="2">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    
                    <div class="slot slot-2x2" data-slot-type="crafting" data-slot-index="3">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-2x2" data-slot-type="crafting" data-slot-index="4">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-3x3" data-slot-type="crafting" data-slot-index="5">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    
                    <div class="slot slot-3x3" data-slot-type="crafting" data-slot-index="6">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-3x3" data-slot-type="crafting" data-slot-index="7">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                    <div class="slot slot-3x3" data-slot-type="crafting" data-slot-index="8">
                        <img class="item-icon">
                        <span class="item-quantity"></span>
                    </div>
                </div>
            </div>
            
            <div id="crafting-arrow">
                <div class="slot" data-slot-type="result" data-slot-index="0">
                    <img class="item-icon">
                    <span class="item-quantity"></span>
                </div>
            </div>
            
            <!-- Inventario Principal (27 slots) -->
            <div id="player-inventory-grid">
                <!-- Slots 9-35 (índices 0-26) -->
            </div>
            
            <!-- Hotbar (9 slots) -->
            <div id="player-hotbar-grid">
                <!-- Slots 0-8 (índices 0-8) -->
            </div>
        </div>
    </div>
    
    <!-- Item en el cursor -->
    <div id="item-cursor">
        <img class="item-icon">
        <span class="item-quantity"></span>
    </div>


    <!-- Contenedor de la Interfaz (Vida + Hotbar) -->
    <div id="game-ui">
        <div id="ui-container">
            <!-- Barra de vida -->
            <div id="health-bar">
                <!-- Los corazones se generan dinámicamente con JS -->
            </div>
            <!-- Contenedor de la Hotbar (en el juego) -->
            <div id="hotbar">
                <!-- Los slots se generan dinámicamente con JS -->
            </div>
        </div>
    </div>

    <!-- 
      Script principal del juego
    -->
    <script type="module">
        
        // --- Configuración de Firebase (dada por el usuario) ---
        const firebaseConfig = {
          apiKey: "AIzaSyCvqvernkGHCvBuGArnJSXcka40lCFBKGk",
          authDomain: "maincraft-e2b8c.firebaseapp.com",
          databaseURL: "https://maincraft-e2b8c-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "maincraft-e2b8c",
          storageBucket: "maincraft-e2b8c.appspot.com", 
          messagingSenderId: "10833551639",
          appId: "1:10833551639:web:d2f83d3967b38710f31752",
          measurementId: "G-E2FMTZZ92P"
        };
        
        // --- Imports de Firebase ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getDatabase, ref, set, onValue, onChildAdded, onChildRemoved, serverTimestamp, query, orderByChild, remove, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // --- Imports de Three.js ---
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Variables Globales ---
        let scene, camera, renderer, controls, raycaster;
        let noise; // Generador de ruido
        let labelRenderer;
        
        // --- Constantes del Jugador ---
        const playerHeight = 1.9; // Altura del jugador
        const playerWidth = 0.4; 
        const gravity = -30.0; 
        const jumpForce = 12.0; 
        const moveSpeed = 40.0; 

        // --- Variables de Firebase ---
        let db, auth;
        let worldName; // El "servidor"
        let userId;    // Nuestro ID de Firebase
        let userName;  // Nuestro nombre de usuario
        let lastFirebaseUpdate = 0;
        let players = new Map(); // Mapa para [userId, { mesh, label }] de otros jugadores
        const playerMeshGeometry = new THREE.BoxGeometry(playerWidth * 2, playerHeight, playerWidth * 2);
        const playerMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, opacity: 0.6, transparent: true });
        
        // Listeners de Firebase (para poder desconectarlos)
        let playersListener = null;
        let blocksListener = { added: null, removed: null }; 
        let worldsListener = null;
        let inventoryListener = null; 

        // --- Sistema de Chunks ---
        const worldData = new Map(); // Guarda los DATOS de bloques ({type: 'stone'}) por chunk
        const chunkMeshes = new Map(); // Guarda las MALLAS generadas por chunk
        
        const chunkSize = 16; 
        // CAMBIO: Altura del chunk (profundidad)
        const chunkHeight = 128; // Desde y=64 hasta y=-64 
        const renderDistance = 1; // 3x3
        
        let currentChunk = new THREE.Vector2(Infinity, Infinity); 

        // --- Variables del Jugador ---
        let playerVelocity = new THREE.Vector3();
        let playerDirection = new THREE.Vector3();
        let playerOnFloor = false; 
        let playerBox = new THREE.Box3(); 
        let lastPlayerVelY = 0; // Para calcular daño por caída

        // --- Sistema de Vida ---
        let playerHealth = 20;
        let playerMaxHealth = 20;

        // --- Variables de Movimiento ---
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        
        let prevTime = performance.now(); 

        // --- Sistema de Minería ---
        let isMining = false;
        let miningTimer = 0;
        let currentMiningBlockCoords = null; // Guarda {x, y, z}
        const blockBreakTime = 0.5; 
        
        // --- Animación de Rotura ---
        let destroyTextures = []; 
        let breakingBlockOverlay = null; 
        let breakingMaterial; 

        // --- Variables de Inventario y Crafteo ---
        let hotbarElement;
        let hotbarSlots = []; // Divs de la hotbar in-game
        let selectedSlot = 0; 
        
        let inventory = []; // 36 slots
        
        // Estado de Crafteo
        let craftingGrid2x2 = [];
        let craftingGrid3x3 = [];
        let resultSlot2x2 = { type: null, quantity: 0 };
        let resultSlot3x3 = { type: null, quantity: 0 };
        let heldItem = { type: null, quantity: 0 }; // Item en el cursor
        let isCrafting = false; // ¿Está el inventario abierto?
        let currentCraftingType = '2x2'; // '2x2' o '3x3'
        
        // DOM Elements
        let gameCanvas, itemCursorElement, playerInventoryGrid, playerHotbarGrid, craftingGridElement, resultSlotElement;
        
        let materials = {}; // SOLO para bloques
        
        // --- URLs de Texturas ---
        const textureBaseUrl = 'https://logise1.github.io/maincraft/';
        const textureLoader = new THREE.TextureLoader();
        
        // --- Constantes del Mundo ---
        const terrainHeight = 6;
        const terrainScale = 0.05; 
        // CAMBIO: Profundidad del mundo
        const worldDepth = -64; 
        
        // --- Geometría de Bloque (única, para animación rotura) ---
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        
        // --- Set de tipos de items (para evitar colocarlos) ---
        const itemTypes = new Set([
            'diamond', 'emerald', 'redstone', 'iron_ingot', 'gold_ingot', 'stick',
            'wooden_pickaxe', 'stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe',
            'diamond_pickaxe', 'netherite_pickaxe'
        ]);
        
        // --- Base de datos de Recetas ---
        const RECIPES = {
            // 2x2
            'oak_log,null,null,null': { result: 'oak_planks', count: 4 },
            'null,oak_log,null,null': { result: 'oak_planks', count: 4 },
            'null,null,oak_log,null': { result: 'oak_planks', count: 4 },
            'null,null,null,oak_log': { result: 'oak_planks', count: 4 },
            
            'oak_planks,null,oak_planks,null': { result: 'stick', count: 4 },
            'null,oak_planks,null,oak_planks': { result: 'stick', count: 4 },
            
            'oak_planks,oak_planks,oak_planks,oak_planks': { result: 'crafting_table', count: 1 },
            
            // 3x3 (Llave de 9)
            'oak_planks,oak_planks,oak_planks,null,stick,null,null,stick,null': { result: 'wooden_pickaxe', count: 1 }
        };

        // --- Carga de Texturas ---
        
        function loadTexture(url) {
            const texture = textureLoader.load(url);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // --- Carga de texturas SOLO para BLOQUES ---
        const stoneTexture = loadTexture(`${textureBaseUrl}stone.png`);
        const dirtTexture = loadTexture(`${textureBaseUrl}dirt.png`);
        const grassTopTexture = loadTexture(`${textureBaseUrl}grass_block_top.png`);
        const grassSideTexture = loadTexture(`${textureBaseUrl}grass_block_side.png`);
        const cobblestoneTexture = loadTexture(`${textureBaseUrl}cobblestone.png`);
        const oakLogTexture = loadTexture(`${textureBaseUrl}oak_log.png`);
        const oakLogTopTexture = loadTexture(`${textureBaseUrl}oak_log_top.png`);
        const oakPlanksTexture = loadTexture(`${textureBaseUrl}oak_planks.png`);
        const oakLeavesTexture = loadTexture(`${textureBaseUrl}oak_leaves.png`);
        
        const craftingTableTopTexture = loadTexture(`${textureBaseUrl}crafting_table_top.png`);
        const craftingTableSideTexture = loadTexture(`${textureBaseUrl}crafting_table_side.png`);
        const craftingTableFrontTexture = loadTexture(`${textureBaseUrl}crafting_table_front.png`);
        
        // Ores
        const coalOreTexture = loadTexture(`${textureBaseUrl}coal_ore.png`);
        const ironOreTexture = loadTexture(`${textureBaseUrl}iron_ore.png`);
        const goldOreTexture = loadTexture(`${textureBaseUrl}gold_ore.png`);
        const diamondOreTexture = loadTexture(`${textureBaseUrl}diamond_ore.png`);
        const emeraldOreTexture = loadTexture(`${textureBaseUrl}emerald_ore.png`);
        const lapisOreTexture = loadTexture(`${textureBaseUrl}lapis_ore.png`);
        const redstoneOreTexture = loadTexture(`${textureBaseUrl}redstone_ore.png`);


        // --- Materiales (Bloques) ---
        // CAMBIO: Ahora son arrays de materiales, uno por tipo de bloque
        // Usaremos multi-materiales en la malla del chunk
        
        const blockMaterials = [
            // Índice 0: grass_side
            new THREE.MeshStandardMaterial({ map: grassSideTexture }),
            // Índice 1: grass_top
            new THREE.MeshStandardMaterial({ map: grassTopTexture, color: 0x90ee90 }), // Tinte verde
            // Índice 2: dirt
            new THREE.MeshStandardMaterial({ map: dirtTexture }),
            // Índice 3: stone
            new THREE.MeshStandardMaterial({ map: stoneTexture }),
            // Índice 4: cobblestone
            new THREE.MeshStandardMaterial({ map: cobblestoneTexture }),
            // Índice 5: oak_log_side
            new THREE.MeshStandardMaterial({ map: oakLogTexture }),
            // Índice 6: oak_log_top
            new THREE.MeshStandardMaterial({ map: oakLogTopTexture }),
            // Índice 7: oak_planks
            new THREE.MeshStandardMaterial({ map: oakPlanksTexture }),
            // Índice 8: oak_leaves
            new THREE.MeshStandardMaterial({ 
                map: oakLeavesTexture, 
                transparent: true, 
                alphaTest: 0.1, 
                side: THREE.DoubleSide, // Importante para que se vea por dentro
                color: 0x90ee90 // Tinte verde
            }),
            // Índice 9: crafting_table_top
            new THREE.MeshStandardMaterial({ map: craftingTableTopTexture }),
            // Índice 10: crafting_table_side
            new THREE.MeshStandardMaterial({ map: craftingTableSideTexture }),
            // Índice 11: crafting_table_front
            new THREE.MeshStandardMaterial({ map: craftingTableFrontTexture }),
            // Índice 12: coal_ore
            new THREE.MeshStandardMaterial({ map: coalOreTexture }),
            // Índice 13: iron_ore
            new THREE.MeshStandardMaterial({ map: ironOreTexture }),
            // Índice 14: gold_ore
            new THREE.MeshStandardMaterial({ map: goldOreTexture }),
            // Índice 15: diamond_ore
            new THREE.MeshStandardMaterial({ map: diamondOreTexture }),
            // Índice 16: emerald_ore
            new THREE.MeshStandardMaterial({ map: emeraldOreTexture }),
            // Índice 17: lapis_ore
            new THREE.MeshStandardMaterial({ map: lapisOreTexture }),
            // Índice 18: redstone_ore
            new THREE.MeshStandardMaterial({ map: redstoneOreTexture }),
        ];
        
        // Mapeo de Tipo de Bloque -> Índices de Material para cada cara [px, nx, py, ny, pz, nz]
        const blockMaterialIndices = {
            'grass': [0, 0, 1, 2, 0, 0],
            'dirt': [2, 2, 2, 2, 2, 2],
            'stone': [3, 3, 3, 3, 3, 3],
            'cobblestone': [4, 4, 4, 4, 4, 4],
            'oak_log': [5, 5, 6, 6, 5, 5],
            'oak_planks': [7, 7, 7, 7, 7, 7],
            'oak_leaves': [8, 8, 8, 8, 8, 8],
            'crafting_table': [10, 10, 9, 7, 11, 10], // px, nx, py(top), ny(bottom), pz(front), nz
            'coal_ore': [12, 12, 12, 12, 12, 12],
            'iron_ore': [13, 13, 13, 13, 13, 13],
            'gold_ore': [14, 14, 14, 14, 14, 14],
            'diamond_ore': [15, 15, 15, 15, 15, 15],
            'emerald_ore': [16, 16, 16, 16, 16, 16],
            'lapis_ore': [17, 17, 17, 17, 17, 17],
            'redstone_ore': [18, 18, 18, 18, 18, 18],
        };
        
        // Caras de un cubo [direccion x, y, z], [vértices (índices)]
        const faces = [
            { dir: [ 1,  0,  0], vertices: [ [1,1,1], [1,0,1], [1,0,0], [1,1,0] ] }, // px
            { dir: [-1,  0,  0], vertices: [ [0,1,0], [0,0,0], [0,0,1], [0,1,1] ] }, // nx
            { dir: [ 0,  1,  0], vertices: [ [1,1,1], [0,1,1], [0,1,0], [1,1,0] ] }, // py
            { dir: [ 0, -1,  0], vertices: [ [1,0,0], [0,0,0], [0,0,1], [1,0,1] ] }, // ny
            { dir: [ 0,  0,  1], vertices: [ [0,1,1], [0,0,1], [1,0,1], [1,1,1] ] }, // pz
            { dir: [ 0,  0, -1], vertices: [ [1,1,0], [1,0,0], [0,0,0], [0,1,0] ] }  // nz
        ];


        // --- Optimización de Colisión ---
        const collisionCheckBlockBox = new THREE.Box3();
        const boxMin = new THREE.Vector3();
        const boxMax = new THREE.Vector3();


        // --- Inicialización ---
        function init() {
            // Inventario
            for (let i = 0; i < 36; i++) {
                inventory.push({ type: null, quantity: 0 });
            }
            for (let i = 0; i < 4; i++) craftingGrid2x2.push({ type: null, quantity: 0 });
            for (let i = 0; i < 9; i++) craftingGrid3x3.push({ type: null, quantity: 0 });

            // 1. Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 0, (renderDistance + 1) * chunkSize); 

            // 2. Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = terrainHeight + 5; 

            // 3. Renderer (WebGL)
            gameCanvas = document.getElementById('game-canvas'); 
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            
            // 3b. Renderer (CSS2D para etiquetas)
            const labelContainer = document.getElementById('label-container');
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelContainer.appendChild(labelRenderer.domElement); 

            // 4. Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; 
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // 5. Controles (Pointer Lock)
            controls = new PointerLockControls(camera, renderer.domElement); 
            scene.add(controls.getObject()); 
            
            controls.addEventListener('unlock', () => {
                if (isCrafting) {
                    return; 
                }
                
                if (worldName) {
                    // Desconectar listeners
                    if (playersListener) off(ref(db, `worlds/${worldName}/players`), 'value', playersListener);
                    if (blocksListener.added) off(ref(db, `worlds/${worldName}/blocks`), 'child_added', blocksListener.added);
                    if (blocksListener.removed) off(ref(db, `worlds/${worldName}/blocks`), 'child_removed', blocksListener.removed);
                    if (inventoryListener) off(ref(db, `worlds/${worldName}/inventories/${userId}`), 'value', inventoryListener);
                    
                    playersListener = null;
                    blocksListener = { added: null, removed: null };
                    inventoryListener = null;
                    worldName = null;
                    
                    // Limpiar jugadores
                    players.forEach(player => {
                        scene.remove(player.mesh);
                        player.mesh.remove(player.label);
                    });
                    players.clear();
                    
                    // Limpiar Mallas de Chunks
                    chunkMeshes.forEach(mesh => scene.remove(mesh));
                    chunkMeshes.clear();
                    worldData.clear(); // Limpiar datos de bloques
                    
                    // Ocultar UI del juego
                    document.getElementById('game-ui').style.display = 'none';
                    document.getElementById('crosshair').style.display = 'none';
                    document.getElementById('ui-container').style.display = 'none';
                    document.getElementById('label-container').style.display = 'none'; 
                    document.getElementById('game-canvas').style.display = 'none'; 
                    
                    showHomescreen(); 
                }
            });
            
            // 6. Flujo de Login
            initLoginScreen();
            
            // 7. Raycaster
            raycaster = new THREE.Raycaster(); // CAMBIO: Sin parámetros por defecto
            raycaster.far = 7; // Límite de alcance para minar/poner

            // 8. Generador de Ruido
            noise = new window.SimplexNoise(); 
            
            // Cargar texturas de rotura
            for (let i = 0; i < 10; i++) {
                const texture = loadTexture(`${textureBaseUrl}destroy_stage_${i}.png`);
                destroyTextures.push(texture);
            }
            
            // Material de rotura
            breakingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                depthTest: false,
                depthWrite: false
            });
            
            // 9. Configurar UI (Vida y Hotbar)
            setupHealthBar();
            setupHotbar();
            
            // 10. Configurar Inventario y Crafteo
            initInventoryUI();
            
            // 11. Eventos de Teclado y Ratón
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp); 
            document.addEventListener('wheel', onMouseWheel); 
            
            // 12. Eventos de Drag-and-Drop
            document.addEventListener('mousemove', onDragCursor);
            document.getElementById('inventory-screen').addEventListener('click', onSlotClick);
            document.getElementById('inventory-screen').addEventListener('contextmenu', onSlotRightClick);

            // 13. Manejador de Redimensión de Ventana
            window.addEventListener('resize', onWindowResize);
            
            // 14. Bucle de Juego
            animate();
        }
        
        // --- Flujo de Autenticación y Lobby ---
        
        function initLoginScreen() {
            const loginButton = document.getElementById('loginButton');
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            const loginStatus = document.getElementById('loginStatus');

            loginButton.addEventListener('click', async () => {
                const username = usernameInput.value;
                const password = passwordInput.value;
                const email = username + "@email.org";

                if (!username || !password) {
                    loginStatus.textContent = "Rellena todos los campos.";
                    return;
                }
                
                loginStatus.textContent = "Conectando...";
                loginButton.disabled = true;
                
                userName = username; // Guardar nombre de usuario

                try {
                    // 1. Inicializar Firebase
                    const app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getDatabase(app); 

                    // 2. Intentar Iniciar Sesión
                    try {
                        const userCredential = await signInWithEmailAndPassword(auth, email, password);
                        userId = userCredential.user.uid;
                    } catch (signInError) {
                        // 3. Si falla el login
                        if (signInError.code === 'auth/user-not-found' || signInError.code === 'auth/invalid-credential') {
                            // Intentamos crear la cuenta
                            try {
                                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                                userId = userCredential.user.uid;
                            } catch (createError) {
                                if (createError.code === 'auth/email-already-in-use') {
                                    loginStatus.textContent = "Contraseña incorrecta.";
                                    loginButton.disabled = false;
                                    return; 
                                } else {
                                    throw createError;
                                }
                            }
                        } else {
                            throw signInError; 
                        }
                    }
                    
                    // 4. Si todo va bien, ir al Homescreen
                    loginStatus.textContent = "";
                    showHomescreen();

                } catch (error) {
                    console.error("Error de autenticación:", error);
                    loginStatus.textContent = `Error: ${error.message}`;
                    loginButton.disabled = false;
                }
            });
        }
        
        function showHomescreen() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('homescreen').style.display = 'flex';
            
            const createButton = document.getElementById('createWorldButton');
            const newWorldInput = document.getElementById('newWorldName');
            const logoutButton = document.getElementById('logoutButton');
            
            createButton.onclick = async () => {
                const newWorld = newWorldInput.value.trim();
                if (newWorld) {
                    const worldListRef = ref(db, "worldList/" + newWorld);
                    await set(worldListRef, { 
                        createdAt: serverTimestamp(),
                        creatorId: userId,
                        creatorName: userName 
                    });
                    joinWorld(newWorld);
                }
            };
            
            logoutButton.onclick = async () => {
                await signOut(auth);
                if (worldsListener) {
                    off(ref(db, "worldList"), 'value', worldsListener);
                }
                
                document.getElementById('homescreen').style.display = 'none';
                document.getElementById('login-screen').style.display = 'flex';
                document.getElementById('loginButton').disabled = false;
                document.getElementById('loginStatus').textContent = "Sesión cerrada.";
            };

            // Escuchar la lista de mundos (RTDB)
            const worldListRef = ref(db, "worldList");
            const q = query(worldListRef, orderByChild("createdAt"));
            
            if (worldsListener) off(ref(db, "worldList"), 'value', worldsListener);
            
            worldsListener = onValue(q, (snapshot) => {
                const serverList = document.getElementById('server-list');
                serverList.innerHTML = ''; 
                
                if(!snapshot.exists()) {
                    serverList.innerHTML = '<div style="padding: 10px; color: #777;">No hay mundos. ¡Crea uno!</div>';
                    return;
                }
                
                const worlds = [];
                snapshot.forEach(childSnapshot => {
                    worlds.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                
                worlds.reverse().forEach(world => {
                    const serverItem = document.createElement('div');
                    serverItem.className = 'server-item';
                    
                    const serverNameDiv = document.createElement('div');
                    serverNameDiv.className = 'server-item-name';
                    
                    const creator = world.creatorName || 'Desconocido';
                    serverNameDiv.innerHTML = `<span>${world.id}</span> <span class="creator-name">(Creador: ${creator})</span>`;
                    
                    serverNameDiv.onclick = () => {
                        joinWorld(world.id);
                    };
                    serverItem.appendChild(serverNameDiv);
                    
                    // Botón Eliminar
                    if (world.creatorId === userId) {
                        const deleteButton = document.createElement('button');
                        deleteButton.className = 'delete-world-btn';
                        deleteButton.textContent = 'Eliminar';
                        deleteButton.onclick = async (e) => {
                            e.stopPropagation(); 
                            if (confirm(`¿Seguro que quieres eliminar el mundo "${world.id}"? Esta acción no se puede deshacer.`)) {
                                await deleteWorld(world.id);
                            }
                        };
                        serverItem.appendChild(deleteButton);
                    }
                    
                    serverList.appendChild(serverItem);
                });
            });
        }
        
        async function deleteWorld(worldId) {
            const worldListRef = ref(db, `worldList/${worldId}`);
            await remove(worldListRef);
            
            const worldDataRef = ref(db, `worlds/${worldId}`);
            await remove(worldDataRef);
        }
        
        async function joinWorld(selectedWorldName) {
            worldName = selectedWorldName;
            
            if (worldsListener) {
                off(ref(db, "worldList"), 'value', worldsListener);
            }
            
            // Ocultar homescreen y mostrar UI del juego
            document.getElementById('homescreen').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('ui-container').style.display = 'flex';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('label-container').style.display = 'block'; 
            document.getElementById('game-canvas').style.display = 'block'; 
            
            // Limpiar datos del mundo anterior si los hubiera
            chunkMeshes.forEach(mesh => scene.remove(mesh));
            chunkMeshes.clear();
            worldData.clear();
            currentChunk.set(Infinity, Infinity); // Forzar carga inicial
            
            // Cargar inventario
            await loadInventory();
            
            controls.lock(); // Bloquear el cursor
            
            // Iniciar listeners de Firebase
            initFirebaseWorldListeners();
        }
        
        // Cargar/crear inventario de 36 slots
        async function loadInventory() {
            const invRef = ref(db, `worlds/${worldName}/inventories/${userId}`);
            
            inventoryListener = onValue(invRef, (snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    if (Array.isArray(data) && data.length === 36) {
                        inventory = data;
                    } else {
                        createEmptyInventory(invRef);
                    }
                } else {
                    createEmptyInventory(invRef);
                }
                updateHotbarInventoryUI();
            });
        }
        
        function createEmptyInventory(invRef) {
             inventory = [];
             for (let i = 0; i < 36; i++) {
                 inventory.push({ type: null, quantity: 0 });
             }
             set(invRef, inventory);
        }
        
        async function saveInventory() {
            if (!db || !worldName || !userId) return;
            const invRef = ref(db, `worlds/${worldName}/inventories/${userId}`);
            set(invRef, inventory);
        }

        
        // Escuchar cambios de Firebase (RTDB)
        function initFirebaseWorldListeners() {
            
            // 1. Listener para Jugadores
            const playersRef = ref(db, `worlds/${worldName}/players`);
            playersListener = onValue(playersRef, (snapshot) => {
                const activePlayers = new Set();
                
                if (!snapshot.exists()) return;

                snapshot.forEach(childSnapshot => {
                    const data = childSnapshot.val();
                    const playerId = childSnapshot.key;
                    
                    if (playerId === userId) return;
                    activePlayers.add(playerId);
                    
                    const now = Date.now();
                    if (data.timestamp && (now - data.timestamp > 10000)) {
                        return; // Ignorar jugador desconectado
                    }

                    let player = players.get(playerId);
                    if (!player) {
                        // Crear Mesh
                        const playerMesh = new THREE.Mesh(playerMeshGeometry, playerMeshMaterial);
                        
                        // Crear Label (Etiqueta de nombre)
                        const labelDiv = document.createElement('div');
                        labelDiv.className = 'player-label';
                        labelDiv.textContent = data.username || 'Jugador';
                        
                        const playerLabel = new CSS2DObject(labelDiv);
                        playerLabel.position.set(0, playerHeight / 2 + 0.5, 0); 
                        playerMesh.add(playerLabel);
                        
                        scene.add(playerMesh);
                        player = { mesh: playerMesh, label: playerLabel };
                        players.set(playerId, player);
                    }
                    
                    player.mesh.position.set(data.x, data.y - (playerHeight / 2), data.z);
                });
                
                // Limpiar jugadores que ya no están
                for (const [playerId, player] of players.entries()) {
                    if (!activePlayers.has(playerId)) {
                        scene.remove(player.mesh);
                        player.mesh.remove(player.label);
                        players.delete(playerId);
                    }
                }
            });
            
            // 2. Listener para Bloques (Simplificado)
            const blocksRef = ref(db, `worlds/${worldName}/blocks`);
            
            // Al añadir un bloque online, actualiza el chunk localmente
            blocksListener.added = onChildAdded(blocksRef, (snapshot) => {
                const data = snapshot.val();
                setBlockType(data.x, data.y, data.z, data.type, false); // No notificar a Firebase de vuelta
                regenerateAffectedChunkMeshes(data.x, data.y, data.z);
            });
            
            // Al quitar un bloque online, actualiza el chunk localmente
            blocksListener.removed = onChildRemoved(blocksRef, (snapshot) => {
                const data = snapshot.val();
                setBlockType(data.x, data.y, data.z, null, false); // null = aire
                regenerateAffectedChunkMeshes(data.x, data.y, data.z);
            });
        }
        
        // --- FUNCIONES DE CHUNKS Y MESHING ---

        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }
        
        // Obtiene el TIPO de bloque en coordenadas globales
        function getBlockType(x, y, z) {
            const chunkX = Math.floor(x / chunkSize);
            const chunkZ = Math.floor(z / chunkSize);
            const chunkKey = getChunkKey(chunkX, chunkZ);
            
            const chunkData = worldData.get(chunkKey);
            if (!chunkData) return null; // Chunk no cargado
            
            const localX = x - chunkX * chunkSize;
            const localY = y + chunkHeight / 2; // Ajuste por rango -64 a 64
            const localZ = z - chunkZ * chunkSize;
            
            if (localX < 0 || localX >= chunkSize || 
                localY < 0 || localY >= chunkHeight || 
                localZ < 0 || localZ >= chunkSize) {
                return null; // Fuera de los límites del chunk (raro, pero seguro)
            }
            
            // CAMBIO: Acceder al array 3D
            return chunkData[localX][localY][localZ]; 
        }
        
        // Establece el TIPO de bloque en coordenadas globales
        function setBlockType(x, y, z, type, notifyFirebase = true) {
            const chunkX = Math.floor(x / chunkSize);
            const chunkZ = Math.floor(z / chunkSize);
            const chunkKey = getChunkKey(chunkX, chunkZ);
            
            let chunkData = worldData.get(chunkKey);
            if (!chunkData) {
                // Si el chunk no existe (p.ej., al poner el primer bloque), crearlo
                chunkData = createEmptyChunkData();
                worldData.set(chunkKey, chunkData);
            }
            
            const localX = x - chunkX * chunkSize;
            const localY = y + chunkHeight / 2; // Ajuste
            const localZ = z - chunkZ * chunkSize;
            
            if (localX < 0 || localX >= chunkSize || 
                localY < 0 || localY >= chunkHeight || 
                localZ < 0 || localZ >= chunkSize) {
                console.error("Intento de escribir fuera de los límites del chunk", x, y, z);
                return; 
            }
            
            // CAMBIO: Actualizar el array 3D
            chunkData[localX][localY][localZ] = type;
            
            // Notificar a Firebase si es necesario
            if (notifyFirebase && db && worldName) {
                const blockKey = `${x}_${y}_${z}`;
                const blockRef = ref(db, `worlds/${worldName}/blocks/${blockKey}`);
                if (type) {
                    set(blockRef, { x, y, z, type: type });
                } else {
                    remove(blockRef);
                }
            }
        }
        
        // Crea la estructura de datos vacía para un chunk
        function createEmptyChunkData() {
            // CAMBIO: Array 3D [x][y][z]
            const chunkData = [];
            for (let x = 0; x < chunkSize; x++) {
                chunkData[x] = [];
                for (let y = 0; y < chunkHeight; y++) {
                    chunkData[x][y] = [];
                    for (let z = 0; z < chunkSize; z++) {
                        chunkData[x][y][z] = null; // null representa aire
                    }
                }
            }
            return chunkData;
        }

        
        function generateTree(x, y, z) {
            // Tronco
            const height = Math.floor(Math.random() * 2) + 4; // 4-5 bloques de alto
            for (let i = 0; i < height; i++) {
                 // CAMBIO: Usar setBlockType para guardar DATOS
                setBlockType(x, y + i, z, 'oak_log', false); 
            }
            
            // Hojas
            const radius = 2;
            for (let lx = -radius; lx <= radius; lx++) {
                for (let ly = -1; ly <= radius; ly++) { 
                    for (let lz = -radius; lz <= radius; lz++) {
                        if (lx*lx + (ly-1)*(ly-1) + lz*lz < (radius * radius + 1)) {
                            if (Math.random() > 0.2) { 
                                const leafX = x + lx;
                                const leafY = y + height + ly -1;
                                const leafZ = z + lz;
                                if (!getBlockType(leafX, leafY, leafZ)) {
                                     // CAMBIO: Usar setBlockType
                                    setBlockType(leafX, leafY, leafZ, 'oak_leaves', false);
                                }
                            }
                        }
                    }
                }
            }
        }

        function loadChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            // CAMBIO: Comprobar si los DATOS ya existen
            if (worldData.has(chunkKey)) {
                return;
            }

            // CAMBIO: Crear datos, no mallas
            const chunkData = createEmptyChunkData();
            worldData.set(chunkKey, chunkData); 
            
            const startX = chunkX * chunkSize;
            const startZ = chunkZ * chunkSize;

            for (let x = 0; x < chunkSize; x++) {
                for (let z = 0; z < chunkSize; z++) {
                    const worldX = startX + x;
                    const worldZ = startZ + z;
                    
                    const noiseVal = noise.noise2D(worldX * terrainScale, worldZ * terrainScale);
                    const height = THREE.MathUtils.mapLinear(noiseVal, -1, 1, 0, terrainHeight);
                    const surfaceY = Math.floor(height);

                    // Generar terreno base hasta la superficie
                    for (let y = worldDepth; y <= surfaceY; y++) {
                         // CAMBIO: Usar setBlockType, no addBlock
                         let blockType;
                         if (y === surfaceY) {
                             blockType = 'grass';
                         } else if (y > surfaceY - 4) {
                             blockType = 'dirt';
                         } else {
                             // --- Lógica de Cuevas y Minerales ---
                             const caveNoiseScale = 0.08;
                             const caveNoise = noise.noise3D(
                                 worldX * caveNoiseScale, 
                                 y * caveNoiseScale * 2, // Hacer las cuevas más estiradas verticalmente
                                 worldZ * caveNoiseScale
                             );
                             
                             // CAMBIO: Ajustar umbral para MÁS cuevas
                             const caveThreshold = 0.55; 
                             if (caveNoise > caveThreshold) {
                                 continue; // Aire (cueva)
                             }
                             
                             blockType = 'stone';
                             const oreRand = Math.random();
                             
                             if (oreRand < 0.03 && y < surfaceY - 2) blockType = 'coal_ore';
                             else if (oreRand < 0.05 && y < -5) blockType = 'iron_ore';
                             else if (oreRand < 0.06 && y < -10) blockType = Math.random() < 0.5 ? 'gold_ore' : 'lapis_ore';
                             else if (oreRand < 0.07 && y < -12) blockType = 'redstone_ore';
                             else if (oreRand < 0.075 && y < -15) blockType = Math.random() < 0.5 ? 'diamond_ore' : 'emerald_ore';
                         }
                         setBlockType(worldX, y, blockType, false);
                    }
                    
                    // Generar Árboles
                    if (x > 1 && x < chunkSize - 2 && z > 1 && z < chunkSize - 2) {
                        if (surfaceY >= worldDepth && surfaceY < terrainHeight && Math.random() < 0.01) { 
                            generateTree(worldX, surfaceY + 1, worldZ); // CAMBIO: No pasar chunkBlocks
                        }
                    }
                }
            }
            
            // CAMBIO: Generar la malla DESPUÉS de crear los datos
            generateChunkMesh(chunkX, chunkZ);
        }

        function unloadChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            // CAMBIO: Quitar malla y datos
            if (chunkMeshes.has(chunkKey)) {
                scene.remove(chunkMeshes.get(chunkKey));
                chunkMeshes.delete(chunkKey);
            }
            if (worldData.has(chunkKey)) {
                worldData.delete(chunkKey);
            }
        }
        
        // --- NUEVA FUNCIÓN: Generar Malla del Chunk ---
        function generateChunkMesh(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            const chunkData = worldData.get(chunkKey);
            if (!chunkData) return; // No hay datos para generar

            // Eliminar malla antigua si existe
            if (chunkMeshes.has(chunkKey)) {
                scene.remove(chunkMeshes.get(chunkKey));
            }
            
            const startX = chunkX * chunkSize;
            const startZ = chunkZ * chunkSize;
            
            const positions = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            const groups = []; // Para multi-material
            
            let groupMaterialIndex = -1;
            let groupStart = 0;
            let groupCount = 0;
            let currentIndex = 0;
            
            const processedMaterials = new Map(); // Mapa [materialIndex, { start, count }]

            for (let x = 0; x < chunkSize; x++) {
                for (let y = 0; y < chunkHeight; y++) {
                    for (let z = 0; z < chunkSize; z++) {
                        const blockType = chunkData[x][y][z];
                        if (!blockType || blockType === 'oak_leaves') continue; // Ignorar aire y hojas por ahora

                        const worldX = startX + x;
                        const worldY = y - chunkHeight / 2; // Convertir de vuelta a coords de mundo
                        const worldZ = startZ + z;
                        
                        const materialIndices = blockMaterialIndices[blockType];
                        if (!materialIndices) continue; // Bloque desconocido

                        // Comprobar las 6 caras
                        for (let i = 0; i < faces.length; i++) {
                            const face = faces[i];
                            const neighborX = worldX + face.dir[0];
                            const neighborY = worldY + face.dir[1];
                            const neighborZ = worldZ + face.dir[2];
                            
                            const neighborType = getBlockType(neighborX, neighborY, neighborZ);
                            
                            // Si el vecino es aire o transparente (hojas), añadir esta cara
                            if (!neighborType || neighborType === 'oak_leaves') {
                                const materialIndex = materialIndices[i];
                                
                                // Añadir vértices
                                for (const vert of face.vertices) {
                                    positions.push(worldX + vert[0] - 0.5, worldY + vert[1] - 0.5, worldZ + vert[2] - 0.5);
                                    normals.push(face.dir[0], face.dir[1], face.dir[2]);
                                }
                                
                                // Añadir UVs (simple, para toda la cara)
                                uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                                
                                // Añadir índices (2 triángulos)
                                indices.push(currentIndex, currentIndex + 1, currentIndex + 2);
                                indices.push(currentIndex, currentIndex + 2, currentIndex + 3);
                                
                                // Gestionar grupos de material
                                let groupInfo = processedMaterials.get(materialIndex);
                                if (!groupInfo) {
                                    groupInfo = { start: indices.length - 6, count: 0 };
                                    processedMaterials.set(materialIndex, groupInfo);
                                }
                                groupInfo.count += 6; // 6 índices por cara
                                
                                currentIndex += 4; // 4 vértices por cara
                            }
                        }
                    }
                }
            }
            
            if (positions.length === 0) return; // Chunk vacío

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            
            // Añadir grupos
            processedMaterials.forEach((groupInfo, materialIndex) => {
                 geometry.addGroup(groupInfo.start, groupInfo.count, materialIndex);
            });
            
            geometry.computeBoundingSphere(); // Necesario para frustum culling
            
            // Crear malla con multi-material
            const chunkMesh = new THREE.Mesh(geometry, blockMaterials); 
            chunkMesh.castShadow = true;
            chunkMesh.receiveShadow = true;
            
            scene.add(chunkMesh);
            chunkMeshes.set(chunkKey, chunkMesh);
        }
        
        // Regenera la malla del chunk y los vecinos afectados si es necesario
        function regenerateAffectedChunkMeshes(worldX, worldY, worldZ) {
            const chunkX = Math.floor(worldX / chunkSize);
            const chunkZ = Math.floor(worldZ / chunkSize);
            
            generateChunkMesh(chunkX, chunkZ); // Regenerar el chunk principal
            
            // Comprobar si el bloque estaba en un borde y regenerar vecinos
            const localX = worldX - chunkX * chunkSize;
            const localZ = worldZ - chunkZ * chunkSize;
            
            if (localX === 0) generateChunkMesh(chunkX - 1, chunkZ);
            if (localX === chunkSize - 1) generateChunkMesh(chunkX + 1, chunkZ);
            if (localZ === 0) generateChunkMesh(chunkX, chunkZ - 1);
            if (localZ === chunkSize - 1) generateChunkMesh(chunkX, chunkZ + 1);
        }

        // --- FIN FUNCIONES DE CHUNKS Y MESHING ---


        // CAMBIO: addBlock y removeBlock ahora solo modifican DATOS y regeneran mallas
        
        function addBlock(x, y, z, blockType, notifyFirebase = true) {
            if (y > terrainHeight + 10 || y < worldDepth) return; 
            
            setBlockType(x, y, z, blockType, notifyFirebase);
            regenerateAffectedChunkMeshes(x, y, z);
        }

        function removeBlock(x, y, z, notifyFirebase = true) {
            const currentType = getBlockType(x, y, z);
            if (!currentType || currentType === 'oak_leaves') return null; // No se puede romper aire u hojas
            
            setBlockType(x, y, z, null, notifyFirebase); // null = aire
            regenerateAffectedChunkMeshes(x, y, z);
            
            return currentType; // Devuelve el tipo de bloque roto para el drop
        }
        
        function updatePlayerBox(position) {
            playerBox.setFromCenterAndSize(
                position,
                new THREE.Vector3(playerWidth * 2, playerHeight, playerWidth * 2)
            );
            playerBox.min.y = position.y - (playerHeight / 2);
            playerBox.max.y = position.y + (playerHeight / 2);
        }

        // CAMBIO: checkCollision ahora usa getBlockType
        function checkCollision() {
            const minX = Math.floor(playerBox.min.x);
            const maxX = Math.ceil(playerBox.max.x);
            const minY = Math.floor(playerBox.min.y);
            const maxY = Math.ceil(playerBox.max.y);
            const minZ = Math.floor(playerBox.min.z);
            const maxZ = Math.ceil(playerBox.max.z);

            for (let x = minX; x < maxX; x++) {
                for (let y = minY; y < maxY; y++) {
                    for (let z = minZ; z < maxZ; z++) {
                        const blockType = getBlockType(x, y, z);
                        if (blockType && blockType !== 'oak_leaves') { // Ignorar aire y hojas
                            boxMin.set(x - 0.5, y - 0.5, z - 0.5);
                            boxMax.set(x + 0.5, y + 0.5, z + 0.5);
                            collisionCheckBlockBox.set(boxMin, boxMax);
                            
                            if (playerBox.intersectsBox(collisionCheckBlockBox)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }


        function updateChunks() {
            const playerPos = controls.getObject().position;
            const chunkX = Math.floor(playerPos.x / chunkSize);
            const chunkZ = Math.floor(playerPos.z / chunkSize);

            if (currentChunk.x === chunkX && currentChunk.y === chunkZ) {
                return; 
            }
            
            currentChunk.set(chunkX, chunkZ); 

            for (let x = chunkX - renderDistance; x <= chunkX + renderDistance; x++) {
                for (let z = chunkZ - renderDistance; z <= chunkZ + renderDistance; z++) {
                    loadChunk(x, z); // Ahora carga datos y genera malla
                }
            }

            // CAMBIO: Comprobar worldData en lugar de worldBlocks
            for (const chunkKey of worldData.keys()) {
                const [cx, cz] = chunkKey.split(',').map(Number);
                const dist_x = Math.abs(cx - chunkX);
                const dist_z = Math.abs(cz - chunkZ);
                
                if (dist_x > renderDistance || dist_z > renderDistance) {
                    unloadChunk(cx, cz); // Ahora quita malla y datos
                }
            }
        }


        // --- Bucle del Juego (Animación) ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            
            let delta = (time - prevTime) / 1000;
            delta = Math.min(delta, 0.05); 

            if (controls.isLocked === true) {
                
                updateChunks();

                lastPlayerVelY = playerVelocity.y;

                // Fricción
                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                // Gravedad
                playerVelocity.y += gravity * delta;
                
                // Dirección
                playerDirection.z = Number(moveForward) - Number(moveBackward);
                playerDirection.x = Number(moveRight) - Number(moveLeft);
                playerDirection.normalize(); 

                // Aplicar movimiento
                if (moveForward || moveBackward) playerVelocity.z -= playerDirection.z * moveSpeed * delta;
                if (moveLeft || moveRight) playerVelocity.x -= playerDirection.x * moveSpeed * delta;

                // Colisión por ejes
                const playerPos = controls.getObject().position;
                const deltaVelX = -playerVelocity.x * delta;
                const deltaVelZ = -playerVelocity.z * delta;
                const deltaVelY = playerVelocity.y * delta;

                controls.moveRight(deltaVelX);
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    controls.moveRight(-deltaVelX); 
                    playerVelocity.x = 0;
                }

                controls.moveForward(deltaVelZ);
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    controls.moveForward(-deltaVelZ); 
                    playerVelocity.z = 0;
                }

                playerPos.y += deltaVelY;
                updatePlayerBox(playerPos);
                if (checkCollision()) {
                    playerPos.y -= deltaVelY; 
                    if (lastPlayerVelY < 0) {
                        canJump = true; 
                        handleFallDamage(lastPlayerVelY); 
                    }
                    playerVelocity.y = 0;
                } else {
                    canJump = false;
                }
                
                // CAMBIO: Raycasting ahora intersecta las mallas de los chunks
                raycaster.setFromCamera({x:0, y:0}, camera); 
                const meshesToIntersect = Array.from(chunkMeshes.values());
                const intersects = raycaster.intersectObjects(meshesToIntersect);

                // Lógica de Minería
                if (isMining) {
                    let blockToMineCoords = null;
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        // Calcular coordenadas del bloque golpeado
                        const hitPos = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.1));
                        hitPos.floor(); 
                        
                        const blockType = getBlockType(hitPos.x, hitPos.y, hitPos.z);
                        
                        if (blockType && blockType !== 'oak_leaves') {
                             blockToMineCoords = hitPos;
                        }
                    }
                    
                    if (blockToMineCoords) {
                        // Empezar a minar o continuar
                        if (!currentMiningBlockCoords || !currentMiningBlockCoords.equals(blockToMineCoords)) {
                            // Empezar a minar un bloque nuevo
                            currentMiningBlockCoords = blockToMineCoords.clone();
                            miningTimer = 0;
                            
                            if (breakingBlockOverlay) scene.remove(breakingBlockOverlay);
                            breakingBlockOverlay = new THREE.Mesh(blockGeometry, breakingMaterial.clone());
                            // Posicionar el overlay en el centro del bloque
                            breakingBlockOverlay.position.copy(currentMiningBlockCoords); 
                            breakingBlockOverlay.renderOrder = 1; 
                            breakingBlockOverlay.material.map = destroyTextures[0];
                            scene.add(breakingBlockOverlay);
                        } 
                        else {
                            // Continuar minando el mismo bloque
                            miningTimer += delta;
                            const breakStage = Math.min(9, Math.floor((miningTimer / blockBreakTime) * 10));
                            
                            if (breakingBlockOverlay) {
                                breakingBlockOverlay.material.map = destroyTextures[breakStage];
                                breakingBlockOverlay.material.needsUpdate = true;
                            }

                            if (miningTimer >= blockBreakTime) {
                                // Bloque roto
                                const blockType = removeBlock(currentMiningBlockCoords.x, currentMiningBlockCoords.y, currentMiningBlockCoords.z, true); 
                                const dropType = getBlockDrop(blockType);
                                if (dropType) {
                                    addToInventory(dropType, 1);
                                }
                                stopMining(); // Resetea currentMiningBlockCoords
                            }
                        }
                    } else {
                        // Se dejó de apuntar a un bloque válido
                        stopMining();
                    }
                }
                
                // Actualizar posición en Firebase
                if (worldName && db && userId && time - lastFirebaseUpdate > 200) { 
                    lastFirebaseUpdate = time;
                    const pos = controls.getObject().position;
                    const playerRef = ref(db, `worlds/${worldName}/players/${userId}`);
                    set(playerRef, { 
                        x: pos.x, 
                        y: pos.y, 
                        z: pos.z, 
                        timestamp: serverTimestamp(),
                        username: userName
                    });
                }
                
                // Caída al vacío
                if (playerPos.y < worldDepth - 20) { // Ajustar límite
                    respawnPlayer();
                }
            }
            
            prevTime = time;

            renderer.render(scene, camera);
            if (labelRenderer) {
                labelRenderer.render(scene, camera);
            }
        }
        
        // "Drops" de Bloques
        function getBlockDrop(blockType) {
            switch (blockType) {
                case 'grass':
                case 'dirt':
                    return 'dirt';
                case 'stone':
                    return 'cobblestone';
                case 'oak_log':
                    return 'oak_log';
                case 'coal_ore':
                    return 'coal_ore'; // TODO: Cambiar a 'coal'
                case 'iron_ore':
                    return 'iron_ore';
                case 'gold_ore':
                    return 'gold_ore';
                case 'lapis_ore':
                    return 'lapis_ore';
                case 'redstone_ore':
                    return 'redstone';
                case 'diamond_ore':
                    return 'diamond';
                case 'emerald_ore':
                    return 'emerald';
                case 'oak_planks':
                    return 'oak_planks';
                case 'crafting_table':
                    return 'crafting_table';
                case 'oak_leaves':
                    return null; // Hojas no dropean nada
                default:
                    return null; 
            }
        }
        
        // --- Lógica de Inventario (Añadir / Encontrar) ---
        
        function addToInventory(itemType, quantity) {
            let remaining = quantity;
            
            // 1. Apilar en slots existentes (36)
            for (let i = 0; i < 36; i++) {
                const slot = inventory[i];
                if (slot.type === itemType && slot.quantity < 64) {
                    const canAdd = 64 - slot.quantity;
                    const toAdd = Math.min(remaining, canAdd);
                    slot.quantity += toAdd;
                    remaining -= toAdd;
                    if (remaining === 0) break;
                }
            }
            
            // 2. Buscar slots vacíos
            if (remaining > 0) {
                for (let i = 0; i < 36; i++) {
                    const slot = inventory[i];
                    if (slot.type === null || slot.quantity === 0) {
                        slot.type = itemType;
                        const toAdd = Math.min(remaining, 64);
                        slot.quantity = toAdd; 
                        remaining -= toAdd;
                        if (remaining === 0) break;
                    }
                }
            }
            
            // 3. Actualizar UI y guardar
            updateHotbarInventoryUI(); 
            if (isCrafting) {
                updateFullInventoryUI();
            }
            saveInventory();
            
            if (remaining > 0) {
                 console.log("Inventario lleno!");
            }
            return remaining;
        }

        
        function stopMining() {
            miningTimer = 0;
            currentMiningBlockCoords = null; // CAMBIO: Usar coordenadas
            if (breakingBlockOverlay) {
                scene.remove(breakingBlockOverlay);
                breakingBlockOverlay = null;
            }
        }

        // --- Manejadores de Eventos ---

        function onKeyDown(event) {
            if (isCrafting) {
                // Si el inventario está abierto
                if (event.code === 'KeyE' || event.code === 'Escape') {
                    closeCraftingUI();
                }
                return;
            }
            
            // Si el juego está activo
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    if (canJump === true) playerVelocity.y += jumpForce;
                    canJump = false;
                    break;
                case 'KeyE':
                    if (controls.isLocked) {
                        openCraftingUI(false); // Abrir inventario 2x2
                    }
                    break;
                
                // Controles de Hotbar (1-9)
                case 'Digit1': selectedSlot = 0; updateHotbarActiveSlotUI(); break;
                case 'Digit2': selectedSlot = 1; updateHotbarActiveSlotUI(); break;
                case 'Digit3': selectedSlot = 2; updateHotbarActiveSlotUI(); break;
                case 'Digit4': selectedSlot = 3; updateHotbarActiveSlotUI(); break;
                case 'Digit5': selectedSlot = 4; updateHotbarActiveSlotUI(); break;
                case 'Digit6': selectedSlot = 5; updateHotbarActiveSlotUI(); break;
                case 'Digit7': selectedSlot = 6; updateHotbarActiveSlotUI(); break;
                case 'Digit8': selectedSlot = 7; updateHotbarActiveSlotUI(); break;
                case 'Digit9': selectedSlot = 8; updateHotbarActiveSlotUI(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        function onMouseDown(event) {
            if (!controls.isLocked || isCrafting) return; 
            
            // Botón Izquierdo (0): Iniciar minería
            if (event.button === 0) {
                isMining = true;
                // La lógica de qué minar se hace en animate()
            } 
            
            // Botón Derecho (2): Poner bloque / Interactuar
            else if (event.button === 2) {
                stopMining(); 
                
                const selectedItem = inventory[selectedSlot];
                
                raycaster.setFromCamera({x:0, y:0}, camera); 
                const meshesToIntersect = Array.from(chunkMeshes.values());
                const intersects = raycaster.intersectObjects(meshesToIntersect);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    // Calcular coordenadas del bloque ADYACENTE donde poner
                    const placePos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.1));
                    placePos.floor(); 
                    
                    const targetBlockPos = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.1));
                    targetBlockPos.floor();
                    
                    const targetBlockType = getBlockType(targetBlockPos.x, targetBlockPos.y, targetBlockPos.z);
                    
                    // Click derecho en Mesa de Crafteo
                    if (targetBlockType === 'crafting_table') {
                        event.preventDefault(); 
                        openCraftingUI(true); // Abrir UI 3x3
                        return;
                    }
                    
                    // Si no hay item o es un item, no se puede poner
                    if (!selectedItem || selectedItem.quantity <= 0 || itemTypes.has(selectedItem.type)) {
                        return;
                    }
                    
                    if (targetBlockType === 'oak_leaves') return; // No se puede poner pegado a hojas
                    
                    // Comprobar colisión con el jugador antes de poner
                    const newBlockBox = new THREE.Box3(
                        placePos.clone().subScalar(0.5),
                        placePos.clone().addScalar(0.5)
                    );

                    updatePlayerBox(controls.getObject().position); // Asegurarse de que playerBox esté actualizado

                    if (!playerBox.intersectsBox(newBlockBox)) {
                        // Añadir bloque al mundo (solo datos, la malla se regenera)
                        addBlock(placePos.x, placePos.y, placePos.z, selectedItem.type, true);
                        
                        // Restar del inventario
                        selectedItem.quantity--;
                        if (selectedItem.quantity === 0) {
                            selectedItem.type = null;
                        }
                        updateHotbarInventoryUI();
                        saveInventory();
                    }
                }
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Botón Izquierdo
                isMining = false;
                stopMining(); // Limpiar UI y estado
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Funciones de Vida y Daño ---
        
        function setupHealthBar() {
            const healthBar = document.getElementById('health-bar');
            healthBar.innerHTML = '';
            for(let i = 0; i < playerMaxHealth / 2; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                healthBar.appendChild(heart);
            }
            updateHealthUI();
        }

        function updateHealthUI() {
            const hearts = document.querySelectorAll('#health-bar .heart');
            const fullHearts = Math.floor(playerHealth / 2);
            
            hearts.forEach((heart, index) => {
                if (index < fullHearts) {
                    heart.textContent = '❤️';
                } else {
                    heart.textContent = '🖤';
                }
            });
        }
        
        function handleFallDamage(fallVelocity) {
            const damageThreshold = -15; 
            if (fallVelocity < damageThreshold) {
                const damage = Math.round(Math.abs(fallVelocity) - Math.abs(damageThreshold));
                takeDamage(damage);
            }
        }
        
        function takeDamage(amount) {
            playerHealth -= amount;
            if (playerHealth < 0) playerHealth = 0;
            updateHealthUI();
            if (playerHealth === 0) {
                respawnPlayer();
            }
        }
        
        function respawnPlayer() {
            playerHealth = playerMaxHealth;
            updateHealthUI();
            controls.getObject().position.set(0, terrainHeight + 5, 0); 
            playerVelocity.set(0, 0, 0);
        }

        
        // --- Funciones de Hotbar (2D) ---

        function setupHotbar() {
            hotbarElement = document.getElementById('hotbar');
            
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot slot';
                
                const icon = document.createElement('img');
                icon.className = 'item-icon';
                slot.appendChild(icon);
                
                const quantityDiv = document.createElement('span');
                quantityDiv.className = 'item-quantity';
                slot.appendChild(quantityDiv);
                
                hotbarElement.appendChild(slot);
                hotbarSlots.push(slot); 
            }
            updateHotbarActiveSlotUI();
        }
        
        function updateHotbarInventoryUI() {
            if (!inventory || inventory.length === 0) return;
            
            // Actualizar la hotbar IN-GAME (slots 0-8)
            for (let i = 0; i < 9; i++) {
                const slotData = inventory[i];
                const slotElement = hotbarSlots[i];
                renderSlot(slotElement, slotData);
            }
            
            if (isCrafting) {
                updateFullInventoryUI();
            }
        }

        function updateHotbarActiveSlotUI() {
            for (let i = 0; i < 9; i++) {
                const slot = hotbarSlots[i];
                if (i === selectedSlot) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            }
        }

        function onMouseWheel(event) {
            if (isCrafting) return; // No cambiar de slot con el inventario abierto
            stopMining(); 
            
            if (event.deltaY > 0) {
                selectedSlot++;
            } else {
                selectedSlot--;
            }

            if (selectedSlot > 8) selectedSlot = 0;
            if (selectedSlot < 0) selectedSlot = 8;

            updateHotbarActiveSlotUI();
        }
        
        
        // --- Lógica de Inventario y Crafteo (Drag-and-Drop) ---
        
        function initInventoryUI() {
            itemCursorElement = document.getElementById('item-cursor');
            playerInventoryGrid = document.getElementById('player-inventory-grid');
            playerHotbarGrid = document.getElementById('player-hotbar-grid');
            craftingGridElement = document.getElementById('crafting-grid');
            resultSlotElement = document.querySelector('[data-slot-type="result"]');
            
            // Crear slots del inventario (27)
            for (let i = 9; i < 36; i++) {
                playerInventoryGrid.appendChild(createSlot('inventory', i));
            }
            
            // Crear slots de la hotbar (en el inventario) (9)
            for (let i = 0; i < 9; i++) {
                playerHotbarGrid.appendChild(createSlot('inventory', i));
            }
        }
        
        function createSlot(type, index) {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.slotType = type;
            slot.dataset.slotIndex = index;
            
            const icon = document.createElement('img');
            icon.className = 'item-icon';
            slot.appendChild(icon);
            
            const quantity = document.createElement('span');
            quantity.className = 'item-quantity';
            slot.appendChild(quantity);
            
            return slot;
        }
        
        // Renderiza un item en un slot (HTML)
        function renderSlot(element, item) {
            const icon = element.querySelector('.item-icon');
            const quantity = element.querySelector('.item-quantity');
            
            if (item && item.type) {
                icon.src = `${textureBaseUrl}${item.type}.png`;
                icon.style.display = 'block';
                
                if (item.quantity > 1) {
                    quantity.textContent = item.quantity;
                    quantity.style.display = 'block';
                } else {
                    quantity.style.display = 'none';
                }
            } else {
                icon.src = '';
                icon.style.display = 'none';
                quantity.style.display = 'none';
            }
        }
        
        // Mueve el item del cursor
        function onDragCursor(event) {
            if (heldItem.type) {
                // CORRECCIÓN: Usar translate para centrar el item en el cursor
                itemCursorElement.style.transform = `translate(${event.clientX - 25}px, ${event.clientY - 25}px)`;
            }
        }
        
        // Click izquierdo en un slot
        function onSlotClick(event) {
            event.preventDefault();
            const slotElement = event.target.closest('.slot');
            if (!slotElement) return;
            
            const { slotType, slotIndex } = slotElement.dataset;
            handleSlotInteraction(slotType, parseInt(slotIndex), 'left');
        }
        
        // Click derecho en un slot
        function onSlotRightClick(event) {
            event.preventDefault();
            const slotElement = event.target.closest('.slot');
            if (!slotElement) return;
            
            const { slotType, slotIndex } = slotElement.dataset;
            handleSlotInteraction(slotType, parseInt(slotIndex), 'right');
        }
        
        // Lógica principal de Drag-and-Drop
        function handleSlotInteraction(type, index, clickType) {
            let targetSlot;
            let gridType = 'inventory'; // Para saber si hay que recalcular crafteo
            
            const craftGridMapping2x2 = [0, 1, 3, 4]; // Índices HTML
            
            if (type === 'inventory') {
                targetSlot = inventory[index];
            } else if (type === 'crafting') {
                gridType = 'crafting';
                if (currentCraftingType === '2x2') {
                    const logicalIndex = craftGridMapping2x2.indexOf(index);
                    if (logicalIndex === -1) return; 
                    targetSlot = craftingGrid2x2[logicalIndex];
                } else {
                    targetSlot = craftingGrid3x3[index];
                }
            } else if (type === 'result') {
                gridType = 'crafting'; // Afecta al crafteo
                targetSlot = (currentCraftingType === '2x2') ? resultSlot2x2 : resultSlot3x3;
                
                // Lógica de coger el resultado
                if (targetSlot && targetSlot.type) {
                    // Si el cursor está vacío O se puede apilar
                    if (!heldItem.type || (heldItem.type === targetSlot.type && heldItem.quantity + targetSlot.quantity <= 64)) {
                        
                        if (!heldItem.type) {
                            heldItem = { ...targetSlot };
                        } else {
                            heldItem.quantity += targetSlot.quantity;
                        }
                        
                        // Consumir ingredientes
                        const grid = (currentCraftingType === '2x2') ? craftingGrid2x2 : craftingGrid3x3;
                        grid.forEach(slot => {
                            if (slot.type) {
                                slot.quantity--;
                                if (slot.quantity === 0) slot.type = null;
                            }
                        });
                        
                        checkRecipes(); // Recalcular (limpiará el slot de resultado)
                    }
                }
                updateFullInventoryUI();
                updateCursorItem();
                return;
            } else {
                return;
            }
            
            if (!targetSlot) {
                console.warn("Target slot no encontrado:", type, index, currentCraftingType);
                return;
            }

            // --- Lógica de Click Izquierdo ---
            if (clickType === 'left') {
                if (heldItem.type) {
                    // Soltar
                    if (!targetSlot.type) {
                        targetSlot.type = heldItem.type;
                        targetSlot.quantity = heldItem.quantity;
                        heldItem = { type: null, quantity: 0 };
                    } 
                    // Apilar
                    else if (targetSlot.type === heldItem.type) {
                        const canAdd = 64 - targetSlot.quantity;
                        const toAdd = Math.min(heldItem.quantity, canAdd);
                        targetSlot.quantity += toAdd;
                        heldItem.quantity -= toAdd;
                        if (heldItem.quantity === 0) heldItem.type = null;
                    }
                    // Intercambiar
                    else {
                        const temp = { ...targetSlot };
                        targetSlot.type = heldItem.type;
                        targetSlot.quantity = heldItem.quantity;
                        heldItem = temp;
                    }
                }
                // Coger
                else if (targetSlot.type) {
                    heldItem = { ...targetSlot };
                    targetSlot.type = null;
                    targetSlot.quantity = 0;
                }
            }
            // --- Lógica de Click Derecho ---
            else if (clickType === 'right') {
                if (heldItem.type) {
                    // Soltar 1
                    if (!targetSlot.type) {
                        targetSlot.type = heldItem.type;
                        targetSlot.quantity = 1;
                        heldItem.quantity--;
                    }
                    // Apilar 1
                    else if (targetSlot.type === heldItem.type && targetSlot.quantity < 64) {
                        targetSlot.quantity++;
                        heldItem.quantity--;
                    }
                    if (heldItem.quantity === 0) heldItem.type = null;
                }
                // Coger la mitad
                else if (targetSlot.type) {
                    const half = Math.ceil(targetSlot.quantity / 2);
                    heldItem.type = targetSlot.type;
                    heldItem.quantity = half;
                    targetSlot.quantity -= half;
                    if (targetSlot.quantity === 0) targetSlot.type = null;
                }
            }
            
            // Actualizar todo
            if (gridType === 'crafting') checkRecipes();
            updateFullInventoryUI();
            updateCursorItem();
            if (type === 'inventory') saveInventory(); // Guardar si se tocó el inventario principal
        }
        
        // Actualiza el item del cursor
        function updateCursorItem() {
            if (heldItem.type) {
                renderSlot(itemCursorElement, heldItem);
                itemCursorElement.style.display = 'flex';
            } else {
                itemCursorElement.style.display = 'none';
            }
        }
        
        // --- Funciones de la UI de Crafteo ---
        
        function openCraftingUI(isTable) {
            isCrafting = true;
            controls.unlock();
            
            currentCraftingType = isTable ? '3x3' : '2x2';
            
            const modal = document.getElementById('inventory-modal');
            const title = document.getElementById('inventory-title');
            const craftingGrid = document.getElementById('crafting-grid');
            
            // Limpiar grids lógicos
            craftingGrid2x2.forEach(s => { s.type = null; s.quantity = 0; });
            craftingGrid3x3.forEach(s => { s.type = null; s.quantity = 0; });
            
            if (isTable) {
                title.textContent = 'Mesa de Crafteo';
                craftingGrid.style.setProperty('--grid-cols', 3); // Usar variable CSS
                document.querySelectorAll('#crafting-grid .slot').forEach(s => s.style.display = 'flex');
            } else {
                title.textContent = 'Inventario';
                craftingGrid.style.setProperty('--grid-cols', 2);
                document.querySelectorAll('#crafting-grid .slot').forEach(s => {
                    s.style.display = s.classList.contains('slot-2x2') ? 'flex' : 'none';
                });
            }
            
            checkRecipes(); // Calcular resultado (vacío)
            updateFullInventoryUI();
            updateCursorItem();
            
            document.getElementById('inventory-screen').style.display = 'flex';
        }
        
        function closeCraftingUI() {
            isCrafting = false;
            controls.lock();
            document.getElementById('inventory-screen').style.display = 'none';
            
            // Devolver items del crafteo al inventario
            const grid = (currentCraftingType === '2x2') ? craftingGrid2x2 : craftingGrid3x3;
            grid.forEach(item => {
                if (item.type) {
                    addToInventory(item.type, item.quantity); // addToInventory ya guarda
                    item.type = null;
                    item.quantity = 0;
                }
            });
            
            // Devolver item del cursor
            if (heldItem.type) {
                addToInventory(heldItem.type, heldItem.quantity);
                heldItem = { type: null, quantity: 0 };
            }
            
            resultSlot2x2 = { type: null, quantity: 0 };
            resultSlot3x3 = { type: null, quantity: 0 };
            
            updateHotbarInventoryUI(); // Sincronizar hotbar in-game
            // saveInventory(); // No es necesario, addToInventory ya guardó
        }
        
        // Renderiza TODOS los slots en el modal de inventario
        function updateFullInventoryUI() {
            // Inventario principal (27 slots)
            for (let i = 9; i < 36; i++) {
                const slotElement = playerInventoryGrid.querySelector(`[data-slot-index="${i}"]`);
                renderSlot(slotElement, inventory[i]);
            }
            
            // Hotbar (9 slots)
            for (let i = 0; i < 9; i++) {
                const slotElement = playerHotbarGrid.querySelector(`[data-slot-index="${i}"]`);
                renderSlot(slotElement, inventory[i]);
            }
            
            // Grid de crafteo
            const gridSlots = craftingGridElement.querySelectorAll('[data-slot-type="crafting"]');
            
            if (currentCraftingType === '2x2') {
                const mapping = [0, 1, 3, 4]; // Índices HTML
                craftingGrid2x2.forEach((item, logicalIndex) => {
                    const htmlIndex = mapping[logicalIndex];
                    renderSlot(gridSlots[htmlIndex], item);
                });
            } else {
                craftingGrid3x3.forEach((item, index) => {
                    renderSlot(gridSlots[index], item);
                });
            }
            
            // Slot de resultado
            const resultSlot = (currentCraftingType === '2x2') ? resultSlot2x2 : resultSlot3x3;
            renderSlot(resultSlotElement, resultSlot);
        }
        
        // Comprueba las recetas
        function checkRecipes() {
            const grid = (currentCraftingType === '2x2') ? craftingGrid2x2 : craftingGrid3x3;
            const resultSlot = (currentCraftingType === '2x2') ? resultSlot2x2 : resultSlot3x3;
            
            let key;
            if (currentCraftingType === '2x2') {
                key = grid.map(slot => slot.type || 'null').join(',');
            } else {
                key = craftingGrid3x3.map(slot => slot.type || 'null').join(',');
            }
            
            const recipe = RECIPES[key];
            
            if (recipe) {
                resultSlot.type = recipe.result;
                resultSlot.quantity = recipe.count;
            } else {
                resultSlot.type = null;
                resultSlot.quantity = 0;
            }
            
            renderSlot(resultSlotElement, resultSlot);
        }

        // --- Iniciar el juego ---
        init();
    </script>
</body>
</html>
